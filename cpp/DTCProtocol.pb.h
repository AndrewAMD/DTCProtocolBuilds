// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DTCProtocol.proto

#ifndef PROTOBUF_INCLUDED_DTCProtocol_2eproto
#define PROTOBUF_INCLUDED_DTCProtocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_DTCProtocol_2eproto 

namespace protobuf_DTCProtocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[92];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_DTCProtocol_2eproto
namespace DTC_PB {
class AccountBalanceReject;
class AccountBalanceRejectDefaultTypeInternal;
extern AccountBalanceRejectDefaultTypeInternal _AccountBalanceReject_default_instance_;
class AccountBalanceRequest;
class AccountBalanceRequestDefaultTypeInternal;
extern AccountBalanceRequestDefaultTypeInternal _AccountBalanceRequest_default_instance_;
class AccountBalanceUpdate;
class AccountBalanceUpdateDefaultTypeInternal;
extern AccountBalanceUpdateDefaultTypeInternal _AccountBalanceUpdate_default_instance_;
class AlertMessage;
class AlertMessageDefaultTypeInternal;
extern AlertMessageDefaultTypeInternal _AlertMessage_default_instance_;
class CancelOrder;
class CancelOrderDefaultTypeInternal;
extern CancelOrderDefaultTypeInternal _CancelOrder_default_instance_;
class CancelReplaceOrder;
class CancelReplaceOrderDefaultTypeInternal;
extern CancelReplaceOrderDefaultTypeInternal _CancelReplaceOrder_default_instance_;
class CancelReplaceOrderInt;
class CancelReplaceOrderIntDefaultTypeInternal;
extern CancelReplaceOrderIntDefaultTypeInternal _CancelReplaceOrderInt_default_instance_;
class CurrentPositionsReject;
class CurrentPositionsRejectDefaultTypeInternal;
extern CurrentPositionsRejectDefaultTypeInternal _CurrentPositionsReject_default_instance_;
class CurrentPositionsRequest;
class CurrentPositionsRequestDefaultTypeInternal;
extern CurrentPositionsRequestDefaultTypeInternal _CurrentPositionsRequest_default_instance_;
class DepthEntry;
class DepthEntryDefaultTypeInternal;
extern DepthEntryDefaultTypeInternal _DepthEntry_default_instance_;
class EncodingRequest;
class EncodingRequestDefaultTypeInternal;
extern EncodingRequestDefaultTypeInternal _EncodingRequest_default_instance_;
class EncodingResponse;
class EncodingResponseDefaultTypeInternal;
extern EncodingResponseDefaultTypeInternal _EncodingResponse_default_instance_;
class ExchangeListRequest;
class ExchangeListRequestDefaultTypeInternal;
extern ExchangeListRequestDefaultTypeInternal _ExchangeListRequest_default_instance_;
class ExchangeListResponse;
class ExchangeListResponseDefaultTypeInternal;
extern ExchangeListResponseDefaultTypeInternal _ExchangeListResponse_default_instance_;
class GeneralLogMessage;
class GeneralLogMessageDefaultTypeInternal;
extern GeneralLogMessageDefaultTypeInternal _GeneralLogMessage_default_instance_;
class Heartbeat;
class HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class HistoricalAccountBalanceResponse;
class HistoricalAccountBalanceResponseDefaultTypeInternal;
extern HistoricalAccountBalanceResponseDefaultTypeInternal _HistoricalAccountBalanceResponse_default_instance_;
class HistoricalAccountBalancesReject;
class HistoricalAccountBalancesRejectDefaultTypeInternal;
extern HistoricalAccountBalancesRejectDefaultTypeInternal _HistoricalAccountBalancesReject_default_instance_;
class HistoricalAccountBalancesRequest;
class HistoricalAccountBalancesRequestDefaultTypeInternal;
extern HistoricalAccountBalancesRequestDefaultTypeInternal _HistoricalAccountBalancesRequest_default_instance_;
class HistoricalOrderFillResponse;
class HistoricalOrderFillResponseDefaultTypeInternal;
extern HistoricalOrderFillResponseDefaultTypeInternal _HistoricalOrderFillResponse_default_instance_;
class HistoricalOrderFillsReject;
class HistoricalOrderFillsRejectDefaultTypeInternal;
extern HistoricalOrderFillsRejectDefaultTypeInternal _HistoricalOrderFillsReject_default_instance_;
class HistoricalOrderFillsRequest;
class HistoricalOrderFillsRequestDefaultTypeInternal;
extern HistoricalOrderFillsRequestDefaultTypeInternal _HistoricalOrderFillsRequest_default_instance_;
class HistoricalPriceDataRecordResponse;
class HistoricalPriceDataRecordResponseDefaultTypeInternal;
extern HistoricalPriceDataRecordResponseDefaultTypeInternal _HistoricalPriceDataRecordResponse_default_instance_;
class HistoricalPriceDataRecordResponse_Int;
class HistoricalPriceDataRecordResponse_IntDefaultTypeInternal;
extern HistoricalPriceDataRecordResponse_IntDefaultTypeInternal _HistoricalPriceDataRecordResponse_Int_default_instance_;
class HistoricalPriceDataReject;
class HistoricalPriceDataRejectDefaultTypeInternal;
extern HistoricalPriceDataRejectDefaultTypeInternal _HistoricalPriceDataReject_default_instance_;
class HistoricalPriceDataRequest;
class HistoricalPriceDataRequestDefaultTypeInternal;
extern HistoricalPriceDataRequestDefaultTypeInternal _HistoricalPriceDataRequest_default_instance_;
class HistoricalPriceDataResponseHeader;
class HistoricalPriceDataResponseHeaderDefaultTypeInternal;
extern HistoricalPriceDataResponseHeaderDefaultTypeInternal _HistoricalPriceDataResponseHeader_default_instance_;
class HistoricalPriceDataResponseTrailer;
class HistoricalPriceDataResponseTrailerDefaultTypeInternal;
extern HistoricalPriceDataResponseTrailerDefaultTypeInternal _HistoricalPriceDataResponseTrailer_default_instance_;
class HistoricalPriceDataTickRecordResponse;
class HistoricalPriceDataTickRecordResponseDefaultTypeInternal;
extern HistoricalPriceDataTickRecordResponseDefaultTypeInternal _HistoricalPriceDataTickRecordResponse_default_instance_;
class HistoricalPriceDataTickRecordResponse_Int;
class HistoricalPriceDataTickRecordResponse_IntDefaultTypeInternal;
extern HistoricalPriceDataTickRecordResponse_IntDefaultTypeInternal _HistoricalPriceDataTickRecordResponse_Int_default_instance_;
class JournalEntriesReject;
class JournalEntriesRejectDefaultTypeInternal;
extern JournalEntriesRejectDefaultTypeInternal _JournalEntriesReject_default_instance_;
class JournalEntriesRequest;
class JournalEntriesRequestDefaultTypeInternal;
extern JournalEntriesRequestDefaultTypeInternal _JournalEntriesRequest_default_instance_;
class JournalEntryAdd;
class JournalEntryAddDefaultTypeInternal;
extern JournalEntryAddDefaultTypeInternal _JournalEntryAdd_default_instance_;
class JournalEntryResponse;
class JournalEntryResponseDefaultTypeInternal;
extern JournalEntryResponseDefaultTypeInternal _JournalEntryResponse_default_instance_;
class Logoff;
class LogoffDefaultTypeInternal;
extern LogoffDefaultTypeInternal _Logoff_default_instance_;
class LogonRequest;
class LogonRequestDefaultTypeInternal;
extern LogonRequestDefaultTypeInternal _LogonRequest_default_instance_;
class LogonResponse;
class LogonResponseDefaultTypeInternal;
extern LogonResponseDefaultTypeInternal _LogonResponse_default_instance_;
class MarketDataFeedStatus;
class MarketDataFeedStatusDefaultTypeInternal;
extern MarketDataFeedStatusDefaultTypeInternal _MarketDataFeedStatus_default_instance_;
class MarketDataFeedSymbolStatus;
class MarketDataFeedSymbolStatusDefaultTypeInternal;
extern MarketDataFeedSymbolStatusDefaultTypeInternal _MarketDataFeedSymbolStatus_default_instance_;
class MarketDataReject;
class MarketDataRejectDefaultTypeInternal;
extern MarketDataRejectDefaultTypeInternal _MarketDataReject_default_instance_;
class MarketDataRequest;
class MarketDataRequestDefaultTypeInternal;
extern MarketDataRequestDefaultTypeInternal _MarketDataRequest_default_instance_;
class MarketDataSnapshot;
class MarketDataSnapshotDefaultTypeInternal;
extern MarketDataSnapshotDefaultTypeInternal _MarketDataSnapshot_default_instance_;
class MarketDataSnapshot_Int;
class MarketDataSnapshot_IntDefaultTypeInternal;
extern MarketDataSnapshot_IntDefaultTypeInternal _MarketDataSnapshot_Int_default_instance_;
class MarketDataUpdateBidAsk;
class MarketDataUpdateBidAskDefaultTypeInternal;
extern MarketDataUpdateBidAskDefaultTypeInternal _MarketDataUpdateBidAsk_default_instance_;
class MarketDataUpdateBidAskCompact;
class MarketDataUpdateBidAskCompactDefaultTypeInternal;
extern MarketDataUpdateBidAskCompactDefaultTypeInternal _MarketDataUpdateBidAskCompact_default_instance_;
class MarketDataUpdateBidAsk_Int;
class MarketDataUpdateBidAsk_IntDefaultTypeInternal;
extern MarketDataUpdateBidAsk_IntDefaultTypeInternal _MarketDataUpdateBidAsk_Int_default_instance_;
class MarketDataUpdateLastTradeSnapshot;
class MarketDataUpdateLastTradeSnapshotDefaultTypeInternal;
extern MarketDataUpdateLastTradeSnapshotDefaultTypeInternal _MarketDataUpdateLastTradeSnapshot_default_instance_;
class MarketDataUpdateOpenInterest;
class MarketDataUpdateOpenInterestDefaultTypeInternal;
extern MarketDataUpdateOpenInterestDefaultTypeInternal _MarketDataUpdateOpenInterest_default_instance_;
class MarketDataUpdateSessionHigh;
class MarketDataUpdateSessionHighDefaultTypeInternal;
extern MarketDataUpdateSessionHighDefaultTypeInternal _MarketDataUpdateSessionHigh_default_instance_;
class MarketDataUpdateSessionHigh_Int;
class MarketDataUpdateSessionHigh_IntDefaultTypeInternal;
extern MarketDataUpdateSessionHigh_IntDefaultTypeInternal _MarketDataUpdateSessionHigh_Int_default_instance_;
class MarketDataUpdateSessionLow;
class MarketDataUpdateSessionLowDefaultTypeInternal;
extern MarketDataUpdateSessionLowDefaultTypeInternal _MarketDataUpdateSessionLow_default_instance_;
class MarketDataUpdateSessionLow_Int;
class MarketDataUpdateSessionLow_IntDefaultTypeInternal;
extern MarketDataUpdateSessionLow_IntDefaultTypeInternal _MarketDataUpdateSessionLow_Int_default_instance_;
class MarketDataUpdateSessionNumTrades;
class MarketDataUpdateSessionNumTradesDefaultTypeInternal;
extern MarketDataUpdateSessionNumTradesDefaultTypeInternal _MarketDataUpdateSessionNumTrades_default_instance_;
class MarketDataUpdateSessionOpen;
class MarketDataUpdateSessionOpenDefaultTypeInternal;
extern MarketDataUpdateSessionOpenDefaultTypeInternal _MarketDataUpdateSessionOpen_default_instance_;
class MarketDataUpdateSessionOpen_Int;
class MarketDataUpdateSessionOpen_IntDefaultTypeInternal;
extern MarketDataUpdateSessionOpen_IntDefaultTypeInternal _MarketDataUpdateSessionOpen_Int_default_instance_;
class MarketDataUpdateSessionSettlement;
class MarketDataUpdateSessionSettlementDefaultTypeInternal;
extern MarketDataUpdateSessionSettlementDefaultTypeInternal _MarketDataUpdateSessionSettlement_default_instance_;
class MarketDataUpdateSessionSettlement_Int;
class MarketDataUpdateSessionSettlement_IntDefaultTypeInternal;
extern MarketDataUpdateSessionSettlement_IntDefaultTypeInternal _MarketDataUpdateSessionSettlement_Int_default_instance_;
class MarketDataUpdateSessionVolume;
class MarketDataUpdateSessionVolumeDefaultTypeInternal;
extern MarketDataUpdateSessionVolumeDefaultTypeInternal _MarketDataUpdateSessionVolume_default_instance_;
class MarketDataUpdateTrade;
class MarketDataUpdateTradeDefaultTypeInternal;
extern MarketDataUpdateTradeDefaultTypeInternal _MarketDataUpdateTrade_default_instance_;
class MarketDataUpdateTradeCompact;
class MarketDataUpdateTradeCompactDefaultTypeInternal;
extern MarketDataUpdateTradeCompactDefaultTypeInternal _MarketDataUpdateTradeCompact_default_instance_;
class MarketDataUpdateTradeWithUnbundledIndicator;
class MarketDataUpdateTradeWithUnbundledIndicatorDefaultTypeInternal;
extern MarketDataUpdateTradeWithUnbundledIndicatorDefaultTypeInternal _MarketDataUpdateTradeWithUnbundledIndicator_default_instance_;
class MarketDataUpdateTrade_Int;
class MarketDataUpdateTrade_IntDefaultTypeInternal;
extern MarketDataUpdateTrade_IntDefaultTypeInternal _MarketDataUpdateTrade_Int_default_instance_;
class MarketDataUpdateTradingSessionDate;
class MarketDataUpdateTradingSessionDateDefaultTypeInternal;
extern MarketDataUpdateTradingSessionDateDefaultTypeInternal _MarketDataUpdateTradingSessionDate_default_instance_;
class MarketDepthFullUpdate10;
class MarketDepthFullUpdate10DefaultTypeInternal;
extern MarketDepthFullUpdate10DefaultTypeInternal _MarketDepthFullUpdate10_default_instance_;
class MarketDepthFullUpdate20;
class MarketDepthFullUpdate20DefaultTypeInternal;
extern MarketDepthFullUpdate20DefaultTypeInternal _MarketDepthFullUpdate20_default_instance_;
class MarketDepthReject;
class MarketDepthRejectDefaultTypeInternal;
extern MarketDepthRejectDefaultTypeInternal _MarketDepthReject_default_instance_;
class MarketDepthRequest;
class MarketDepthRequestDefaultTypeInternal;
extern MarketDepthRequestDefaultTypeInternal _MarketDepthRequest_default_instance_;
class MarketDepthSnapshotLevel;
class MarketDepthSnapshotLevelDefaultTypeInternal;
extern MarketDepthSnapshotLevelDefaultTypeInternal _MarketDepthSnapshotLevel_default_instance_;
class MarketDepthSnapshotLevel_Int;
class MarketDepthSnapshotLevel_IntDefaultTypeInternal;
extern MarketDepthSnapshotLevel_IntDefaultTypeInternal _MarketDepthSnapshotLevel_Int_default_instance_;
class MarketDepthUpdateLevel;
class MarketDepthUpdateLevelDefaultTypeInternal;
extern MarketDepthUpdateLevelDefaultTypeInternal _MarketDepthUpdateLevel_default_instance_;
class MarketDepthUpdateLevelCompact;
class MarketDepthUpdateLevelCompactDefaultTypeInternal;
extern MarketDepthUpdateLevelCompactDefaultTypeInternal _MarketDepthUpdateLevelCompact_default_instance_;
class MarketDepthUpdateLevelCompact2;
class MarketDepthUpdateLevelCompact2DefaultTypeInternal;
extern MarketDepthUpdateLevelCompact2DefaultTypeInternal _MarketDepthUpdateLevelCompact2_default_instance_;
class MarketDepthUpdateLevel_Int;
class MarketDepthUpdateLevel_IntDefaultTypeInternal;
extern MarketDepthUpdateLevel_IntDefaultTypeInternal _MarketDepthUpdateLevel_Int_default_instance_;
class OpenOrdersReject;
class OpenOrdersRejectDefaultTypeInternal;
extern OpenOrdersRejectDefaultTypeInternal _OpenOrdersReject_default_instance_;
class OpenOrdersRequest;
class OpenOrdersRequestDefaultTypeInternal;
extern OpenOrdersRequestDefaultTypeInternal _OpenOrdersRequest_default_instance_;
class OrderUpdate;
class OrderUpdateDefaultTypeInternal;
extern OrderUpdateDefaultTypeInternal _OrderUpdate_default_instance_;
class PositionUpdate;
class PositionUpdateDefaultTypeInternal;
extern PositionUpdateDefaultTypeInternal _PositionUpdate_default_instance_;
class SecurityDefinitionForSymbolRequest;
class SecurityDefinitionForSymbolRequestDefaultTypeInternal;
extern SecurityDefinitionForSymbolRequestDefaultTypeInternal _SecurityDefinitionForSymbolRequest_default_instance_;
class SecurityDefinitionReject;
class SecurityDefinitionRejectDefaultTypeInternal;
extern SecurityDefinitionRejectDefaultTypeInternal _SecurityDefinitionReject_default_instance_;
class SecurityDefinitionResponse;
class SecurityDefinitionResponseDefaultTypeInternal;
extern SecurityDefinitionResponseDefaultTypeInternal _SecurityDefinitionResponse_default_instance_;
class SubmitNewOCOOrder;
class SubmitNewOCOOrderDefaultTypeInternal;
extern SubmitNewOCOOrderDefaultTypeInternal _SubmitNewOCOOrder_default_instance_;
class SubmitNewOCOOrderInt;
class SubmitNewOCOOrderIntDefaultTypeInternal;
extern SubmitNewOCOOrderIntDefaultTypeInternal _SubmitNewOCOOrderInt_default_instance_;
class SubmitNewSingleOrder;
class SubmitNewSingleOrderDefaultTypeInternal;
extern SubmitNewSingleOrderDefaultTypeInternal _SubmitNewSingleOrder_default_instance_;
class SubmitNewSingleOrderInt;
class SubmitNewSingleOrderIntDefaultTypeInternal;
extern SubmitNewSingleOrderIntDefaultTypeInternal _SubmitNewSingleOrderInt_default_instance_;
class SymbolSearchRequest;
class SymbolSearchRequestDefaultTypeInternal;
extern SymbolSearchRequestDefaultTypeInternal _SymbolSearchRequest_default_instance_;
class SymbolsForExchangeRequest;
class SymbolsForExchangeRequestDefaultTypeInternal;
extern SymbolsForExchangeRequestDefaultTypeInternal _SymbolsForExchangeRequest_default_instance_;
class SymbolsForUnderlyingRequest;
class SymbolsForUnderlyingRequestDefaultTypeInternal;
extern SymbolsForUnderlyingRequestDefaultTypeInternal _SymbolsForUnderlyingRequest_default_instance_;
class TradeAccountResponse;
class TradeAccountResponseDefaultTypeInternal;
extern TradeAccountResponseDefaultTypeInternal _TradeAccountResponse_default_instance_;
class TradeAccountsRequest;
class TradeAccountsRequestDefaultTypeInternal;
extern TradeAccountsRequestDefaultTypeInternal _TradeAccountsRequest_default_instance_;
class TradingSymbolStatus;
class TradingSymbolStatusDefaultTypeInternal;
extern TradingSymbolStatusDefaultTypeInternal _TradingSymbolStatus_default_instance_;
class UnderlyingSymbolsForExchangeRequest;
class UnderlyingSymbolsForExchangeRequestDefaultTypeInternal;
extern UnderlyingSymbolsForExchangeRequestDefaultTypeInternal _UnderlyingSymbolsForExchangeRequest_default_instance_;
class UserMessage;
class UserMessageDefaultTypeInternal;
extern UserMessageDefaultTypeInternal _UserMessage_default_instance_;
}  // namespace DTC_PB
namespace google {
namespace protobuf {
template<> ::DTC_PB::AccountBalanceReject* Arena::CreateMaybeMessage<::DTC_PB::AccountBalanceReject>(Arena*);
template<> ::DTC_PB::AccountBalanceRequest* Arena::CreateMaybeMessage<::DTC_PB::AccountBalanceRequest>(Arena*);
template<> ::DTC_PB::AccountBalanceUpdate* Arena::CreateMaybeMessage<::DTC_PB::AccountBalanceUpdate>(Arena*);
template<> ::DTC_PB::AlertMessage* Arena::CreateMaybeMessage<::DTC_PB::AlertMessage>(Arena*);
template<> ::DTC_PB::CancelOrder* Arena::CreateMaybeMessage<::DTC_PB::CancelOrder>(Arena*);
template<> ::DTC_PB::CancelReplaceOrder* Arena::CreateMaybeMessage<::DTC_PB::CancelReplaceOrder>(Arena*);
template<> ::DTC_PB::CancelReplaceOrderInt* Arena::CreateMaybeMessage<::DTC_PB::CancelReplaceOrderInt>(Arena*);
template<> ::DTC_PB::CurrentPositionsReject* Arena::CreateMaybeMessage<::DTC_PB::CurrentPositionsReject>(Arena*);
template<> ::DTC_PB::CurrentPositionsRequest* Arena::CreateMaybeMessage<::DTC_PB::CurrentPositionsRequest>(Arena*);
template<> ::DTC_PB::DepthEntry* Arena::CreateMaybeMessage<::DTC_PB::DepthEntry>(Arena*);
template<> ::DTC_PB::EncodingRequest* Arena::CreateMaybeMessage<::DTC_PB::EncodingRequest>(Arena*);
template<> ::DTC_PB::EncodingResponse* Arena::CreateMaybeMessage<::DTC_PB::EncodingResponse>(Arena*);
template<> ::DTC_PB::ExchangeListRequest* Arena::CreateMaybeMessage<::DTC_PB::ExchangeListRequest>(Arena*);
template<> ::DTC_PB::ExchangeListResponse* Arena::CreateMaybeMessage<::DTC_PB::ExchangeListResponse>(Arena*);
template<> ::DTC_PB::GeneralLogMessage* Arena::CreateMaybeMessage<::DTC_PB::GeneralLogMessage>(Arena*);
template<> ::DTC_PB::Heartbeat* Arena::CreateMaybeMessage<::DTC_PB::Heartbeat>(Arena*);
template<> ::DTC_PB::HistoricalAccountBalanceResponse* Arena::CreateMaybeMessage<::DTC_PB::HistoricalAccountBalanceResponse>(Arena*);
template<> ::DTC_PB::HistoricalAccountBalancesReject* Arena::CreateMaybeMessage<::DTC_PB::HistoricalAccountBalancesReject>(Arena*);
template<> ::DTC_PB::HistoricalAccountBalancesRequest* Arena::CreateMaybeMessage<::DTC_PB::HistoricalAccountBalancesRequest>(Arena*);
template<> ::DTC_PB::HistoricalOrderFillResponse* Arena::CreateMaybeMessage<::DTC_PB::HistoricalOrderFillResponse>(Arena*);
template<> ::DTC_PB::HistoricalOrderFillsReject* Arena::CreateMaybeMessage<::DTC_PB::HistoricalOrderFillsReject>(Arena*);
template<> ::DTC_PB::HistoricalOrderFillsRequest* Arena::CreateMaybeMessage<::DTC_PB::HistoricalOrderFillsRequest>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataRecordResponse* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataRecordResponse>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataRecordResponse_Int* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataRecordResponse_Int>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataReject* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataReject>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataRequest* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataRequest>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataResponseHeader* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataResponseHeader>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataResponseTrailer* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataResponseTrailer>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataTickRecordResponse* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataTickRecordResponse>(Arena*);
template<> ::DTC_PB::HistoricalPriceDataTickRecordResponse_Int* Arena::CreateMaybeMessage<::DTC_PB::HistoricalPriceDataTickRecordResponse_Int>(Arena*);
template<> ::DTC_PB::JournalEntriesReject* Arena::CreateMaybeMessage<::DTC_PB::JournalEntriesReject>(Arena*);
template<> ::DTC_PB::JournalEntriesRequest* Arena::CreateMaybeMessage<::DTC_PB::JournalEntriesRequest>(Arena*);
template<> ::DTC_PB::JournalEntryAdd* Arena::CreateMaybeMessage<::DTC_PB::JournalEntryAdd>(Arena*);
template<> ::DTC_PB::JournalEntryResponse* Arena::CreateMaybeMessage<::DTC_PB::JournalEntryResponse>(Arena*);
template<> ::DTC_PB::Logoff* Arena::CreateMaybeMessage<::DTC_PB::Logoff>(Arena*);
template<> ::DTC_PB::LogonRequest* Arena::CreateMaybeMessage<::DTC_PB::LogonRequest>(Arena*);
template<> ::DTC_PB::LogonResponse* Arena::CreateMaybeMessage<::DTC_PB::LogonResponse>(Arena*);
template<> ::DTC_PB::MarketDataFeedStatus* Arena::CreateMaybeMessage<::DTC_PB::MarketDataFeedStatus>(Arena*);
template<> ::DTC_PB::MarketDataFeedSymbolStatus* Arena::CreateMaybeMessage<::DTC_PB::MarketDataFeedSymbolStatus>(Arena*);
template<> ::DTC_PB::MarketDataReject* Arena::CreateMaybeMessage<::DTC_PB::MarketDataReject>(Arena*);
template<> ::DTC_PB::MarketDataRequest* Arena::CreateMaybeMessage<::DTC_PB::MarketDataRequest>(Arena*);
template<> ::DTC_PB::MarketDataSnapshot* Arena::CreateMaybeMessage<::DTC_PB::MarketDataSnapshot>(Arena*);
template<> ::DTC_PB::MarketDataSnapshot_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDataSnapshot_Int>(Arena*);
template<> ::DTC_PB::MarketDataUpdateBidAsk* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateBidAsk>(Arena*);
template<> ::DTC_PB::MarketDataUpdateBidAskCompact* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateBidAskCompact>(Arena*);
template<> ::DTC_PB::MarketDataUpdateBidAsk_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateBidAsk_Int>(Arena*);
template<> ::DTC_PB::MarketDataUpdateLastTradeSnapshot* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateLastTradeSnapshot>(Arena*);
template<> ::DTC_PB::MarketDataUpdateOpenInterest* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateOpenInterest>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionHigh* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionHigh>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionHigh_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionHigh_Int>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionLow* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionLow>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionLow_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionLow_Int>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionNumTrades* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionNumTrades>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionOpen* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionOpen>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionOpen_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionOpen_Int>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionSettlement* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionSettlement>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionSettlement_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionSettlement_Int>(Arena*);
template<> ::DTC_PB::MarketDataUpdateSessionVolume* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateSessionVolume>(Arena*);
template<> ::DTC_PB::MarketDataUpdateTrade* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateTrade>(Arena*);
template<> ::DTC_PB::MarketDataUpdateTradeCompact* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateTradeCompact>(Arena*);
template<> ::DTC_PB::MarketDataUpdateTradeWithUnbundledIndicator* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateTradeWithUnbundledIndicator>(Arena*);
template<> ::DTC_PB::MarketDataUpdateTrade_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateTrade_Int>(Arena*);
template<> ::DTC_PB::MarketDataUpdateTradingSessionDate* Arena::CreateMaybeMessage<::DTC_PB::MarketDataUpdateTradingSessionDate>(Arena*);
template<> ::DTC_PB::MarketDepthFullUpdate10* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthFullUpdate10>(Arena*);
template<> ::DTC_PB::MarketDepthFullUpdate20* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthFullUpdate20>(Arena*);
template<> ::DTC_PB::MarketDepthReject* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthReject>(Arena*);
template<> ::DTC_PB::MarketDepthRequest* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthRequest>(Arena*);
template<> ::DTC_PB::MarketDepthSnapshotLevel* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthSnapshotLevel>(Arena*);
template<> ::DTC_PB::MarketDepthSnapshotLevel_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthSnapshotLevel_Int>(Arena*);
template<> ::DTC_PB::MarketDepthUpdateLevel* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthUpdateLevel>(Arena*);
template<> ::DTC_PB::MarketDepthUpdateLevelCompact* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthUpdateLevelCompact>(Arena*);
template<> ::DTC_PB::MarketDepthUpdateLevelCompact2* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthUpdateLevelCompact2>(Arena*);
template<> ::DTC_PB::MarketDepthUpdateLevel_Int* Arena::CreateMaybeMessage<::DTC_PB::MarketDepthUpdateLevel_Int>(Arena*);
template<> ::DTC_PB::OpenOrdersReject* Arena::CreateMaybeMessage<::DTC_PB::OpenOrdersReject>(Arena*);
template<> ::DTC_PB::OpenOrdersRequest* Arena::CreateMaybeMessage<::DTC_PB::OpenOrdersRequest>(Arena*);
template<> ::DTC_PB::OrderUpdate* Arena::CreateMaybeMessage<::DTC_PB::OrderUpdate>(Arena*);
template<> ::DTC_PB::PositionUpdate* Arena::CreateMaybeMessage<::DTC_PB::PositionUpdate>(Arena*);
template<> ::DTC_PB::SecurityDefinitionForSymbolRequest* Arena::CreateMaybeMessage<::DTC_PB::SecurityDefinitionForSymbolRequest>(Arena*);
template<> ::DTC_PB::SecurityDefinitionReject* Arena::CreateMaybeMessage<::DTC_PB::SecurityDefinitionReject>(Arena*);
template<> ::DTC_PB::SecurityDefinitionResponse* Arena::CreateMaybeMessage<::DTC_PB::SecurityDefinitionResponse>(Arena*);
template<> ::DTC_PB::SubmitNewOCOOrder* Arena::CreateMaybeMessage<::DTC_PB::SubmitNewOCOOrder>(Arena*);
template<> ::DTC_PB::SubmitNewOCOOrderInt* Arena::CreateMaybeMessage<::DTC_PB::SubmitNewOCOOrderInt>(Arena*);
template<> ::DTC_PB::SubmitNewSingleOrder* Arena::CreateMaybeMessage<::DTC_PB::SubmitNewSingleOrder>(Arena*);
template<> ::DTC_PB::SubmitNewSingleOrderInt* Arena::CreateMaybeMessage<::DTC_PB::SubmitNewSingleOrderInt>(Arena*);
template<> ::DTC_PB::SymbolSearchRequest* Arena::CreateMaybeMessage<::DTC_PB::SymbolSearchRequest>(Arena*);
template<> ::DTC_PB::SymbolsForExchangeRequest* Arena::CreateMaybeMessage<::DTC_PB::SymbolsForExchangeRequest>(Arena*);
template<> ::DTC_PB::SymbolsForUnderlyingRequest* Arena::CreateMaybeMessage<::DTC_PB::SymbolsForUnderlyingRequest>(Arena*);
template<> ::DTC_PB::TradeAccountResponse* Arena::CreateMaybeMessage<::DTC_PB::TradeAccountResponse>(Arena*);
template<> ::DTC_PB::TradeAccountsRequest* Arena::CreateMaybeMessage<::DTC_PB::TradeAccountsRequest>(Arena*);
template<> ::DTC_PB::TradingSymbolStatus* Arena::CreateMaybeMessage<::DTC_PB::TradingSymbolStatus>(Arena*);
template<> ::DTC_PB::UnderlyingSymbolsForExchangeRequest* Arena::CreateMaybeMessage<::DTC_PB::UnderlyingSymbolsForExchangeRequest>(Arena*);
template<> ::DTC_PB::UserMessage* Arena::CreateMaybeMessage<::DTC_PB::UserMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace DTC_PB {

enum DTCVersion {
  CURRENT_VERSION = 8
};
bool DTCVersion_IsValid(int value);
const DTCVersion DTCVersion_MIN = CURRENT_VERSION;
const DTCVersion DTCVersion_MAX = CURRENT_VERSION;
const int DTCVersion_ARRAYSIZE = DTCVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* DTCVersion_descriptor();
inline const ::std::string& DTCVersion_Name(DTCVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    DTCVersion_descriptor(), value);
}
inline bool DTCVersion_Parse(
    const ::std::string& name, DTCVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DTCVersion>(
    DTCVersion_descriptor(), name, value);
}
enum DTCMessageType {
  LOGON_REQUEST = 1,
  LOGON_RESPONSE = 2,
  HEARTBEAT = 3,
  LOGOFF = 5,
  ENCODING_REQUEST = 6,
  ENCODING_RESPONSE = 7,
  MARKET_DATA_REQUEST = 101,
  MARKET_DATA_REJECT = 103,
  MARKET_DATA_SNAPSHOT = 104,
  MARKET_DATA_SNAPSHOT_INT = 125,
  MARKET_DATA_UPDATE_TRADE = 107,
  MARKET_DATA_UPDATE_TRADE_COMPACT = 112,
  MARKET_DATA_UPDATE_TRADE_INT = 126,
  MARKET_DATA_UPDATE_LAST_TRADE_SNAPSHOT = 134,
  MARKET_DATA_UPDATE_BID_ASK = 108,
  MARKET_DATA_UPDATE_BID_ASK_COMPACT = 117,
  MARKET_DATA_UPDATE_BID_ASK_INT = 127,
  MARKET_DATA_UPDATE_SESSION_OPEN = 120,
  MARKET_DATA_UPDATE_SESSION_OPEN_INT = 128,
  MARKET_DATA_UPDATE_SESSION_HIGH = 114,
  MARKET_DATA_UPDATE_SESSION_HIGH_INT = 129,
  MARKET_DATA_UPDATE_SESSION_LOW = 115,
  MARKET_DATA_UPDATE_SESSION_LOW_INT = 130,
  MARKET_DATA_UPDATE_SESSION_VOLUME = 113,
  MARKET_DATA_UPDATE_OPEN_INTEREST = 124,
  MARKET_DATA_UPDATE_SESSION_SETTLEMENT = 119,
  MARKET_DATA_UPDATE_SESSION_SETTLEMENT_INT = 131,
  MARKET_DATA_UPDATE_SESSION_NUM_TRADES = 135,
  MARKET_DATA_UPDATE_TRADING_SESSION_DATE = 136,
  MARKET_DEPTH_REQUEST = 102,
  MARKET_DEPTH_REJECT = 121,
  MARKET_DEPTH_SNAPSHOT_LEVEL = 122,
  MARKET_DEPTH_SNAPSHOT_LEVEL_INT = 132,
  MARKET_DEPTH_UPDATE_LEVEL = 106,
  MARKET_DEPTH_UPDATE_LEVEL_COMPACT = 118,
  MARKET_DEPTH_UPDATE_LEVEL_COMPACT_2 = 139,
  MARKET_DEPTH_UPDATE_LEVEL_INT = 133,
  MARKET_DEPTH_FULL_UPDATE_10 = 123,
  MARKET_DEPTH_FULL_UPDATE_20 = 105,
  MARKET_DATA_FEED_STATUS = 100,
  MARKET_DATA_FEED_SYMBOL_STATUS = 116,
  TRADING_SYMBOL_STATUS = 138,
  SUBMIT_NEW_SINGLE_ORDER = 208,
  SUBMIT_NEW_SINGLE_ORDER_INT = 206,
  SUBMIT_NEW_OCO_ORDER = 201,
  SUBMIT_NEW_OCO_ORDER_INT = 207,
  CANCEL_ORDER = 203,
  CANCEL_REPLACE_ORDER = 204,
  CANCEL_REPLACE_ORDER_INT = 205,
  OPEN_ORDERS_REQUEST = 300,
  OPEN_ORDERS_REJECT = 302,
  ORDER_UPDATE = 301,
  HISTORICAL_ORDER_FILLS_REQUEST = 303,
  HISTORICAL_ORDER_FILL_RESPONSE = 304,
  HISTORICAL_ORDER_FILLS_REJECT = 308,
  CURRENT_POSITIONS_REQUEST = 305,
  CURRENT_POSITIONS_REJECT = 307,
  POSITION_UPDATE = 306,
  TRADE_ACCOUNTS_REQUEST = 400,
  TRADE_ACCOUNT_RESPONSE = 401,
  EXCHANGE_LIST_REQUEST = 500,
  EXCHANGE_LIST_RESPONSE = 501,
  SYMBOLS_FOR_EXCHANGE_REQUEST = 502,
  UNDERLYING_SYMBOLS_FOR_EXCHANGE_REQUEST = 503,
  SYMBOLS_FOR_UNDERLYING_REQUEST = 504,
  SECURITY_DEFINITION_FOR_SYMBOL_REQUEST = 506,
  SECURITY_DEFINITION_RESPONSE = 507,
  SYMBOL_SEARCH_REQUEST = 508,
  SECURITY_DEFINITION_REJECT = 509,
  ACCOUNT_BALANCE_REQUEST = 601,
  ACCOUNT_BALANCE_REJECT = 602,
  ACCOUNT_BALANCE_UPDATE = 600,
  HISTORICAL_ACCOUNT_BALANCES_REQUEST = 603,
  HISTORICAL_ACCOUNT_BALANCES_REJECT = 604,
  HISTORICAL_ACCOUNT_BALANCE_RESPONSE = 605,
  USER_MESSAGE = 700,
  GENERAL_LOG_MESSAGE = 701,
  ALERT_MESSAGE = 702,
  JOURNAL_ENTRY_ADD = 703,
  JOURNAL_ENTRIES_REQUEST = 704,
  JOURNAL_ENTRIES_REJECT = 705,
  JOURNAL_ENTRY_RESPONSE = 706,
  HISTORICAL_PRICE_DATA_REQUEST = 800,
  HISTORICAL_PRICE_DATA_RESPONSE_HEADER = 801,
  HISTORICAL_PRICE_DATA_REJECT = 802,
  HISTORICAL_PRICE_DATA_RECORD_RESPONSE = 803,
  HISTORICAL_PRICE_DATA_TICK_RECORD_RESPONSE = 804,
  HISTORICAL_PRICE_DATA_RECORD_RESPONSE_INT = 805,
  HISTORICAL_PRICE_DATA_TICK_RECORD_RESPONSE_INT = 806
};
bool DTCMessageType_IsValid(int value);
const DTCMessageType DTCMessageType_MIN = LOGON_REQUEST;
const DTCMessageType DTCMessageType_MAX = HISTORICAL_PRICE_DATA_TICK_RECORD_RESPONSE_INT;
const int DTCMessageType_ARRAYSIZE = DTCMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DTCMessageType_descriptor();
inline const ::std::string& DTCMessageType_Name(DTCMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DTCMessageType_descriptor(), value);
}
inline bool DTCMessageType_Parse(
    const ::std::string& name, DTCMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DTCMessageType>(
    DTCMessageType_descriptor(), name, value);
}
enum EncodingEnum {
  BINARY_ENCODING = 0,
  BINARY_WITH_VARIABLE_LENGTH_STRINGS = 1,
  JSON_ENCODING = 2,
  JSON_COMPACT_ENCODING = 3,
  PROTOCOL_BUFFERS = 4
};
bool EncodingEnum_IsValid(int value);
const EncodingEnum EncodingEnum_MIN = BINARY_ENCODING;
const EncodingEnum EncodingEnum_MAX = PROTOCOL_BUFFERS;
const int EncodingEnum_ARRAYSIZE = EncodingEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncodingEnum_descriptor();
inline const ::std::string& EncodingEnum_Name(EncodingEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncodingEnum_descriptor(), value);
}
inline bool EncodingEnum_Parse(
    const ::std::string& name, EncodingEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncodingEnum>(
    EncodingEnum_descriptor(), name, value);
}
enum LogonStatusEnum {
  LOGON_SUCCESS = 1,
  LOGON_ERROR = 2,
  LOGON_ERROR_NO_RECONNECT = 3,
  LOGON_RECONNECT_NEW_ADDRESS = 4
};
bool LogonStatusEnum_IsValid(int value);
const LogonStatusEnum LogonStatusEnum_MIN = LOGON_SUCCESS;
const LogonStatusEnum LogonStatusEnum_MAX = LOGON_RECONNECT_NEW_ADDRESS;
const int LogonStatusEnum_ARRAYSIZE = LogonStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogonStatusEnum_descriptor();
inline const ::std::string& LogonStatusEnum_Name(LogonStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogonStatusEnum_descriptor(), value);
}
inline bool LogonStatusEnum_Parse(
    const ::std::string& name, LogonStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogonStatusEnum>(
    LogonStatusEnum_descriptor(), name, value);
}
enum MessageSupportedEnum {
  MESSAGE_UNSUPPORTED = 0,
  MESSAGE_SUPPORTED = 1
};
bool MessageSupportedEnum_IsValid(int value);
const MessageSupportedEnum MessageSupportedEnum_MIN = MESSAGE_UNSUPPORTED;
const MessageSupportedEnum MessageSupportedEnum_MAX = MESSAGE_SUPPORTED;
const int MessageSupportedEnum_ARRAYSIZE = MessageSupportedEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageSupportedEnum_descriptor();
inline const ::std::string& MessageSupportedEnum_Name(MessageSupportedEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageSupportedEnum_descriptor(), value);
}
inline bool MessageSupportedEnum_Parse(
    const ::std::string& name, MessageSupportedEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageSupportedEnum>(
    MessageSupportedEnum_descriptor(), name, value);
}
enum TradeModeEnum {
  TRADE_MODE_UNSET = 0,
  TRADE_MODE_DEMO = 1,
  TRADE_MODE_SIMULATED = 2,
  TRADE_MODE_LIVE = 3
};
bool TradeModeEnum_IsValid(int value);
const TradeModeEnum TradeModeEnum_MIN = TRADE_MODE_UNSET;
const TradeModeEnum TradeModeEnum_MAX = TRADE_MODE_LIVE;
const int TradeModeEnum_ARRAYSIZE = TradeModeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradeModeEnum_descriptor();
inline const ::std::string& TradeModeEnum_Name(TradeModeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradeModeEnum_descriptor(), value);
}
inline bool TradeModeEnum_Parse(
    const ::std::string& name, TradeModeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradeModeEnum>(
    TradeModeEnum_descriptor(), name, value);
}
enum RequestActionEnum {
  SUBSCRIBE = 1,
  UNSUBSCRIBE = 2,
  SNAPSHOT = 3
};
bool RequestActionEnum_IsValid(int value);
const RequestActionEnum RequestActionEnum_MIN = SUBSCRIBE;
const RequestActionEnum RequestActionEnum_MAX = SNAPSHOT;
const int RequestActionEnum_ARRAYSIZE = RequestActionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestActionEnum_descriptor();
inline const ::std::string& RequestActionEnum_Name(RequestActionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestActionEnum_descriptor(), value);
}
inline bool RequestActionEnum_Parse(
    const ::std::string& name, RequestActionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestActionEnum>(
    RequestActionEnum_descriptor(), name, value);
}
enum UnbundledTradeIndicatorEnum {
  UNBUNDLED_TRADE_NONE = 0,
  FIRST_SUB_TRADE_OF_UNBUNDLED_TRADE = 1,
  LAST_SUB_TRADE_OF_UNBUNDLED_TRADE = 2
};
bool UnbundledTradeIndicatorEnum_IsValid(int value);
const UnbundledTradeIndicatorEnum UnbundledTradeIndicatorEnum_MIN = UNBUNDLED_TRADE_NONE;
const UnbundledTradeIndicatorEnum UnbundledTradeIndicatorEnum_MAX = LAST_SUB_TRADE_OF_UNBUNDLED_TRADE;
const int UnbundledTradeIndicatorEnum_ARRAYSIZE = UnbundledTradeIndicatorEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnbundledTradeIndicatorEnum_descriptor();
inline const ::std::string& UnbundledTradeIndicatorEnum_Name(UnbundledTradeIndicatorEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnbundledTradeIndicatorEnum_descriptor(), value);
}
inline bool UnbundledTradeIndicatorEnum_Parse(
    const ::std::string& name, UnbundledTradeIndicatorEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnbundledTradeIndicatorEnum>(
    UnbundledTradeIndicatorEnum_descriptor(), name, value);
}
enum OrderStatusEnum {
  ORDER_STATUS_UNSPECIFIED = 0,
  ORDER_STATUS_ORDER_SENT = 1,
  ORDER_STATUS_PENDING_OPEN = 2,
  ORDER_STATUS_PENDING_CHILD = 3,
  ORDER_STATUS_OPEN = 4,
  ORDER_STATUS_PENDING_CANCEL_REPLACE = 5,
  ORDER_STATUS_PENDING_CANCEL = 6,
  ORDER_STATUS_FILLED = 7,
  ORDER_STATUS_CANCELED = 8,
  ORDER_STATUS_REJECTED = 9,
  ORDER_STATUS_PARTIALLY_FILLED = 10
};
bool OrderStatusEnum_IsValid(int value);
const OrderStatusEnum OrderStatusEnum_MIN = ORDER_STATUS_UNSPECIFIED;
const OrderStatusEnum OrderStatusEnum_MAX = ORDER_STATUS_PARTIALLY_FILLED;
const int OrderStatusEnum_ARRAYSIZE = OrderStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderStatusEnum_descriptor();
inline const ::std::string& OrderStatusEnum_Name(OrderStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderStatusEnum_descriptor(), value);
}
inline bool OrderStatusEnum_Parse(
    const ::std::string& name, OrderStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderStatusEnum>(
    OrderStatusEnum_descriptor(), name, value);
}
enum OrderUpdateReasonEnum {
  ORDER_UPDATE_REASON_UNSET = 0,
  OPEN_ORDERS_REQUEST_RESPONSE = 1,
  NEW_ORDER_ACCEPTED = 2,
  GENERAL_ORDER_UPDATE = 3,
  ORDER_FILLED = 4,
  ORDER_FILLED_PARTIALLY = 5,
  ORDER_CANCELED = 6,
  ORDER_CANCEL_REPLACE_COMPLETE = 7,
  NEW_ORDER_REJECTED = 8,
  ORDER_CANCEL_REJECTED = 9,
  ORDER_CANCEL_REPLACE_REJECTED = 10
};
bool OrderUpdateReasonEnum_IsValid(int value);
const OrderUpdateReasonEnum OrderUpdateReasonEnum_MIN = ORDER_UPDATE_REASON_UNSET;
const OrderUpdateReasonEnum OrderUpdateReasonEnum_MAX = ORDER_CANCEL_REPLACE_REJECTED;
const int OrderUpdateReasonEnum_ARRAYSIZE = OrderUpdateReasonEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderUpdateReasonEnum_descriptor();
inline const ::std::string& OrderUpdateReasonEnum_Name(OrderUpdateReasonEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderUpdateReasonEnum_descriptor(), value);
}
inline bool OrderUpdateReasonEnum_Parse(
    const ::std::string& name, OrderUpdateReasonEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderUpdateReasonEnum>(
    OrderUpdateReasonEnum_descriptor(), name, value);
}
enum AtBidOrAskEnum {
  BID_ASK_UNSET = 0,
  AT_BID = 1,
  AT_ASK = 2
};
bool AtBidOrAskEnum_IsValid(int value);
const AtBidOrAskEnum AtBidOrAskEnum_MIN = BID_ASK_UNSET;
const AtBidOrAskEnum AtBidOrAskEnum_MAX = AT_ASK;
const int AtBidOrAskEnum_ARRAYSIZE = AtBidOrAskEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* AtBidOrAskEnum_descriptor();
inline const ::std::string& AtBidOrAskEnum_Name(AtBidOrAskEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    AtBidOrAskEnum_descriptor(), value);
}
inline bool AtBidOrAskEnum_Parse(
    const ::std::string& name, AtBidOrAskEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AtBidOrAskEnum>(
    AtBidOrAskEnum_descriptor(), name, value);
}
enum AtBidOrAskEnum8 {
  BID_ASK_UNSET_8 = 0,
  AT_BID_8 = 1,
  AT_ASK_8 = 2
};
bool AtBidOrAskEnum8_IsValid(int value);
const AtBidOrAskEnum8 AtBidOrAskEnum8_MIN = BID_ASK_UNSET_8;
const AtBidOrAskEnum8 AtBidOrAskEnum8_MAX = AT_ASK_8;
const int AtBidOrAskEnum8_ARRAYSIZE = AtBidOrAskEnum8_MAX + 1;

const ::google::protobuf::EnumDescriptor* AtBidOrAskEnum8_descriptor();
inline const ::std::string& AtBidOrAskEnum8_Name(AtBidOrAskEnum8 value) {
  return ::google::protobuf::internal::NameOfEnum(
    AtBidOrAskEnum8_descriptor(), value);
}
inline bool AtBidOrAskEnum8_Parse(
    const ::std::string& name, AtBidOrAskEnum8* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AtBidOrAskEnum8>(
    AtBidOrAskEnum8_descriptor(), name, value);
}
enum MarketDepthUpdateTypeEnum {
  DEPTH_UNSET = 0,
  MARKET_DEPTH_INSERT_UPDATE_LEVEL = 1,
  MARKET_DEPTH_DELETE_LEVEL = 2
};
bool MarketDepthUpdateTypeEnum_IsValid(int value);
const MarketDepthUpdateTypeEnum MarketDepthUpdateTypeEnum_MIN = DEPTH_UNSET;
const MarketDepthUpdateTypeEnum MarketDepthUpdateTypeEnum_MAX = MARKET_DEPTH_DELETE_LEVEL;
const int MarketDepthUpdateTypeEnum_ARRAYSIZE = MarketDepthUpdateTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketDepthUpdateTypeEnum_descriptor();
inline const ::std::string& MarketDepthUpdateTypeEnum_Name(MarketDepthUpdateTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketDepthUpdateTypeEnum_descriptor(), value);
}
inline bool MarketDepthUpdateTypeEnum_Parse(
    const ::std::string& name, MarketDepthUpdateTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketDepthUpdateTypeEnum>(
    MarketDepthUpdateTypeEnum_descriptor(), name, value);
}
enum OrderTypeEnum {
  ORDER_TYPE_UNSET = 0,
  ORDER_TYPE_MARKET = 1,
  ORDER_TYPE_LIMIT = 2,
  ORDER_TYPE_STOP = 3,
  ORDER_TYPE_STOP_LIMIT = 4,
  ORDER_TYPE_MARKET_IF_TOUCHED = 5,
  ORDER_TYPE_LIMIT_IF_TOUCHED = 6
};
bool OrderTypeEnum_IsValid(int value);
const OrderTypeEnum OrderTypeEnum_MIN = ORDER_TYPE_UNSET;
const OrderTypeEnum OrderTypeEnum_MAX = ORDER_TYPE_LIMIT_IF_TOUCHED;
const int OrderTypeEnum_ARRAYSIZE = OrderTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderTypeEnum_descriptor();
inline const ::std::string& OrderTypeEnum_Name(OrderTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderTypeEnum_descriptor(), value);
}
inline bool OrderTypeEnum_Parse(
    const ::std::string& name, OrderTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderTypeEnum>(
    OrderTypeEnum_descriptor(), name, value);
}
enum TimeInForceEnum {
  TIF_UNSET = 0,
  TIF_DAY = 1,
  TIF_GOOD_TILL_CANCELED = 2,
  TIF_GOOD_TILL_DATE_TIME = 3,
  TIF_IMMEDIATE_OR_CANCEL = 4,
  TIF_ALL_OR_NONE = 5,
  TIF_FILL_OR_KILL = 6
};
bool TimeInForceEnum_IsValid(int value);
const TimeInForceEnum TimeInForceEnum_MIN = TIF_UNSET;
const TimeInForceEnum TimeInForceEnum_MAX = TIF_FILL_OR_KILL;
const int TimeInForceEnum_ARRAYSIZE = TimeInForceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeInForceEnum_descriptor();
inline const ::std::string& TimeInForceEnum_Name(TimeInForceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeInForceEnum_descriptor(), value);
}
inline bool TimeInForceEnum_Parse(
    const ::std::string& name, TimeInForceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeInForceEnum>(
    TimeInForceEnum_descriptor(), name, value);
}
enum BuySellEnum {
  BUY_SELL_UNSET = 0,
  BUY = 1,
  SELL = 2
};
bool BuySellEnum_IsValid(int value);
const BuySellEnum BuySellEnum_MIN = BUY_SELL_UNSET;
const BuySellEnum BuySellEnum_MAX = SELL;
const int BuySellEnum_ARRAYSIZE = BuySellEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuySellEnum_descriptor();
inline const ::std::string& BuySellEnum_Name(BuySellEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuySellEnum_descriptor(), value);
}
inline bool BuySellEnum_Parse(
    const ::std::string& name, BuySellEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuySellEnum>(
    BuySellEnum_descriptor(), name, value);
}
enum OpenCloseTradeEnum {
  TRADE_UNSET = 0,
  TRADE_OPEN = 1,
  TRADE_CLOSE = 2
};
bool OpenCloseTradeEnum_IsValid(int value);
const OpenCloseTradeEnum OpenCloseTradeEnum_MIN = TRADE_UNSET;
const OpenCloseTradeEnum OpenCloseTradeEnum_MAX = TRADE_CLOSE;
const int OpenCloseTradeEnum_ARRAYSIZE = OpenCloseTradeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OpenCloseTradeEnum_descriptor();
inline const ::std::string& OpenCloseTradeEnum_Name(OpenCloseTradeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OpenCloseTradeEnum_descriptor(), value);
}
inline bool OpenCloseTradeEnum_Parse(
    const ::std::string& name, OpenCloseTradeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpenCloseTradeEnum>(
    OpenCloseTradeEnum_descriptor(), name, value);
}
enum PartialFillHandlingEnum {
  PARTIAL_FILL_UNSET = 0,
  PARTIAL_FILL_HANDLING_REDUCE_QUANTITY = 1,
  PARTIAL_FILL_HANDLING_IMMEDIATE_CANCEL = 2
};
bool PartialFillHandlingEnum_IsValid(int value);
const PartialFillHandlingEnum PartialFillHandlingEnum_MIN = PARTIAL_FILL_UNSET;
const PartialFillHandlingEnum PartialFillHandlingEnum_MAX = PARTIAL_FILL_HANDLING_IMMEDIATE_CANCEL;
const int PartialFillHandlingEnum_ARRAYSIZE = PartialFillHandlingEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartialFillHandlingEnum_descriptor();
inline const ::std::string& PartialFillHandlingEnum_Name(PartialFillHandlingEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartialFillHandlingEnum_descriptor(), value);
}
inline bool PartialFillHandlingEnum_Parse(
    const ::std::string& name, PartialFillHandlingEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartialFillHandlingEnum>(
    PartialFillHandlingEnum_descriptor(), name, value);
}
enum MarketDataFeedStatusEnum {
  MARKET_DATA_FEED_UNAVAILABLE = 1,
  MARKET_DATA_FEED_AVAILABLE = 2
};
bool MarketDataFeedStatusEnum_IsValid(int value);
const MarketDataFeedStatusEnum MarketDataFeedStatusEnum_MIN = MARKET_DATA_FEED_UNAVAILABLE;
const MarketDataFeedStatusEnum MarketDataFeedStatusEnum_MAX = MARKET_DATA_FEED_AVAILABLE;
const int MarketDataFeedStatusEnum_ARRAYSIZE = MarketDataFeedStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketDataFeedStatusEnum_descriptor();
inline const ::std::string& MarketDataFeedStatusEnum_Name(MarketDataFeedStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketDataFeedStatusEnum_descriptor(), value);
}
inline bool MarketDataFeedStatusEnum_Parse(
    const ::std::string& name, MarketDataFeedStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketDataFeedStatusEnum>(
    MarketDataFeedStatusEnum_descriptor(), name, value);
}
enum PriceDisplayFormatEnum {
  PRICE_DISPLAY_FORMAT_UNSET = -1,
  PRICE_DISPLAY_FORMAT_DECIMAL_0 = 0,
  PRICE_DISPLAY_FORMAT_DECIMAL_1 = 1,
  PRICE_DISPLAY_FORMAT_DECIMAL_2 = 2,
  PRICE_DISPLAY_FORMAT_DECIMAL_3 = 3,
  PRICE_DISPLAY_FORMAT_DECIMAL_4 = 4,
  PRICE_DISPLAY_FORMAT_DECIMAL_5 = 5,
  PRICE_DISPLAY_FORMAT_DECIMAL_6 = 6,
  PRICE_DISPLAY_FORMAT_DECIMAL_7 = 7,
  PRICE_DISPLAY_FORMAT_DECIMAL_8 = 8,
  PRICE_DISPLAY_FORMAT_DECIMAL_9 = 9,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_256 = 356,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_128 = 228,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_64 = 164,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_32_QUARTERS = 136,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_32_HALVES = 134,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_32 = 132,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_16 = 116,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_8 = 108,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_4 = 104,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_2 = 102
};
bool PriceDisplayFormatEnum_IsValid(int value);
const PriceDisplayFormatEnum PriceDisplayFormatEnum_MIN = PRICE_DISPLAY_FORMAT_UNSET;
const PriceDisplayFormatEnum PriceDisplayFormatEnum_MAX = PRICE_DISPLAY_FORMAT_DENOMINATOR_256;
const int PriceDisplayFormatEnum_ARRAYSIZE = PriceDisplayFormatEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriceDisplayFormatEnum_descriptor();
inline const ::std::string& PriceDisplayFormatEnum_Name(PriceDisplayFormatEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriceDisplayFormatEnum_descriptor(), value);
}
inline bool PriceDisplayFormatEnum_Parse(
    const ::std::string& name, PriceDisplayFormatEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriceDisplayFormatEnum>(
    PriceDisplayFormatEnum_descriptor(), name, value);
}
enum SecurityTypeEnum {
  SECURITY_TYPE_UNSET = 0,
  SECURITY_TYPE_FUTURE = 1,
  SECURITY_TYPE_STOCK = 2,
  SECURITY_TYPE_FOREX = 3,
  SECURITY_TYPE_INDEX = 4,
  SECURITY_TYPE_FUTURES_STRATEGY = 5,
  SECURITY_TYPE_FUTURES_OPTION = 7,
  SECURITY_TYPE_STOCK_OPTION = 6,
  SECURITY_TYPE_INDEX_OPTION = 8,
  SECURITY_TYPE_BOND = 9,
  SECURITY_TYPE_MUTUAL_FUND = 10
};
bool SecurityTypeEnum_IsValid(int value);
const SecurityTypeEnum SecurityTypeEnum_MIN = SECURITY_TYPE_UNSET;
const SecurityTypeEnum SecurityTypeEnum_MAX = SECURITY_TYPE_MUTUAL_FUND;
const int SecurityTypeEnum_ARRAYSIZE = SecurityTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityTypeEnum_descriptor();
inline const ::std::string& SecurityTypeEnum_Name(SecurityTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityTypeEnum_descriptor(), value);
}
inline bool SecurityTypeEnum_Parse(
    const ::std::string& name, SecurityTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityTypeEnum>(
    SecurityTypeEnum_descriptor(), name, value);
}
enum PutCallEnum {
  PC_UNSET = 0,
  PC_CALL = 1,
  PC_PUT = 2
};
bool PutCallEnum_IsValid(int value);
const PutCallEnum PutCallEnum_MIN = PC_UNSET;
const PutCallEnum PutCallEnum_MAX = PC_PUT;
const int PutCallEnum_ARRAYSIZE = PutCallEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PutCallEnum_descriptor();
inline const ::std::string& PutCallEnum_Name(PutCallEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PutCallEnum_descriptor(), value);
}
inline bool PutCallEnum_Parse(
    const ::std::string& name, PutCallEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PutCallEnum>(
    PutCallEnum_descriptor(), name, value);
}
enum SearchTypeEnum {
  SEARCH_TYPE_UNSET = 0,
  SEARCH_TYPE_BY_SYMBOL = 1,
  SEARCH_TYPE_BY_DESCRIPTION = 2
};
bool SearchTypeEnum_IsValid(int value);
const SearchTypeEnum SearchTypeEnum_MIN = SEARCH_TYPE_UNSET;
const SearchTypeEnum SearchTypeEnum_MAX = SEARCH_TYPE_BY_DESCRIPTION;
const int SearchTypeEnum_ARRAYSIZE = SearchTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchTypeEnum_descriptor();
inline const ::std::string& SearchTypeEnum_Name(SearchTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchTypeEnum_descriptor(), value);
}
inline bool SearchTypeEnum_Parse(
    const ::std::string& name, SearchTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchTypeEnum>(
    SearchTypeEnum_descriptor(), name, value);
}
enum HistoricalDataIntervalEnum {
  INTERVAL_TICK = 0,
  INTERVAL_1_SECOND = 1,
  INTERVAL_2_SECONDS = 2,
  INTERVAL_4_SECONDS = 4,
  INTERVAL_5_SECONDS = 5,
  INTERVAL_10_SECONDS = 10,
  INTERVAL_30_SECONDS = 30,
  INTERVAL_1_MINUTE = 60,
  INTERVAL_1_DAY = 86400,
  INTERVAL_1_WEEK = 604800
};
bool HistoricalDataIntervalEnum_IsValid(int value);
const HistoricalDataIntervalEnum HistoricalDataIntervalEnum_MIN = INTERVAL_TICK;
const HistoricalDataIntervalEnum HistoricalDataIntervalEnum_MAX = INTERVAL_1_WEEK;
const int HistoricalDataIntervalEnum_ARRAYSIZE = HistoricalDataIntervalEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* HistoricalDataIntervalEnum_descriptor();
inline const ::std::string& HistoricalDataIntervalEnum_Name(HistoricalDataIntervalEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    HistoricalDataIntervalEnum_descriptor(), value);
}
inline bool HistoricalDataIntervalEnum_Parse(
    const ::std::string& name, HistoricalDataIntervalEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HistoricalDataIntervalEnum>(
    HistoricalDataIntervalEnum_descriptor(), name, value);
}
enum HistoricalPriceDataRejectReasonCodeEnum {
  HPDR_UNSET = 0,
  HPDR_UNABLE_TO_SERVE_DATA_RETRY_LATER = 1,
  HPDR_UNABLE_TO_SERVE_DATA_DO_NOT_RETRY = 2,
  HPDR_DATA_REQUEST_OUTSIDE_BOUNDS_OF_AVAILABLE_DATA = 3,
  HPDR_GENERAL_REJECT_ERROR = 4
};
bool HistoricalPriceDataRejectReasonCodeEnum_IsValid(int value);
const HistoricalPriceDataRejectReasonCodeEnum HistoricalPriceDataRejectReasonCodeEnum_MIN = HPDR_UNSET;
const HistoricalPriceDataRejectReasonCodeEnum HistoricalPriceDataRejectReasonCodeEnum_MAX = HPDR_GENERAL_REJECT_ERROR;
const int HistoricalPriceDataRejectReasonCodeEnum_ARRAYSIZE = HistoricalPriceDataRejectReasonCodeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* HistoricalPriceDataRejectReasonCodeEnum_descriptor();
inline const ::std::string& HistoricalPriceDataRejectReasonCodeEnum_Name(HistoricalPriceDataRejectReasonCodeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    HistoricalPriceDataRejectReasonCodeEnum_descriptor(), value);
}
inline bool HistoricalPriceDataRejectReasonCodeEnum_Parse(
    const ::std::string& name, HistoricalPriceDataRejectReasonCodeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HistoricalPriceDataRejectReasonCodeEnum>(
    HistoricalPriceDataRejectReasonCodeEnum_descriptor(), name, value);
}
enum TradingStatusEnum {
  TRADING_STATUS_UNKNOWN = 0,
  TRADING_STATUS_PRE_OPEN = 1,
  TRADING_STATUS_OPEN = 2,
  TRADING_STATUS_CLOSE = 3,
  TRADING_STATUS_TRADING_HALT = 4
};
bool TradingStatusEnum_IsValid(int value);
const TradingStatusEnum TradingStatusEnum_MIN = TRADING_STATUS_UNKNOWN;
const TradingStatusEnum TradingStatusEnum_MAX = TRADING_STATUS_TRADING_HALT;
const int TradingStatusEnum_ARRAYSIZE = TradingStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingStatusEnum_descriptor();
inline const ::std::string& TradingStatusEnum_Name(TradingStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingStatusEnum_descriptor(), value);
}
inline bool TradingStatusEnum_Parse(
    const ::std::string& name, TradingStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingStatusEnum>(
    TradingStatusEnum_descriptor(), name, value);
}
// ===================================================================

class EncodingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.EncodingRequest) */ {
 public:
  EncodingRequest();
  virtual ~EncodingRequest();

  EncodingRequest(const EncodingRequest& from);

  inline EncodingRequest& operator=(const EncodingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EncodingRequest(EncodingRequest&& from) noexcept
    : EncodingRequest() {
    *this = ::std::move(from);
  }

  inline EncodingRequest& operator=(EncodingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncodingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EncodingRequest* internal_default_instance() {
    return reinterpret_cast<const EncodingRequest*>(
               &_EncodingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EncodingRequest* other);
  friend void swap(EncodingRequest& a, EncodingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EncodingRequest* New() const final {
    return CreateMaybeMessage<EncodingRequest>(NULL);
  }

  EncodingRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EncodingRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EncodingRequest& from);
  void MergeFrom(const EncodingRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncodingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProtocolType = 3;
  bool has_protocoltype() const;
  void clear_protocoltype();
  static const int kProtocolTypeFieldNumber = 3;
  const ::std::string& protocoltype() const;
  void set_protocoltype(const ::std::string& value);
  #if LANG_CXX11
  void set_protocoltype(::std::string&& value);
  #endif
  void set_protocoltype(const char* value);
  void set_protocoltype(const char* value, size_t size);
  ::std::string* mutable_protocoltype();
  ::std::string* release_protocoltype();
  void set_allocated_protocoltype(::std::string* protocoltype);

  // optional int32 ProtocolVersion = 1;
  bool has_protocolversion() const;
  void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  ::google::protobuf::int32 protocolversion() const;
  void set_protocolversion(::google::protobuf::int32 value);

  // optional .DTC_PB.EncodingEnum Encoding = 2;
  bool has_encoding() const;
  void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  ::DTC_PB::EncodingEnum encoding() const;
  void set_encoding(::DTC_PB::EncodingEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.EncodingRequest)
 private:
  void set_has_protocolversion();
  void clear_has_protocolversion();
  void set_has_encoding();
  void clear_has_encoding();
  void set_has_protocoltype();
  void clear_has_protocoltype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocoltype_;
  ::google::protobuf::int32 protocolversion_;
  int encoding_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EncodingResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.EncodingResponse) */ {
 public:
  EncodingResponse();
  virtual ~EncodingResponse();

  EncodingResponse(const EncodingResponse& from);

  inline EncodingResponse& operator=(const EncodingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EncodingResponse(EncodingResponse&& from) noexcept
    : EncodingResponse() {
    *this = ::std::move(from);
  }

  inline EncodingResponse& operator=(EncodingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncodingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EncodingResponse* internal_default_instance() {
    return reinterpret_cast<const EncodingResponse*>(
               &_EncodingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EncodingResponse* other);
  friend void swap(EncodingResponse& a, EncodingResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EncodingResponse* New() const final {
    return CreateMaybeMessage<EncodingResponse>(NULL);
  }

  EncodingResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EncodingResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EncodingResponse& from);
  void MergeFrom(const EncodingResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncodingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProtocolType = 3;
  bool has_protocoltype() const;
  void clear_protocoltype();
  static const int kProtocolTypeFieldNumber = 3;
  const ::std::string& protocoltype() const;
  void set_protocoltype(const ::std::string& value);
  #if LANG_CXX11
  void set_protocoltype(::std::string&& value);
  #endif
  void set_protocoltype(const char* value);
  void set_protocoltype(const char* value, size_t size);
  ::std::string* mutable_protocoltype();
  ::std::string* release_protocoltype();
  void set_allocated_protocoltype(::std::string* protocoltype);

  // optional int32 ProtocolVersion = 1;
  bool has_protocolversion() const;
  void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  ::google::protobuf::int32 protocolversion() const;
  void set_protocolversion(::google::protobuf::int32 value);

  // optional .DTC_PB.EncodingEnum Encoding = 2;
  bool has_encoding() const;
  void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  ::DTC_PB::EncodingEnum encoding() const;
  void set_encoding(::DTC_PB::EncodingEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.EncodingResponse)
 private:
  void set_has_protocolversion();
  void clear_has_protocolversion();
  void set_has_encoding();
  void clear_has_encoding();
  void set_has_protocoltype();
  void clear_has_protocoltype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocoltype_;
  ::google::protobuf::int32 protocolversion_;
  int encoding_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogonRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.LogonRequest) */ {
 public:
  LogonRequest();
  virtual ~LogonRequest();

  LogonRequest(const LogonRequest& from);

  inline LogonRequest& operator=(const LogonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogonRequest(LogonRequest&& from) noexcept
    : LogonRequest() {
    *this = ::std::move(from);
  }

  inline LogonRequest& operator=(LogonRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogonRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogonRequest* internal_default_instance() {
    return reinterpret_cast<const LogonRequest*>(
               &_LogonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LogonRequest* other);
  friend void swap(LogonRequest& a, LogonRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogonRequest* New() const final {
    return CreateMaybeMessage<LogonRequest>(NULL);
  }

  LogonRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogonRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogonRequest& from);
  void MergeFrom(const LogonRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogonRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string Password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string GeneralTextData = 4;
  bool has_generaltextdata() const;
  void clear_generaltextdata();
  static const int kGeneralTextDataFieldNumber = 4;
  const ::std::string& generaltextdata() const;
  void set_generaltextdata(const ::std::string& value);
  #if LANG_CXX11
  void set_generaltextdata(::std::string&& value);
  #endif
  void set_generaltextdata(const char* value);
  void set_generaltextdata(const char* value, size_t size);
  ::std::string* mutable_generaltextdata();
  ::std::string* release_generaltextdata();
  void set_allocated_generaltextdata(::std::string* generaltextdata);

  // optional string TradeAccount = 9;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 9;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string HardwareIdentifier = 10;
  bool has_hardwareidentifier() const;
  void clear_hardwareidentifier();
  static const int kHardwareIdentifierFieldNumber = 10;
  const ::std::string& hardwareidentifier() const;
  void set_hardwareidentifier(const ::std::string& value);
  #if LANG_CXX11
  void set_hardwareidentifier(::std::string&& value);
  #endif
  void set_hardwareidentifier(const char* value);
  void set_hardwareidentifier(const char* value, size_t size);
  ::std::string* mutable_hardwareidentifier();
  ::std::string* release_hardwareidentifier();
  void set_allocated_hardwareidentifier(::std::string* hardwareidentifier);

  // optional string ClientName = 11;
  bool has_clientname() const;
  void clear_clientname();
  static const int kClientNameFieldNumber = 11;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // optional int32 ProtocolVersion = 1;
  bool has_protocolversion() const;
  void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  ::google::protobuf::int32 protocolversion() const;
  void set_protocolversion(::google::protobuf::int32 value);

  // optional int32 Integer_1 = 5;
  bool has_integer_1() const;
  void clear_integer_1();
  static const int kInteger1FieldNumber = 5;
  ::google::protobuf::int32 integer_1() const;
  void set_integer_1(::google::protobuf::int32 value);

  // optional int32 Integer_2 = 6;
  bool has_integer_2() const;
  void clear_integer_2();
  static const int kInteger2FieldNumber = 6;
  ::google::protobuf::int32 integer_2() const;
  void set_integer_2(::google::protobuf::int32 value);

  // optional int32 HeartbeatIntervalInSeconds = 7;
  bool has_heartbeatintervalinseconds() const;
  void clear_heartbeatintervalinseconds();
  static const int kHeartbeatIntervalInSecondsFieldNumber = 7;
  ::google::protobuf::int32 heartbeatintervalinseconds() const;
  void set_heartbeatintervalinseconds(::google::protobuf::int32 value);

  // optional .DTC_PB.TradeModeEnum TradeMode = 8;
  bool has_trademode() const;
  void clear_trademode();
  static const int kTradeModeFieldNumber = 8;
  ::DTC_PB::TradeModeEnum trademode() const;
  void set_trademode(::DTC_PB::TradeModeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.LogonRequest)
 private:
  void set_has_protocolversion();
  void clear_has_protocolversion();
  void set_has_username();
  void clear_has_username();
  void set_has_password();
  void clear_has_password();
  void set_has_generaltextdata();
  void clear_has_generaltextdata();
  void set_has_integer_1();
  void clear_has_integer_1();
  void set_has_integer_2();
  void clear_has_integer_2();
  void set_has_heartbeatintervalinseconds();
  void clear_has_heartbeatintervalinseconds();
  void set_has_trademode();
  void clear_has_trademode();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_hardwareidentifier();
  void clear_has_hardwareidentifier();
  void set_has_clientname();
  void clear_has_clientname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr generaltextdata_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr hardwareidentifier_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::google::protobuf::int32 protocolversion_;
  ::google::protobuf::int32 integer_1_;
  ::google::protobuf::int32 integer_2_;
  ::google::protobuf::int32 heartbeatintervalinseconds_;
  int trademode_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogonResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.LogonResponse) */ {
 public:
  LogonResponse();
  virtual ~LogonResponse();

  LogonResponse(const LogonResponse& from);

  inline LogonResponse& operator=(const LogonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogonResponse(LogonResponse&& from) noexcept
    : LogonResponse() {
    *this = ::std::move(from);
  }

  inline LogonResponse& operator=(LogonResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogonResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogonResponse* internal_default_instance() {
    return reinterpret_cast<const LogonResponse*>(
               &_LogonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LogonResponse* other);
  friend void swap(LogonResponse& a, LogonResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogonResponse* New() const final {
    return CreateMaybeMessage<LogonResponse>(NULL);
  }

  LogonResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogonResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogonResponse& from);
  void MergeFrom(const LogonResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogonResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ResultText = 3;
  bool has_resulttext() const;
  void clear_resulttext();
  static const int kResultTextFieldNumber = 3;
  const ::std::string& resulttext() const;
  void set_resulttext(const ::std::string& value);
  #if LANG_CXX11
  void set_resulttext(::std::string&& value);
  #endif
  void set_resulttext(const char* value);
  void set_resulttext(const char* value, size_t size);
  ::std::string* mutable_resulttext();
  ::std::string* release_resulttext();
  void set_allocated_resulttext(::std::string* resulttext);

  // optional string ReconnectAddress = 4;
  bool has_reconnectaddress() const;
  void clear_reconnectaddress();
  static const int kReconnectAddressFieldNumber = 4;
  const ::std::string& reconnectaddress() const;
  void set_reconnectaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_reconnectaddress(::std::string&& value);
  #endif
  void set_reconnectaddress(const char* value);
  void set_reconnectaddress(const char* value, size_t size);
  ::std::string* mutable_reconnectaddress();
  ::std::string* release_reconnectaddress();
  void set_allocated_reconnectaddress(::std::string* reconnectaddress);

  // optional string ServerName = 6;
  bool has_servername() const;
  void clear_servername();
  static const int kServerNameFieldNumber = 6;
  const ::std::string& servername() const;
  void set_servername(const ::std::string& value);
  #if LANG_CXX11
  void set_servername(::std::string&& value);
  #endif
  void set_servername(const char* value);
  void set_servername(const char* value, size_t size);
  ::std::string* mutable_servername();
  ::std::string* release_servername();
  void set_allocated_servername(::std::string* servername);

  // optional string SymbolExchangeDelimiter = 11;
  bool has_symbolexchangedelimiter() const;
  void clear_symbolexchangedelimiter();
  static const int kSymbolExchangeDelimiterFieldNumber = 11;
  const ::std::string& symbolexchangedelimiter() const;
  void set_symbolexchangedelimiter(const ::std::string& value);
  #if LANG_CXX11
  void set_symbolexchangedelimiter(::std::string&& value);
  #endif
  void set_symbolexchangedelimiter(const char* value);
  void set_symbolexchangedelimiter(const char* value, size_t size);
  ::std::string* mutable_symbolexchangedelimiter();
  ::std::string* release_symbolexchangedelimiter();
  void set_allocated_symbolexchangedelimiter(::std::string* symbolexchangedelimiter);

  // optional int32 ProtocolVersion = 1;
  bool has_protocolversion() const;
  void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  ::google::protobuf::int32 protocolversion() const;
  void set_protocolversion(::google::protobuf::int32 value);

  // optional int32 Integer_1 = 5;
  bool has_integer_1() const;
  void clear_integer_1();
  static const int kInteger1FieldNumber = 5;
  ::google::protobuf::int32 integer_1() const;
  void set_integer_1(::google::protobuf::int32 value);

  // optional uint32 MarketDepthUpdatesBestBidAndAsk = 7;
  bool has_marketdepthupdatesbestbidandask() const;
  void clear_marketdepthupdatesbestbidandask();
  static const int kMarketDepthUpdatesBestBidAndAskFieldNumber = 7;
  ::google::protobuf::uint32 marketdepthupdatesbestbidandask() const;
  void set_marketdepthupdatesbestbidandask(::google::protobuf::uint32 value);

  // optional uint32 TradingIsSupported = 8;
  bool has_tradingissupported() const;
  void clear_tradingissupported();
  static const int kTradingIsSupportedFieldNumber = 8;
  ::google::protobuf::uint32 tradingissupported() const;
  void set_tradingissupported(::google::protobuf::uint32 value);

  // optional uint32 OCOOrdersSupported = 9;
  bool has_ocoorderssupported() const;
  void clear_ocoorderssupported();
  static const int kOCOOrdersSupportedFieldNumber = 9;
  ::google::protobuf::uint32 ocoorderssupported() const;
  void set_ocoorderssupported(::google::protobuf::uint32 value);

  // optional uint32 OrderCancelReplaceSupported = 10;
  bool has_ordercancelreplacesupported() const;
  void clear_ordercancelreplacesupported();
  static const int kOrderCancelReplaceSupportedFieldNumber = 10;
  ::google::protobuf::uint32 ordercancelreplacesupported() const;
  void set_ordercancelreplacesupported(::google::protobuf::uint32 value);

  // optional uint32 SecurityDefinitionsSupported = 12;
  bool has_securitydefinitionssupported() const;
  void clear_securitydefinitionssupported();
  static const int kSecurityDefinitionsSupportedFieldNumber = 12;
  ::google::protobuf::uint32 securitydefinitionssupported() const;
  void set_securitydefinitionssupported(::google::protobuf::uint32 value);

  // optional uint32 HistoricalPriceDataSupported = 13;
  bool has_historicalpricedatasupported() const;
  void clear_historicalpricedatasupported();
  static const int kHistoricalPriceDataSupportedFieldNumber = 13;
  ::google::protobuf::uint32 historicalpricedatasupported() const;
  void set_historicalpricedatasupported(::google::protobuf::uint32 value);

  // optional uint32 ResubscribeWhenMarketDataFeedAvailable = 14;
  bool has_resubscribewhenmarketdatafeedavailable() const;
  void clear_resubscribewhenmarketdatafeedavailable();
  static const int kResubscribeWhenMarketDataFeedAvailableFieldNumber = 14;
  ::google::protobuf::uint32 resubscribewhenmarketdatafeedavailable() const;
  void set_resubscribewhenmarketdatafeedavailable(::google::protobuf::uint32 value);

  // optional uint32 MarketDepthIsSupported = 15;
  bool has_marketdepthissupported() const;
  void clear_marketdepthissupported();
  static const int kMarketDepthIsSupportedFieldNumber = 15;
  ::google::protobuf::uint32 marketdepthissupported() const;
  void set_marketdepthissupported(::google::protobuf::uint32 value);

  // optional uint32 OneHistoricalPriceDataRequestPerConnection = 16;
  bool has_onehistoricalpricedatarequestperconnection() const;
  void clear_onehistoricalpricedatarequestperconnection();
  static const int kOneHistoricalPriceDataRequestPerConnectionFieldNumber = 16;
  ::google::protobuf::uint32 onehistoricalpricedatarequestperconnection() const;
  void set_onehistoricalpricedatarequestperconnection(::google::protobuf::uint32 value);

  // optional uint32 BracketOrdersSupported = 17;
  bool has_bracketorderssupported() const;
  void clear_bracketorderssupported();
  static const int kBracketOrdersSupportedFieldNumber = 17;
  ::google::protobuf::uint32 bracketorderssupported() const;
  void set_bracketorderssupported(::google::protobuf::uint32 value);

  // optional uint32 UseIntegerPriceOrderMessages = 18;
  bool has_useintegerpriceordermessages() const;
  void clear_useintegerpriceordermessages();
  static const int kUseIntegerPriceOrderMessagesFieldNumber = 18;
  ::google::protobuf::uint32 useintegerpriceordermessages() const;
  void set_useintegerpriceordermessages(::google::protobuf::uint32 value);

  // optional uint32 UsesMultiplePositionsPerSymbolAndTradeAccount = 19;
  bool has_usesmultiplepositionspersymbolandtradeaccount() const;
  void clear_usesmultiplepositionspersymbolandtradeaccount();
  static const int kUsesMultiplePositionsPerSymbolAndTradeAccountFieldNumber = 19;
  ::google::protobuf::uint32 usesmultiplepositionspersymbolandtradeaccount() const;
  void set_usesmultiplepositionspersymbolandtradeaccount(::google::protobuf::uint32 value);

  // optional uint32 MarketDataSupported = 20;
  bool has_marketdatasupported() const;
  void clear_marketdatasupported();
  static const int kMarketDataSupportedFieldNumber = 20;
  ::google::protobuf::uint32 marketdatasupported() const;
  void set_marketdatasupported(::google::protobuf::uint32 value);

  // optional .DTC_PB.LogonStatusEnum Result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::DTC_PB::LogonStatusEnum result() const;
  void set_result(::DTC_PB::LogonStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.LogonResponse)
 private:
  void set_has_protocolversion();
  void clear_has_protocolversion();
  void set_has_result();
  void clear_has_result();
  void set_has_resulttext();
  void clear_has_resulttext();
  void set_has_reconnectaddress();
  void clear_has_reconnectaddress();
  void set_has_integer_1();
  void clear_has_integer_1();
  void set_has_servername();
  void clear_has_servername();
  void set_has_marketdepthupdatesbestbidandask();
  void clear_has_marketdepthupdatesbestbidandask();
  void set_has_tradingissupported();
  void clear_has_tradingissupported();
  void set_has_ocoorderssupported();
  void clear_has_ocoorderssupported();
  void set_has_ordercancelreplacesupported();
  void clear_has_ordercancelreplacesupported();
  void set_has_symbolexchangedelimiter();
  void clear_has_symbolexchangedelimiter();
  void set_has_securitydefinitionssupported();
  void clear_has_securitydefinitionssupported();
  void set_has_historicalpricedatasupported();
  void clear_has_historicalpricedatasupported();
  void set_has_resubscribewhenmarketdatafeedavailable();
  void clear_has_resubscribewhenmarketdatafeedavailable();
  void set_has_marketdepthissupported();
  void clear_has_marketdepthissupported();
  void set_has_onehistoricalpricedatarequestperconnection();
  void clear_has_onehistoricalpricedatarequestperconnection();
  void set_has_bracketorderssupported();
  void clear_has_bracketorderssupported();
  void set_has_useintegerpriceordermessages();
  void clear_has_useintegerpriceordermessages();
  void set_has_usesmultiplepositionspersymbolandtradeaccount();
  void clear_has_usesmultiplepositionspersymbolandtradeaccount();
  void set_has_marketdatasupported();
  void clear_has_marketdatasupported();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr resulttext_;
  ::google::protobuf::internal::ArenaStringPtr reconnectaddress_;
  ::google::protobuf::internal::ArenaStringPtr servername_;
  ::google::protobuf::internal::ArenaStringPtr symbolexchangedelimiter_;
  ::google::protobuf::int32 protocolversion_;
  ::google::protobuf::int32 integer_1_;
  ::google::protobuf::uint32 marketdepthupdatesbestbidandask_;
  ::google::protobuf::uint32 tradingissupported_;
  ::google::protobuf::uint32 ocoorderssupported_;
  ::google::protobuf::uint32 ordercancelreplacesupported_;
  ::google::protobuf::uint32 securitydefinitionssupported_;
  ::google::protobuf::uint32 historicalpricedatasupported_;
  ::google::protobuf::uint32 resubscribewhenmarketdatafeedavailable_;
  ::google::protobuf::uint32 marketdepthissupported_;
  ::google::protobuf::uint32 onehistoricalpricedatarequestperconnection_;
  ::google::protobuf::uint32 bracketorderssupported_;
  ::google::protobuf::uint32 useintegerpriceordermessages_;
  ::google::protobuf::uint32 usesmultiplepositionspersymbolandtradeaccount_;
  ::google::protobuf::uint32 marketdatasupported_;
  int result_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Logoff : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.Logoff) */ {
 public:
  Logoff();
  virtual ~Logoff();

  Logoff(const Logoff& from);

  inline Logoff& operator=(const Logoff& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Logoff(Logoff&& from) noexcept
    : Logoff() {
    *this = ::std::move(from);
  }

  inline Logoff& operator=(Logoff&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logoff& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logoff* internal_default_instance() {
    return reinterpret_cast<const Logoff*>(
               &_Logoff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Logoff* other);
  friend void swap(Logoff& a, Logoff& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Logoff* New() const final {
    return CreateMaybeMessage<Logoff>(NULL);
  }

  Logoff* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Logoff>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Logoff& from);
  void MergeFrom(const Logoff& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logoff* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Reason = 1;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // optional uint32 DoNotReconnect = 2;
  bool has_donotreconnect() const;
  void clear_donotreconnect();
  static const int kDoNotReconnectFieldNumber = 2;
  ::google::protobuf::uint32 donotreconnect() const;
  void set_donotreconnect(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.Logoff)
 private:
  void set_has_reason();
  void clear_has_reason();
  void set_has_donotreconnect();
  void clear_has_donotreconnect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::uint32 donotreconnect_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.Heartbeat) */ {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Heartbeat* other);
  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Heartbeat* New() const final {
    return CreateMaybeMessage<Heartbeat>(NULL);
  }

  Heartbeat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 CurrentDateTime = 2;
  bool has_currentdatetime() const;
  void clear_currentdatetime();
  static const int kCurrentDateTimeFieldNumber = 2;
  ::google::protobuf::int64 currentdatetime() const;
  void set_currentdatetime(::google::protobuf::int64 value);

  // optional uint32 NumDroppedMessages = 1;
  bool has_numdroppedmessages() const;
  void clear_numdroppedmessages();
  static const int kNumDroppedMessagesFieldNumber = 1;
  ::google::protobuf::uint32 numdroppedmessages() const;
  void set_numdroppedmessages(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.Heartbeat)
 private:
  void set_has_numdroppedmessages();
  void clear_has_numdroppedmessages();
  void set_has_currentdatetime();
  void clear_has_currentdatetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 currentdatetime_;
  ::google::protobuf::uint32 numdroppedmessages_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataFeedStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataFeedStatus) */ {
 public:
  MarketDataFeedStatus();
  virtual ~MarketDataFeedStatus();

  MarketDataFeedStatus(const MarketDataFeedStatus& from);

  inline MarketDataFeedStatus& operator=(const MarketDataFeedStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataFeedStatus(MarketDataFeedStatus&& from) noexcept
    : MarketDataFeedStatus() {
    *this = ::std::move(from);
  }

  inline MarketDataFeedStatus& operator=(MarketDataFeedStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataFeedStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataFeedStatus* internal_default_instance() {
    return reinterpret_cast<const MarketDataFeedStatus*>(
               &_MarketDataFeedStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MarketDataFeedStatus* other);
  friend void swap(MarketDataFeedStatus& a, MarketDataFeedStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataFeedStatus* New() const final {
    return CreateMaybeMessage<MarketDataFeedStatus>(NULL);
  }

  MarketDataFeedStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataFeedStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataFeedStatus& from);
  void MergeFrom(const MarketDataFeedStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataFeedStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DTC_PB.MarketDataFeedStatusEnum Status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::DTC_PB::MarketDataFeedStatusEnum status() const;
  void set_status(::DTC_PB::MarketDataFeedStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataFeedStatus)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataFeedSymbolStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataFeedSymbolStatus) */ {
 public:
  MarketDataFeedSymbolStatus();
  virtual ~MarketDataFeedSymbolStatus();

  MarketDataFeedSymbolStatus(const MarketDataFeedSymbolStatus& from);

  inline MarketDataFeedSymbolStatus& operator=(const MarketDataFeedSymbolStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataFeedSymbolStatus(MarketDataFeedSymbolStatus&& from) noexcept
    : MarketDataFeedSymbolStatus() {
    *this = ::std::move(from);
  }

  inline MarketDataFeedSymbolStatus& operator=(MarketDataFeedSymbolStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataFeedSymbolStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataFeedSymbolStatus* internal_default_instance() {
    return reinterpret_cast<const MarketDataFeedSymbolStatus*>(
               &_MarketDataFeedSymbolStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MarketDataFeedSymbolStatus* other);
  friend void swap(MarketDataFeedSymbolStatus& a, MarketDataFeedSymbolStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataFeedSymbolStatus* New() const final {
    return CreateMaybeMessage<MarketDataFeedSymbolStatus>(NULL);
  }

  MarketDataFeedSymbolStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataFeedSymbolStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataFeedSymbolStatus& from);
  void MergeFrom(const MarketDataFeedSymbolStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataFeedSymbolStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.MarketDataFeedStatusEnum Status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::DTC_PB::MarketDataFeedStatusEnum status() const;
  void set_status(::DTC_PB::MarketDataFeedStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataFeedSymbolStatus)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int status_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradingSymbolStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.TradingSymbolStatus) */ {
 public:
  TradingSymbolStatus();
  virtual ~TradingSymbolStatus();

  TradingSymbolStatus(const TradingSymbolStatus& from);

  inline TradingSymbolStatus& operator=(const TradingSymbolStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradingSymbolStatus(TradingSymbolStatus&& from) noexcept
    : TradingSymbolStatus() {
    *this = ::std::move(from);
  }

  inline TradingSymbolStatus& operator=(TradingSymbolStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradingSymbolStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradingSymbolStatus* internal_default_instance() {
    return reinterpret_cast<const TradingSymbolStatus*>(
               &_TradingSymbolStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TradingSymbolStatus* other);
  friend void swap(TradingSymbolStatus& a, TradingSymbolStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradingSymbolStatus* New() const final {
    return CreateMaybeMessage<TradingSymbolStatus>(NULL);
  }

  TradingSymbolStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradingSymbolStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradingSymbolStatus& from);
  void MergeFrom(const TradingSymbolStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingSymbolStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.TradingStatusEnum Status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::DTC_PB::TradingStatusEnum status() const;
  void set_status(::DTC_PB::TradingStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.TradingSymbolStatus)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int status_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataRequest) */ {
 public:
  MarketDataRequest();
  virtual ~MarketDataRequest();

  MarketDataRequest(const MarketDataRequest& from);

  inline MarketDataRequest& operator=(const MarketDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataRequest(MarketDataRequest&& from) noexcept
    : MarketDataRequest() {
    *this = ::std::move(from);
  }

  inline MarketDataRequest& operator=(MarketDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataRequest* internal_default_instance() {
    return reinterpret_cast<const MarketDataRequest*>(
               &_MarketDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(MarketDataRequest* other);
  friend void swap(MarketDataRequest& a, MarketDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataRequest* New() const final {
    return CreateMaybeMessage<MarketDataRequest>(NULL);
  }

  MarketDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataRequest& from);
  void MergeFrom(const MarketDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 3;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 4;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 4;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional uint32 SymbolID = 2;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 2;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.RequestActionEnum RequestAction = 1;
  bool has_requestaction() const;
  void clear_requestaction();
  static const int kRequestActionFieldNumber = 1;
  ::DTC_PB::RequestActionEnum requestaction() const;
  void set_requestaction(::DTC_PB::RequestActionEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataRequest)
 private:
  void set_has_requestaction();
  void clear_has_requestaction();
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::uint32 symbolid_;
  int requestaction_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthRequest) */ {
 public:
  MarketDepthRequest();
  virtual ~MarketDepthRequest();

  MarketDepthRequest(const MarketDepthRequest& from);

  inline MarketDepthRequest& operator=(const MarketDepthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthRequest(MarketDepthRequest&& from) noexcept
    : MarketDepthRequest() {
    *this = ::std::move(from);
  }

  inline MarketDepthRequest& operator=(MarketDepthRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthRequest* internal_default_instance() {
    return reinterpret_cast<const MarketDepthRequest*>(
               &_MarketDepthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(MarketDepthRequest* other);
  friend void swap(MarketDepthRequest& a, MarketDepthRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthRequest* New() const final {
    return CreateMaybeMessage<MarketDepthRequest>(NULL);
  }

  MarketDepthRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthRequest& from);
  void MergeFrom(const MarketDepthRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 3;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 4;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 4;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional uint32 SymbolID = 2;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 2;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 NumLevels = 5;
  bool has_numlevels() const;
  void clear_numlevels();
  static const int kNumLevelsFieldNumber = 5;
  ::google::protobuf::int32 numlevels() const;
  void set_numlevels(::google::protobuf::int32 value);

  // optional .DTC_PB.RequestActionEnum RequestAction = 1;
  bool has_requestaction() const;
  void clear_requestaction();
  static const int kRequestActionFieldNumber = 1;
  ::DTC_PB::RequestActionEnum requestaction() const;
  void set_requestaction(::DTC_PB::RequestActionEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthRequest)
 private:
  void set_has_requestaction();
  void clear_has_requestaction();
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_numlevels();
  void clear_has_numlevels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 numlevels_;
  int requestaction_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataReject) */ {
 public:
  MarketDataReject();
  virtual ~MarketDataReject();

  MarketDataReject(const MarketDataReject& from);

  inline MarketDataReject& operator=(const MarketDataReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataReject(MarketDataReject&& from) noexcept
    : MarketDataReject() {
    *this = ::std::move(from);
  }

  inline MarketDataReject& operator=(MarketDataReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataReject* internal_default_instance() {
    return reinterpret_cast<const MarketDataReject*>(
               &_MarketDataReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(MarketDataReject* other);
  friend void swap(MarketDataReject& a, MarketDataReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataReject* New() const final {
    return CreateMaybeMessage<MarketDataReject>(NULL);
  }

  MarketDataReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataReject& from);
  void MergeFrom(const MarketDataReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataReject)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::uint32 symbolid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataSnapshot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataSnapshot) */ {
 public:
  MarketDataSnapshot();
  virtual ~MarketDataSnapshot();

  MarketDataSnapshot(const MarketDataSnapshot& from);

  inline MarketDataSnapshot& operator=(const MarketDataSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataSnapshot(MarketDataSnapshot&& from) noexcept
    : MarketDataSnapshot() {
    *this = ::std::move(from);
  }

  inline MarketDataSnapshot& operator=(MarketDataSnapshot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataSnapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataSnapshot* internal_default_instance() {
    return reinterpret_cast<const MarketDataSnapshot*>(
               &_MarketDataSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(MarketDataSnapshot* other);
  friend void swap(MarketDataSnapshot& a, MarketDataSnapshot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataSnapshot* New() const final {
    return CreateMaybeMessage<MarketDataSnapshot>(NULL);
  }

  MarketDataSnapshot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataSnapshot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataSnapshot& from);
  void MergeFrom(const MarketDataSnapshot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double SessionSettlementPrice = 2;
  bool has_sessionsettlementprice() const;
  void clear_sessionsettlementprice();
  static const int kSessionSettlementPriceFieldNumber = 2;
  double sessionsettlementprice() const;
  void set_sessionsettlementprice(double value);

  // optional double SessionOpenPrice = 3;
  bool has_sessionopenprice() const;
  void clear_sessionopenprice();
  static const int kSessionOpenPriceFieldNumber = 3;
  double sessionopenprice() const;
  void set_sessionopenprice(double value);

  // optional double SessionHighPrice = 4;
  bool has_sessionhighprice() const;
  void clear_sessionhighprice();
  static const int kSessionHighPriceFieldNumber = 4;
  double sessionhighprice() const;
  void set_sessionhighprice(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 SessionNumTrades = 7;
  bool has_sessionnumtrades() const;
  void clear_sessionnumtrades();
  static const int kSessionNumTradesFieldNumber = 7;
  ::google::protobuf::uint32 sessionnumtrades() const;
  void set_sessionnumtrades(::google::protobuf::uint32 value);

  // optional double SessionLowPrice = 5;
  bool has_sessionlowprice() const;
  void clear_sessionlowprice();
  static const int kSessionLowPriceFieldNumber = 5;
  double sessionlowprice() const;
  void set_sessionlowprice(double value);

  // optional double SessionVolume = 6;
  bool has_sessionvolume() const;
  void clear_sessionvolume();
  static const int kSessionVolumeFieldNumber = 6;
  double sessionvolume() const;
  void set_sessionvolume(double value);

  // optional double BidPrice = 9;
  bool has_bidprice() const;
  void clear_bidprice();
  static const int kBidPriceFieldNumber = 9;
  double bidprice() const;
  void set_bidprice(double value);

  // optional double AskPrice = 10;
  bool has_askprice() const;
  void clear_askprice();
  static const int kAskPriceFieldNumber = 10;
  double askprice() const;
  void set_askprice(double value);

  // optional double AskQuantity = 11;
  bool has_askquantity() const;
  void clear_askquantity();
  static const int kAskQuantityFieldNumber = 11;
  double askquantity() const;
  void set_askquantity(double value);

  // optional double BidQuantity = 12;
  bool has_bidquantity() const;
  void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 12;
  double bidquantity() const;
  void set_bidquantity(double value);

  // optional uint32 OpenInterest = 8;
  bool has_openinterest() const;
  void clear_openinterest();
  static const int kOpenInterestFieldNumber = 8;
  ::google::protobuf::uint32 openinterest() const;
  void set_openinterest(::google::protobuf::uint32 value);

  // optional uint32 SessionSettlementDateTime = 17;
  bool has_sessionsettlementdatetime() const;
  void clear_sessionsettlementdatetime();
  static const int kSessionSettlementDateTimeFieldNumber = 17;
  ::google::protobuf::uint32 sessionsettlementdatetime() const;
  void set_sessionsettlementdatetime(::google::protobuf::uint32 value);

  // optional double LastTradePrice = 13;
  bool has_lasttradeprice() const;
  void clear_lasttradeprice();
  static const int kLastTradePriceFieldNumber = 13;
  double lasttradeprice() const;
  void set_lasttradeprice(double value);

  // optional double LastTradeVolume = 14;
  bool has_lasttradevolume() const;
  void clear_lasttradevolume();
  static const int kLastTradeVolumeFieldNumber = 14;
  double lasttradevolume() const;
  void set_lasttradevolume(double value);

  // optional double LastTradeDateTime = 15;
  bool has_lasttradedatetime() const;
  void clear_lasttradedatetime();
  static const int kLastTradeDateTimeFieldNumber = 15;
  double lasttradedatetime() const;
  void set_lasttradedatetime(double value);

  // optional double BidAskDateTime = 16;
  bool has_bidaskdatetime() const;
  void clear_bidaskdatetime();
  static const int kBidAskDateTimeFieldNumber = 16;
  double bidaskdatetime() const;
  void set_bidaskdatetime(double value);

  // optional uint32 TradingSessionDate = 18;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 18;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // optional .DTC_PB.TradingStatusEnum TradingStatus = 19;
  bool has_tradingstatus() const;
  void clear_tradingstatus();
  static const int kTradingStatusFieldNumber = 19;
  ::DTC_PB::TradingStatusEnum tradingstatus() const;
  void set_tradingstatus(::DTC_PB::TradingStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataSnapshot)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_sessionsettlementprice();
  void clear_has_sessionsettlementprice();
  void set_has_sessionopenprice();
  void clear_has_sessionopenprice();
  void set_has_sessionhighprice();
  void clear_has_sessionhighprice();
  void set_has_sessionlowprice();
  void clear_has_sessionlowprice();
  void set_has_sessionvolume();
  void clear_has_sessionvolume();
  void set_has_sessionnumtrades();
  void clear_has_sessionnumtrades();
  void set_has_openinterest();
  void clear_has_openinterest();
  void set_has_bidprice();
  void clear_has_bidprice();
  void set_has_askprice();
  void clear_has_askprice();
  void set_has_askquantity();
  void clear_has_askquantity();
  void set_has_bidquantity();
  void clear_has_bidquantity();
  void set_has_lasttradeprice();
  void clear_has_lasttradeprice();
  void set_has_lasttradevolume();
  void clear_has_lasttradevolume();
  void set_has_lasttradedatetime();
  void clear_has_lasttradedatetime();
  void set_has_bidaskdatetime();
  void clear_has_bidaskdatetime();
  void set_has_sessionsettlementdatetime();
  void clear_has_sessionsettlementdatetime();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();
  void set_has_tradingstatus();
  void clear_has_tradingstatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double sessionsettlementprice_;
  double sessionopenprice_;
  double sessionhighprice_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 sessionnumtrades_;
  double sessionlowprice_;
  double sessionvolume_;
  double bidprice_;
  double askprice_;
  double askquantity_;
  double bidquantity_;
  ::google::protobuf::uint32 openinterest_;
  ::google::protobuf::uint32 sessionsettlementdatetime_;
  double lasttradeprice_;
  double lasttradevolume_;
  double lasttradedatetime_;
  double bidaskdatetime_;
  ::google::protobuf::uint32 tradingsessiondate_;
  int tradingstatus_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataSnapshot_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataSnapshot_Int) */ {
 public:
  MarketDataSnapshot_Int();
  virtual ~MarketDataSnapshot_Int();

  MarketDataSnapshot_Int(const MarketDataSnapshot_Int& from);

  inline MarketDataSnapshot_Int& operator=(const MarketDataSnapshot_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataSnapshot_Int(MarketDataSnapshot_Int&& from) noexcept
    : MarketDataSnapshot_Int() {
    *this = ::std::move(from);
  }

  inline MarketDataSnapshot_Int& operator=(MarketDataSnapshot_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataSnapshot_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataSnapshot_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDataSnapshot_Int*>(
               &_MarketDataSnapshot_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MarketDataSnapshot_Int* other);
  friend void swap(MarketDataSnapshot_Int& a, MarketDataSnapshot_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataSnapshot_Int* New() const final {
    return CreateMaybeMessage<MarketDataSnapshot_Int>(NULL);
  }

  MarketDataSnapshot_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataSnapshot_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataSnapshot_Int& from);
  void MergeFrom(const MarketDataSnapshot_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataSnapshot_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 SessionSettlementPrice = 2;
  bool has_sessionsettlementprice() const;
  void clear_sessionsettlementprice();
  static const int kSessionSettlementPriceFieldNumber = 2;
  ::google::protobuf::int32 sessionsettlementprice() const;
  void set_sessionsettlementprice(::google::protobuf::int32 value);

  // optional int32 SessionOpenPrice = 3;
  bool has_sessionopenprice() const;
  void clear_sessionopenprice();
  static const int kSessionOpenPriceFieldNumber = 3;
  ::google::protobuf::int32 sessionopenprice() const;
  void set_sessionopenprice(::google::protobuf::int32 value);

  // optional int32 SessionHighPrice = 4;
  bool has_sessionhighprice() const;
  void clear_sessionhighprice();
  static const int kSessionHighPriceFieldNumber = 4;
  ::google::protobuf::int32 sessionhighprice() const;
  void set_sessionhighprice(::google::protobuf::int32 value);

  // optional int32 SessionLowPrice = 5;
  bool has_sessionlowprice() const;
  void clear_sessionlowprice();
  static const int kSessionLowPriceFieldNumber = 5;
  ::google::protobuf::int32 sessionlowprice() const;
  void set_sessionlowprice(::google::protobuf::int32 value);

  // optional int32 SessionVolume = 6;
  bool has_sessionvolume() const;
  void clear_sessionvolume();
  static const int kSessionVolumeFieldNumber = 6;
  ::google::protobuf::int32 sessionvolume() const;
  void set_sessionvolume(::google::protobuf::int32 value);

  // optional uint32 SessionNumTrades = 7;
  bool has_sessionnumtrades() const;
  void clear_sessionnumtrades();
  static const int kSessionNumTradesFieldNumber = 7;
  ::google::protobuf::uint32 sessionnumtrades() const;
  void set_sessionnumtrades(::google::protobuf::uint32 value);

  // optional uint32 OpenInterest = 8;
  bool has_openinterest() const;
  void clear_openinterest();
  static const int kOpenInterestFieldNumber = 8;
  ::google::protobuf::uint32 openinterest() const;
  void set_openinterest(::google::protobuf::uint32 value);

  // optional int32 BidPrice = 9;
  bool has_bidprice() const;
  void clear_bidprice();
  static const int kBidPriceFieldNumber = 9;
  ::google::protobuf::int32 bidprice() const;
  void set_bidprice(::google::protobuf::int32 value);

  // optional int32 AskPrice = 10;
  bool has_askprice() const;
  void clear_askprice();
  static const int kAskPriceFieldNumber = 10;
  ::google::protobuf::int32 askprice() const;
  void set_askprice(::google::protobuf::int32 value);

  // optional int32 AskQuantity = 11;
  bool has_askquantity() const;
  void clear_askquantity();
  static const int kAskQuantityFieldNumber = 11;
  ::google::protobuf::int32 askquantity() const;
  void set_askquantity(::google::protobuf::int32 value);

  // optional int32 BidQuantity = 12;
  bool has_bidquantity() const;
  void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 12;
  ::google::protobuf::int32 bidquantity() const;
  void set_bidquantity(::google::protobuf::int32 value);

  // optional int32 LastTradePrice = 13;
  bool has_lasttradeprice() const;
  void clear_lasttradeprice();
  static const int kLastTradePriceFieldNumber = 13;
  ::google::protobuf::int32 lasttradeprice() const;
  void set_lasttradeprice(::google::protobuf::int32 value);

  // optional int32 LastTradeVolume = 14;
  bool has_lasttradevolume() const;
  void clear_lasttradevolume();
  static const int kLastTradeVolumeFieldNumber = 14;
  ::google::protobuf::int32 lasttradevolume() const;
  void set_lasttradevolume(::google::protobuf::int32 value);

  // optional double LastTradeDateTime = 15;
  bool has_lasttradedatetime() const;
  void clear_lasttradedatetime();
  static const int kLastTradeDateTimeFieldNumber = 15;
  double lasttradedatetime() const;
  void set_lasttradedatetime(double value);

  // optional double BidAskDateTime = 16;
  bool has_bidaskdatetime() const;
  void clear_bidaskdatetime();
  static const int kBidAskDateTimeFieldNumber = 16;
  double bidaskdatetime() const;
  void set_bidaskdatetime(double value);

  // optional uint32 SessionSettlementDateTime = 17;
  bool has_sessionsettlementdatetime() const;
  void clear_sessionsettlementdatetime();
  static const int kSessionSettlementDateTimeFieldNumber = 17;
  ::google::protobuf::uint32 sessionsettlementdatetime() const;
  void set_sessionsettlementdatetime(::google::protobuf::uint32 value);

  // optional uint32 TradingSessionDate = 18;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 18;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // optional .DTC_PB.TradingStatusEnum TradingStatus = 19;
  bool has_tradingstatus() const;
  void clear_tradingstatus();
  static const int kTradingStatusFieldNumber = 19;
  ::DTC_PB::TradingStatusEnum tradingstatus() const;
  void set_tradingstatus(::DTC_PB::TradingStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataSnapshot_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_sessionsettlementprice();
  void clear_has_sessionsettlementprice();
  void set_has_sessionopenprice();
  void clear_has_sessionopenprice();
  void set_has_sessionhighprice();
  void clear_has_sessionhighprice();
  void set_has_sessionlowprice();
  void clear_has_sessionlowprice();
  void set_has_sessionvolume();
  void clear_has_sessionvolume();
  void set_has_sessionnumtrades();
  void clear_has_sessionnumtrades();
  void set_has_openinterest();
  void clear_has_openinterest();
  void set_has_bidprice();
  void clear_has_bidprice();
  void set_has_askprice();
  void clear_has_askprice();
  void set_has_askquantity();
  void clear_has_askquantity();
  void set_has_bidquantity();
  void clear_has_bidquantity();
  void set_has_lasttradeprice();
  void clear_has_lasttradeprice();
  void set_has_lasttradevolume();
  void clear_has_lasttradevolume();
  void set_has_lasttradedatetime();
  void clear_has_lasttradedatetime();
  void set_has_bidaskdatetime();
  void clear_has_bidaskdatetime();
  void set_has_sessionsettlementdatetime();
  void clear_has_sessionsettlementdatetime();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();
  void set_has_tradingstatus();
  void clear_has_tradingstatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 sessionsettlementprice_;
  ::google::protobuf::int32 sessionopenprice_;
  ::google::protobuf::int32 sessionhighprice_;
  ::google::protobuf::int32 sessionlowprice_;
  ::google::protobuf::int32 sessionvolume_;
  ::google::protobuf::uint32 sessionnumtrades_;
  ::google::protobuf::uint32 openinterest_;
  ::google::protobuf::int32 bidprice_;
  ::google::protobuf::int32 askprice_;
  ::google::protobuf::int32 askquantity_;
  ::google::protobuf::int32 bidquantity_;
  ::google::protobuf::int32 lasttradeprice_;
  ::google::protobuf::int32 lasttradevolume_;
  double lasttradedatetime_;
  double bidaskdatetime_;
  ::google::protobuf::uint32 sessionsettlementdatetime_;
  ::google::protobuf::uint32 tradingsessiondate_;
  int tradingstatus_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DepthEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.DepthEntry) */ {
 public:
  DepthEntry();
  virtual ~DepthEntry();

  DepthEntry(const DepthEntry& from);

  inline DepthEntry& operator=(const DepthEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DepthEntry(DepthEntry&& from) noexcept
    : DepthEntry() {
    *this = ::std::move(from);
  }

  inline DepthEntry& operator=(DepthEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DepthEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthEntry* internal_default_instance() {
    return reinterpret_cast<const DepthEntry*>(
               &_DepthEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(DepthEntry* other);
  friend void swap(DepthEntry& a, DepthEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthEntry* New() const final {
    return CreateMaybeMessage<DepthEntry>(NULL);
  }

  DepthEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DepthEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DepthEntry& from);
  void MergeFrom(const DepthEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double Price = 1;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 1;
  double price() const;
  void set_price(double value);

  // optional float Quantity = 12;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 12;
  float quantity() const;
  void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:DTC_PB.DepthEntry)
 private:
  void set_has_price();
  void clear_has_price();
  void set_has_quantity();
  void clear_has_quantity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double price_;
  float quantity_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthFullUpdate20 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthFullUpdate20) */ {
 public:
  MarketDepthFullUpdate20();
  virtual ~MarketDepthFullUpdate20();

  MarketDepthFullUpdate20(const MarketDepthFullUpdate20& from);

  inline MarketDepthFullUpdate20& operator=(const MarketDepthFullUpdate20& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthFullUpdate20(MarketDepthFullUpdate20&& from) noexcept
    : MarketDepthFullUpdate20() {
    *this = ::std::move(from);
  }

  inline MarketDepthFullUpdate20& operator=(MarketDepthFullUpdate20&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthFullUpdate20& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthFullUpdate20* internal_default_instance() {
    return reinterpret_cast<const MarketDepthFullUpdate20*>(
               &_MarketDepthFullUpdate20_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MarketDepthFullUpdate20* other);
  friend void swap(MarketDepthFullUpdate20& a, MarketDepthFullUpdate20& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthFullUpdate20* New() const final {
    return CreateMaybeMessage<MarketDepthFullUpdate20>(NULL);
  }

  MarketDepthFullUpdate20* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthFullUpdate20>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthFullUpdate20& from);
  void MergeFrom(const MarketDepthFullUpdate20& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthFullUpdate20* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DTC_PB.DepthEntry BidDepth = 2;
  int biddepth_size() const;
  void clear_biddepth();
  static const int kBidDepthFieldNumber = 2;
  ::DTC_PB::DepthEntry* mutable_biddepth(int index);
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_biddepth();
  const ::DTC_PB::DepthEntry& biddepth(int index) const;
  ::DTC_PB::DepthEntry* add_biddepth();
  const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      biddepth() const;

  // repeated .DTC_PB.DepthEntry AskDepth = 3;
  int askdepth_size() const;
  void clear_askdepth();
  static const int kAskDepthFieldNumber = 3;
  ::DTC_PB::DepthEntry* mutable_askdepth(int index);
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_askdepth();
  const ::DTC_PB::DepthEntry& askdepth(int index) const;
  ::DTC_PB::DepthEntry* add_askdepth();
  const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      askdepth() const;

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthFullUpdate20)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > biddepth_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > askdepth_;
  ::google::protobuf::uint32 symbolid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthFullUpdate10 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthFullUpdate10) */ {
 public:
  MarketDepthFullUpdate10();
  virtual ~MarketDepthFullUpdate10();

  MarketDepthFullUpdate10(const MarketDepthFullUpdate10& from);

  inline MarketDepthFullUpdate10& operator=(const MarketDepthFullUpdate10& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthFullUpdate10(MarketDepthFullUpdate10&& from) noexcept
    : MarketDepthFullUpdate10() {
    *this = ::std::move(from);
  }

  inline MarketDepthFullUpdate10& operator=(MarketDepthFullUpdate10&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthFullUpdate10& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthFullUpdate10* internal_default_instance() {
    return reinterpret_cast<const MarketDepthFullUpdate10*>(
               &_MarketDepthFullUpdate10_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(MarketDepthFullUpdate10* other);
  friend void swap(MarketDepthFullUpdate10& a, MarketDepthFullUpdate10& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthFullUpdate10* New() const final {
    return CreateMaybeMessage<MarketDepthFullUpdate10>(NULL);
  }

  MarketDepthFullUpdate10* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthFullUpdate10>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthFullUpdate10& from);
  void MergeFrom(const MarketDepthFullUpdate10& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthFullUpdate10* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DTC_PB.DepthEntry BidDepth = 2;
  int biddepth_size() const;
  void clear_biddepth();
  static const int kBidDepthFieldNumber = 2;
  ::DTC_PB::DepthEntry* mutable_biddepth(int index);
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_biddepth();
  const ::DTC_PB::DepthEntry& biddepth(int index) const;
  ::DTC_PB::DepthEntry* add_biddepth();
  const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      biddepth() const;

  // repeated .DTC_PB.DepthEntry AskDepth = 3;
  int askdepth_size() const;
  void clear_askdepth();
  static const int kAskDepthFieldNumber = 3;
  ::DTC_PB::DepthEntry* mutable_askdepth(int index);
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_askdepth();
  const ::DTC_PB::DepthEntry& askdepth(int index) const;
  ::DTC_PB::DepthEntry* add_askdepth();
  const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      askdepth() const;

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthFullUpdate10)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > biddepth_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > askdepth_;
  ::google::protobuf::uint32 symbolid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthSnapshotLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthSnapshotLevel) */ {
 public:
  MarketDepthSnapshotLevel();
  virtual ~MarketDepthSnapshotLevel();

  MarketDepthSnapshotLevel(const MarketDepthSnapshotLevel& from);

  inline MarketDepthSnapshotLevel& operator=(const MarketDepthSnapshotLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthSnapshotLevel(MarketDepthSnapshotLevel&& from) noexcept
    : MarketDepthSnapshotLevel() {
    *this = ::std::move(from);
  }

  inline MarketDepthSnapshotLevel& operator=(MarketDepthSnapshotLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthSnapshotLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthSnapshotLevel* internal_default_instance() {
    return reinterpret_cast<const MarketDepthSnapshotLevel*>(
               &_MarketDepthSnapshotLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MarketDepthSnapshotLevel* other);
  friend void swap(MarketDepthSnapshotLevel& a, MarketDepthSnapshotLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthSnapshotLevel* New() const final {
    return CreateMaybeMessage<MarketDepthSnapshotLevel>(NULL);
  }

  MarketDepthSnapshotLevel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthSnapshotLevel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthSnapshotLevel& from);
  void MergeFrom(const MarketDepthSnapshotLevel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthSnapshotLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum side() const;
  void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  double price() const;
  void set_price(double value);

  // optional double Quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  double quantity() const;
  void set_quantity(double value);

  // optional uint32 Level = 5;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // optional uint32 IsFirstMessageInBatch = 6;
  bool has_isfirstmessageinbatch() const;
  void clear_isfirstmessageinbatch();
  static const int kIsFirstMessageInBatchFieldNumber = 6;
  ::google::protobuf::uint32 isfirstmessageinbatch() const;
  void set_isfirstmessageinbatch(::google::protobuf::uint32 value);

  // optional double DateTime = 8;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 8;
  double datetime() const;
  void set_datetime(double value);

  // optional uint32 IsLastMessageInBatch = 7;
  bool has_islastmessageinbatch() const;
  void clear_islastmessageinbatch();
  static const int kIsLastMessageInBatchFieldNumber = 7;
  ::google::protobuf::uint32 islastmessageinbatch() const;
  void set_islastmessageinbatch(::google::protobuf::uint32 value);

  // optional uint32 NumOrders = 9;
  bool has_numorders() const;
  void clear_numorders();
  static const int kNumOrdersFieldNumber = 9;
  ::google::protobuf::uint32 numorders() const;
  void set_numorders(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthSnapshotLevel)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_side();
  void clear_has_side();
  void set_has_price();
  void clear_has_price();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_level();
  void clear_has_level();
  void set_has_isfirstmessageinbatch();
  void clear_has_isfirstmessageinbatch();
  void set_has_islastmessageinbatch();
  void clear_has_islastmessageinbatch();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_numorders();
  void clear_has_numorders();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  double price_;
  double quantity_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 isfirstmessageinbatch_;
  double datetime_;
  ::google::protobuf::uint32 islastmessageinbatch_;
  ::google::protobuf::uint32 numorders_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthSnapshotLevel_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthSnapshotLevel_Int) */ {
 public:
  MarketDepthSnapshotLevel_Int();
  virtual ~MarketDepthSnapshotLevel_Int();

  MarketDepthSnapshotLevel_Int(const MarketDepthSnapshotLevel_Int& from);

  inline MarketDepthSnapshotLevel_Int& operator=(const MarketDepthSnapshotLevel_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthSnapshotLevel_Int(MarketDepthSnapshotLevel_Int&& from) noexcept
    : MarketDepthSnapshotLevel_Int() {
    *this = ::std::move(from);
  }

  inline MarketDepthSnapshotLevel_Int& operator=(MarketDepthSnapshotLevel_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthSnapshotLevel_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthSnapshotLevel_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDepthSnapshotLevel_Int*>(
               &_MarketDepthSnapshotLevel_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(MarketDepthSnapshotLevel_Int* other);
  friend void swap(MarketDepthSnapshotLevel_Int& a, MarketDepthSnapshotLevel_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthSnapshotLevel_Int* New() const final {
    return CreateMaybeMessage<MarketDepthSnapshotLevel_Int>(NULL);
  }

  MarketDepthSnapshotLevel_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthSnapshotLevel_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthSnapshotLevel_Int& from);
  void MergeFrom(const MarketDepthSnapshotLevel_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthSnapshotLevel_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum side() const;
  void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional int32 Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional int32 Quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  ::google::protobuf::int32 quantity() const;
  void set_quantity(::google::protobuf::int32 value);

  // optional uint32 Level = 5;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // optional uint32 IsFirstMessageInBatch = 6;
  bool has_isfirstmessageinbatch() const;
  void clear_isfirstmessageinbatch();
  static const int kIsFirstMessageInBatchFieldNumber = 6;
  ::google::protobuf::uint32 isfirstmessageinbatch() const;
  void set_isfirstmessageinbatch(::google::protobuf::uint32 value);

  // optional double DateTime = 8;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 8;
  double datetime() const;
  void set_datetime(double value);

  // optional uint32 IsLastMessageInBatch = 7;
  bool has_islastmessageinbatch() const;
  void clear_islastmessageinbatch();
  static const int kIsLastMessageInBatchFieldNumber = 7;
  ::google::protobuf::uint32 islastmessageinbatch() const;
  void set_islastmessageinbatch(::google::protobuf::uint32 value);

  // optional uint32 NumOrders = 9;
  bool has_numorders() const;
  void clear_numorders();
  static const int kNumOrdersFieldNumber = 9;
  ::google::protobuf::uint32 numorders() const;
  void set_numorders(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthSnapshotLevel_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_side();
  void clear_has_side();
  void set_has_price();
  void clear_has_price();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_level();
  void clear_has_level();
  void set_has_isfirstmessageinbatch();
  void clear_has_isfirstmessageinbatch();
  void set_has_islastmessageinbatch();
  void clear_has_islastmessageinbatch();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_numorders();
  void clear_has_numorders();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 quantity_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 isfirstmessageinbatch_;
  double datetime_;
  ::google::protobuf::uint32 islastmessageinbatch_;
  ::google::protobuf::uint32 numorders_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthUpdateLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthUpdateLevel) */ {
 public:
  MarketDepthUpdateLevel();
  virtual ~MarketDepthUpdateLevel();

  MarketDepthUpdateLevel(const MarketDepthUpdateLevel& from);

  inline MarketDepthUpdateLevel& operator=(const MarketDepthUpdateLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthUpdateLevel(MarketDepthUpdateLevel&& from) noexcept
    : MarketDepthUpdateLevel() {
    *this = ::std::move(from);
  }

  inline MarketDepthUpdateLevel& operator=(MarketDepthUpdateLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthUpdateLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthUpdateLevel* internal_default_instance() {
    return reinterpret_cast<const MarketDepthUpdateLevel*>(
               &_MarketDepthUpdateLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(MarketDepthUpdateLevel* other);
  friend void swap(MarketDepthUpdateLevel& a, MarketDepthUpdateLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthUpdateLevel* New() const final {
    return CreateMaybeMessage<MarketDepthUpdateLevel>(NULL);
  }

  MarketDepthUpdateLevel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthUpdateLevel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthUpdateLevel& from);
  void MergeFrom(const MarketDepthUpdateLevel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthUpdateLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum side() const;
  void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  double price() const;
  void set_price(double value);

  // optional double Quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  double quantity() const;
  void set_quantity(double value);

  // optional double DateTime = 6;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  double datetime() const;
  void set_datetime(double value);

  // optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
  bool has_updatetype() const;
  void clear_updatetype();
  static const int kUpdateTypeFieldNumber = 5;
  ::DTC_PB::MarketDepthUpdateTypeEnum updatetype() const;
  void set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value);

  // optional uint32 NumOrders = 7;
  bool has_numorders() const;
  void clear_numorders();
  static const int kNumOrdersFieldNumber = 7;
  ::google::protobuf::uint32 numorders() const;
  void set_numorders(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthUpdateLevel)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_side();
  void clear_has_side();
  void set_has_price();
  void clear_has_price();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_updatetype();
  void clear_has_updatetype();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_numorders();
  void clear_has_numorders();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  double price_;
  double quantity_;
  double datetime_;
  int updatetype_;
  ::google::protobuf::uint32 numorders_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthUpdateLevel_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthUpdateLevel_Int) */ {
 public:
  MarketDepthUpdateLevel_Int();
  virtual ~MarketDepthUpdateLevel_Int();

  MarketDepthUpdateLevel_Int(const MarketDepthUpdateLevel_Int& from);

  inline MarketDepthUpdateLevel_Int& operator=(const MarketDepthUpdateLevel_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthUpdateLevel_Int(MarketDepthUpdateLevel_Int&& from) noexcept
    : MarketDepthUpdateLevel_Int() {
    *this = ::std::move(from);
  }

  inline MarketDepthUpdateLevel_Int& operator=(MarketDepthUpdateLevel_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthUpdateLevel_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthUpdateLevel_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDepthUpdateLevel_Int*>(
               &_MarketDepthUpdateLevel_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(MarketDepthUpdateLevel_Int* other);
  friend void swap(MarketDepthUpdateLevel_Int& a, MarketDepthUpdateLevel_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthUpdateLevel_Int* New() const final {
    return CreateMaybeMessage<MarketDepthUpdateLevel_Int>(NULL);
  }

  MarketDepthUpdateLevel_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthUpdateLevel_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthUpdateLevel_Int& from);
  void MergeFrom(const MarketDepthUpdateLevel_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthUpdateLevel_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum side() const;
  void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional int32 Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional int32 Quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  ::google::protobuf::int32 quantity() const;
  void set_quantity(::google::protobuf::int32 value);

  // optional double DateTime = 6;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  double datetime() const;
  void set_datetime(double value);

  // optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
  bool has_updatetype() const;
  void clear_updatetype();
  static const int kUpdateTypeFieldNumber = 5;
  ::DTC_PB::MarketDepthUpdateTypeEnum updatetype() const;
  void set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value);

  // optional uint32 NumOrders = 7;
  bool has_numorders() const;
  void clear_numorders();
  static const int kNumOrdersFieldNumber = 7;
  ::google::protobuf::uint32 numorders() const;
  void set_numorders(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthUpdateLevel_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_side();
  void clear_has_side();
  void set_has_price();
  void clear_has_price();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_updatetype();
  void clear_has_updatetype();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_numorders();
  void clear_has_numorders();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 quantity_;
  double datetime_;
  int updatetype_;
  ::google::protobuf::uint32 numorders_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthUpdateLevelCompact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthUpdateLevelCompact) */ {
 public:
  MarketDepthUpdateLevelCompact();
  virtual ~MarketDepthUpdateLevelCompact();

  MarketDepthUpdateLevelCompact(const MarketDepthUpdateLevelCompact& from);

  inline MarketDepthUpdateLevelCompact& operator=(const MarketDepthUpdateLevelCompact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthUpdateLevelCompact(MarketDepthUpdateLevelCompact&& from) noexcept
    : MarketDepthUpdateLevelCompact() {
    *this = ::std::move(from);
  }

  inline MarketDepthUpdateLevelCompact& operator=(MarketDepthUpdateLevelCompact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthUpdateLevelCompact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthUpdateLevelCompact* internal_default_instance() {
    return reinterpret_cast<const MarketDepthUpdateLevelCompact*>(
               &_MarketDepthUpdateLevelCompact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(MarketDepthUpdateLevelCompact* other);
  friend void swap(MarketDepthUpdateLevelCompact& a, MarketDepthUpdateLevelCompact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthUpdateLevelCompact* New() const final {
    return CreateMaybeMessage<MarketDepthUpdateLevelCompact>(NULL);
  }

  MarketDepthUpdateLevelCompact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthUpdateLevelCompact>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthUpdateLevelCompact& from);
  void MergeFrom(const MarketDepthUpdateLevelCompact& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthUpdateLevelCompact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum side() const;
  void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional float Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  float price() const;
  void set_price(float value);

  // optional float Quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  float quantity() const;
  void set_quantity(float value);

  // optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
  bool has_updatetype() const;
  void clear_updatetype();
  static const int kUpdateTypeFieldNumber = 5;
  ::DTC_PB::MarketDepthUpdateTypeEnum updatetype() const;
  void set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value);

  // optional uint32 DateTime = 6;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  ::google::protobuf::uint32 datetime() const;
  void set_datetime(::google::protobuf::uint32 value);

  // optional uint32 NumOrders = 7;
  bool has_numorders() const;
  void clear_numorders();
  static const int kNumOrdersFieldNumber = 7;
  ::google::protobuf::uint32 numorders() const;
  void set_numorders(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthUpdateLevelCompact)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_side();
  void clear_has_side();
  void set_has_price();
  void clear_has_price();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_updatetype();
  void clear_has_updatetype();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_numorders();
  void clear_has_numorders();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  float price_;
  float quantity_;
  int updatetype_;
  ::google::protobuf::uint32 datetime_;
  ::google::protobuf::uint32 numorders_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthUpdateLevelCompact2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthUpdateLevelCompact2) */ {
 public:
  MarketDepthUpdateLevelCompact2();
  virtual ~MarketDepthUpdateLevelCompact2();

  MarketDepthUpdateLevelCompact2(const MarketDepthUpdateLevelCompact2& from);

  inline MarketDepthUpdateLevelCompact2& operator=(const MarketDepthUpdateLevelCompact2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthUpdateLevelCompact2(MarketDepthUpdateLevelCompact2&& from) noexcept
    : MarketDepthUpdateLevelCompact2() {
    *this = ::std::move(from);
  }

  inline MarketDepthUpdateLevelCompact2& operator=(MarketDepthUpdateLevelCompact2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthUpdateLevelCompact2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthUpdateLevelCompact2* internal_default_instance() {
    return reinterpret_cast<const MarketDepthUpdateLevelCompact2*>(
               &_MarketDepthUpdateLevelCompact2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(MarketDepthUpdateLevelCompact2* other);
  friend void swap(MarketDepthUpdateLevelCompact2& a, MarketDepthUpdateLevelCompact2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthUpdateLevelCompact2* New() const final {
    return CreateMaybeMessage<MarketDepthUpdateLevelCompact2>(NULL);
  }

  MarketDepthUpdateLevelCompact2* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthUpdateLevelCompact2>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthUpdateLevelCompact2& from);
  void MergeFrom(const MarketDepthUpdateLevelCompact2& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthUpdateLevelCompact2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Side = 2;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 2;
  ::google::protobuf::int32 side() const;
  void set_side(::google::protobuf::int32 value);

  // optional int32 UpdateType = 3;
  bool has_updatetype() const;
  void clear_updatetype();
  static const int kUpdateTypeFieldNumber = 3;
  ::google::protobuf::int32 updatetype() const;
  void set_updatetype(::google::protobuf::int32 value);

  // optional uint32 NumOrders = 4;
  bool has_numorders() const;
  void clear_numorders();
  static const int kNumOrdersFieldNumber = 4;
  ::google::protobuf::uint32 numorders() const;
  void set_numorders(::google::protobuf::uint32 value);

  // optional float Price = 5;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 5;
  float price() const;
  void set_price(float value);

  // optional float Quantity = 6;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  float quantity() const;
  void set_quantity(float value);

  // optional uint32 DateTime = 7;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 7;
  ::google::protobuf::uint32 datetime() const;
  void set_datetime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthUpdateLevelCompact2)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_side();
  void clear_has_side();
  void set_has_updatetype();
  void clear_has_updatetype();
  void set_has_numorders();
  void clear_has_numorders();
  void set_has_price();
  void clear_has_price();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 side_;
  ::google::protobuf::int32 updatetype_;
  ::google::protobuf::uint32 numorders_;
  float price_;
  float quantity_;
  ::google::protobuf::uint32 datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionSettlement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionSettlement) */ {
 public:
  MarketDataUpdateSessionSettlement();
  virtual ~MarketDataUpdateSessionSettlement();

  MarketDataUpdateSessionSettlement(const MarketDataUpdateSessionSettlement& from);

  inline MarketDataUpdateSessionSettlement& operator=(const MarketDataUpdateSessionSettlement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionSettlement(MarketDataUpdateSessionSettlement&& from) noexcept
    : MarketDataUpdateSessionSettlement() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionSettlement& operator=(MarketDataUpdateSessionSettlement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionSettlement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionSettlement* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionSettlement*>(
               &_MarketDataUpdateSessionSettlement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(MarketDataUpdateSessionSettlement* other);
  friend void swap(MarketDataUpdateSessionSettlement& a, MarketDataUpdateSessionSettlement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionSettlement* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionSettlement>(NULL);
  }

  MarketDataUpdateSessionSettlement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionSettlement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionSettlement& from);
  void MergeFrom(const MarketDataUpdateSessionSettlement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionSettlement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  double price() const;
  void set_price(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 DateTime = 3;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 3;
  ::google::protobuf::uint32 datetime() const;
  void set_datetime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionSettlement)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionSettlement_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionSettlement_Int) */ {
 public:
  MarketDataUpdateSessionSettlement_Int();
  virtual ~MarketDataUpdateSessionSettlement_Int();

  MarketDataUpdateSessionSettlement_Int(const MarketDataUpdateSessionSettlement_Int& from);

  inline MarketDataUpdateSessionSettlement_Int& operator=(const MarketDataUpdateSessionSettlement_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionSettlement_Int(MarketDataUpdateSessionSettlement_Int&& from) noexcept
    : MarketDataUpdateSessionSettlement_Int() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionSettlement_Int& operator=(MarketDataUpdateSessionSettlement_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionSettlement_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionSettlement_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionSettlement_Int*>(
               &_MarketDataUpdateSessionSettlement_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(MarketDataUpdateSessionSettlement_Int* other);
  friend void swap(MarketDataUpdateSessionSettlement_Int& a, MarketDataUpdateSessionSettlement_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionSettlement_Int* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionSettlement_Int>(NULL);
  }

  MarketDataUpdateSessionSettlement_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionSettlement_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionSettlement_Int& from);
  void MergeFrom(const MarketDataUpdateSessionSettlement_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionSettlement_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional int32 DateTime = 3;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 3;
  ::google::protobuf::int32 datetime() const;
  void set_datetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionSettlement_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionOpen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionOpen) */ {
 public:
  MarketDataUpdateSessionOpen();
  virtual ~MarketDataUpdateSessionOpen();

  MarketDataUpdateSessionOpen(const MarketDataUpdateSessionOpen& from);

  inline MarketDataUpdateSessionOpen& operator=(const MarketDataUpdateSessionOpen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionOpen(MarketDataUpdateSessionOpen&& from) noexcept
    : MarketDataUpdateSessionOpen() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionOpen& operator=(MarketDataUpdateSessionOpen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionOpen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionOpen* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionOpen*>(
               &_MarketDataUpdateSessionOpen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(MarketDataUpdateSessionOpen* other);
  friend void swap(MarketDataUpdateSessionOpen& a, MarketDataUpdateSessionOpen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionOpen* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionOpen>(NULL);
  }

  MarketDataUpdateSessionOpen* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionOpen>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionOpen& from);
  void MergeFrom(const MarketDataUpdateSessionOpen& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionOpen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  double price() const;
  void set_price(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionOpen)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionOpen_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionOpen_Int) */ {
 public:
  MarketDataUpdateSessionOpen_Int();
  virtual ~MarketDataUpdateSessionOpen_Int();

  MarketDataUpdateSessionOpen_Int(const MarketDataUpdateSessionOpen_Int& from);

  inline MarketDataUpdateSessionOpen_Int& operator=(const MarketDataUpdateSessionOpen_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionOpen_Int(MarketDataUpdateSessionOpen_Int&& from) noexcept
    : MarketDataUpdateSessionOpen_Int() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionOpen_Int& operator=(MarketDataUpdateSessionOpen_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionOpen_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionOpen_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionOpen_Int*>(
               &_MarketDataUpdateSessionOpen_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(MarketDataUpdateSessionOpen_Int* other);
  friend void swap(MarketDataUpdateSessionOpen_Int& a, MarketDataUpdateSessionOpen_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionOpen_Int* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionOpen_Int>(NULL);
  }

  MarketDataUpdateSessionOpen_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionOpen_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionOpen_Int& from);
  void MergeFrom(const MarketDataUpdateSessionOpen_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionOpen_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionOpen_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionNumTrades : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionNumTrades) */ {
 public:
  MarketDataUpdateSessionNumTrades();
  virtual ~MarketDataUpdateSessionNumTrades();

  MarketDataUpdateSessionNumTrades(const MarketDataUpdateSessionNumTrades& from);

  inline MarketDataUpdateSessionNumTrades& operator=(const MarketDataUpdateSessionNumTrades& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionNumTrades(MarketDataUpdateSessionNumTrades&& from) noexcept
    : MarketDataUpdateSessionNumTrades() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionNumTrades& operator=(MarketDataUpdateSessionNumTrades&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionNumTrades& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionNumTrades* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionNumTrades*>(
               &_MarketDataUpdateSessionNumTrades_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(MarketDataUpdateSessionNumTrades* other);
  friend void swap(MarketDataUpdateSessionNumTrades& a, MarketDataUpdateSessionNumTrades& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionNumTrades* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionNumTrades>(NULL);
  }

  MarketDataUpdateSessionNumTrades* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionNumTrades>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionNumTrades& from);
  void MergeFrom(const MarketDataUpdateSessionNumTrades& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionNumTrades* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 NumTrades = 2;
  bool has_numtrades() const;
  void clear_numtrades();
  static const int kNumTradesFieldNumber = 2;
  ::google::protobuf::int32 numtrades() const;
  void set_numtrades(::google::protobuf::int32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionNumTrades)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_numtrades();
  void clear_has_numtrades();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 numtrades_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateTradingSessionDate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateTradingSessionDate) */ {
 public:
  MarketDataUpdateTradingSessionDate();
  virtual ~MarketDataUpdateTradingSessionDate();

  MarketDataUpdateTradingSessionDate(const MarketDataUpdateTradingSessionDate& from);

  inline MarketDataUpdateTradingSessionDate& operator=(const MarketDataUpdateTradingSessionDate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateTradingSessionDate(MarketDataUpdateTradingSessionDate&& from) noexcept
    : MarketDataUpdateTradingSessionDate() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateTradingSessionDate& operator=(MarketDataUpdateTradingSessionDate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTradingSessionDate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateTradingSessionDate* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateTradingSessionDate*>(
               &_MarketDataUpdateTradingSessionDate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(MarketDataUpdateTradingSessionDate* other);
  friend void swap(MarketDataUpdateTradingSessionDate& a, MarketDataUpdateTradingSessionDate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateTradingSessionDate* New() const final {
    return CreateMaybeMessage<MarketDataUpdateTradingSessionDate>(NULL);
  }

  MarketDataUpdateTradingSessionDate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateTradingSessionDate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateTradingSessionDate& from);
  void MergeFrom(const MarketDataUpdateTradingSessionDate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateTradingSessionDate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 Date = 2;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 2;
  ::google::protobuf::uint32 date() const;
  void set_date(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTradingSessionDate)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_date();
  void clear_has_date();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 date_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDepthReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDepthReject) */ {
 public:
  MarketDepthReject();
  virtual ~MarketDepthReject();

  MarketDepthReject(const MarketDepthReject& from);

  inline MarketDepthReject& operator=(const MarketDepthReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDepthReject(MarketDepthReject&& from) noexcept
    : MarketDepthReject() {
    *this = ::std::move(from);
  }

  inline MarketDepthReject& operator=(MarketDepthReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDepthReject* internal_default_instance() {
    return reinterpret_cast<const MarketDepthReject*>(
               &_MarketDepthReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(MarketDepthReject* other);
  friend void swap(MarketDepthReject& a, MarketDepthReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDepthReject* New() const final {
    return CreateMaybeMessage<MarketDepthReject>(NULL);
  }

  MarketDepthReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDepthReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDepthReject& from);
  void MergeFrom(const MarketDepthReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDepthReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthReject)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::uint32 symbolid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateTrade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateTrade) */ {
 public:
  MarketDataUpdateTrade();
  virtual ~MarketDataUpdateTrade();

  MarketDataUpdateTrade(const MarketDataUpdateTrade& from);

  inline MarketDataUpdateTrade& operator=(const MarketDataUpdateTrade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateTrade(MarketDataUpdateTrade&& from) noexcept
    : MarketDataUpdateTrade() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateTrade& operator=(MarketDataUpdateTrade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTrade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateTrade* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateTrade*>(
               &_MarketDataUpdateTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(MarketDataUpdateTrade* other);
  friend void swap(MarketDataUpdateTrade& a, MarketDataUpdateTrade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateTrade* New() const final {
    return CreateMaybeMessage<MarketDataUpdateTrade>(NULL);
  }

  MarketDataUpdateTrade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateTrade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateTrade& from);
  void MergeFrom(const MarketDataUpdateTrade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateTrade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
  bool has_atbidorask() const;
  void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  double price() const;
  void set_price(double value);

  // optional double Volume = 4;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  double volume() const;
  void set_volume(double value);

  // optional double DateTime = 5;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 5;
  double datetime() const;
  void set_datetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTrade)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_atbidorask();
  void clear_has_atbidorask();
  void set_has_price();
  void clear_has_price();
  void set_has_volume();
  void clear_has_volume();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int atbidorask_;
  double price_;
  double volume_;
  double datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateTrade_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateTrade_Int) */ {
 public:
  MarketDataUpdateTrade_Int();
  virtual ~MarketDataUpdateTrade_Int();

  MarketDataUpdateTrade_Int(const MarketDataUpdateTrade_Int& from);

  inline MarketDataUpdateTrade_Int& operator=(const MarketDataUpdateTrade_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateTrade_Int(MarketDataUpdateTrade_Int&& from) noexcept
    : MarketDataUpdateTrade_Int() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateTrade_Int& operator=(MarketDataUpdateTrade_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTrade_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateTrade_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateTrade_Int*>(
               &_MarketDataUpdateTrade_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(MarketDataUpdateTrade_Int* other);
  friend void swap(MarketDataUpdateTrade_Int& a, MarketDataUpdateTrade_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateTrade_Int* New() const final {
    return CreateMaybeMessage<MarketDataUpdateTrade_Int>(NULL);
  }

  MarketDataUpdateTrade_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateTrade_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateTrade_Int& from);
  void MergeFrom(const MarketDataUpdateTrade_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateTrade_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
  bool has_atbidorask() const;
  void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional int32 Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional int32 Volume = 4;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // optional double DateTime = 5;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 5;
  double datetime() const;
  void set_datetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTrade_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_atbidorask();
  void clear_has_atbidorask();
  void set_has_price();
  void clear_has_price();
  void set_has_volume();
  void clear_has_volume();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int atbidorask_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 volume_;
  double datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateTradeWithUnbundledIndicator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator) */ {
 public:
  MarketDataUpdateTradeWithUnbundledIndicator();
  virtual ~MarketDataUpdateTradeWithUnbundledIndicator();

  MarketDataUpdateTradeWithUnbundledIndicator(const MarketDataUpdateTradeWithUnbundledIndicator& from);

  inline MarketDataUpdateTradeWithUnbundledIndicator& operator=(const MarketDataUpdateTradeWithUnbundledIndicator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateTradeWithUnbundledIndicator(MarketDataUpdateTradeWithUnbundledIndicator&& from) noexcept
    : MarketDataUpdateTradeWithUnbundledIndicator() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateTradeWithUnbundledIndicator& operator=(MarketDataUpdateTradeWithUnbundledIndicator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTradeWithUnbundledIndicator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateTradeWithUnbundledIndicator* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateTradeWithUnbundledIndicator*>(
               &_MarketDataUpdateTradeWithUnbundledIndicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(MarketDataUpdateTradeWithUnbundledIndicator* other);
  friend void swap(MarketDataUpdateTradeWithUnbundledIndicator& a, MarketDataUpdateTradeWithUnbundledIndicator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateTradeWithUnbundledIndicator* New() const final {
    return CreateMaybeMessage<MarketDataUpdateTradeWithUnbundledIndicator>(NULL);
  }

  MarketDataUpdateTradeWithUnbundledIndicator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateTradeWithUnbundledIndicator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateTradeWithUnbundledIndicator& from);
  void MergeFrom(const MarketDataUpdateTradeWithUnbundledIndicator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateTradeWithUnbundledIndicator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum8 AtBidOrAsk = 2;
  bool has_atbidorask() const;
  void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 2;
  ::DTC_PB::AtBidOrAskEnum8 atbidorask() const;
  void set_atbidorask(::DTC_PB::AtBidOrAskEnum8 value);

  // optional double Price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  double price() const;
  void set_price(double value);

  // optional .DTC_PB.UnbundledTradeIndicatorEnum UnbundledTradeIndicator = 3;
  bool has_unbundledtradeindicator() const;
  void clear_unbundledtradeindicator();
  static const int kUnbundledTradeIndicatorFieldNumber = 3;
  ::DTC_PB::UnbundledTradeIndicatorEnum unbundledtradeindicator() const;
  void set_unbundledtradeindicator(::DTC_PB::UnbundledTradeIndicatorEnum value);

  // optional uint32 Volume = 5;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 5;
  ::google::protobuf::uint32 volume() const;
  void set_volume(::google::protobuf::uint32 value);

  // optional double DateTime = 6;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  double datetime() const;
  void set_datetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_atbidorask();
  void clear_has_atbidorask();
  void set_has_unbundledtradeindicator();
  void clear_has_unbundledtradeindicator();
  void set_has_price();
  void clear_has_price();
  void set_has_volume();
  void clear_has_volume();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int atbidorask_;
  double price_;
  int unbundledtradeindicator_;
  ::google::protobuf::uint32 volume_;
  double datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateBidAsk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateBidAsk) */ {
 public:
  MarketDataUpdateBidAsk();
  virtual ~MarketDataUpdateBidAsk();

  MarketDataUpdateBidAsk(const MarketDataUpdateBidAsk& from);

  inline MarketDataUpdateBidAsk& operator=(const MarketDataUpdateBidAsk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateBidAsk(MarketDataUpdateBidAsk&& from) noexcept
    : MarketDataUpdateBidAsk() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateBidAsk& operator=(MarketDataUpdateBidAsk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateBidAsk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateBidAsk* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateBidAsk*>(
               &_MarketDataUpdateBidAsk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(MarketDataUpdateBidAsk* other);
  friend void swap(MarketDataUpdateBidAsk& a, MarketDataUpdateBidAsk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateBidAsk* New() const final {
    return CreateMaybeMessage<MarketDataUpdateBidAsk>(NULL);
  }

  MarketDataUpdateBidAsk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateBidAsk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateBidAsk& from);
  void MergeFrom(const MarketDataUpdateBidAsk& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateBidAsk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double BidPrice = 2;
  bool has_bidprice() const;
  void clear_bidprice();
  static const int kBidPriceFieldNumber = 2;
  double bidprice() const;
  void set_bidprice(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional float BidQuantity = 3;
  bool has_bidquantity() const;
  void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 3;
  float bidquantity() const;
  void set_bidquantity(float value);

  // optional double AskPrice = 4;
  bool has_askprice() const;
  void clear_askprice();
  static const int kAskPriceFieldNumber = 4;
  double askprice() const;
  void set_askprice(double value);

  // optional float AskQuantity = 5;
  bool has_askquantity() const;
  void clear_askquantity();
  static const int kAskQuantityFieldNumber = 5;
  float askquantity() const;
  void set_askquantity(float value);

  // optional sfixed32 DateTime = 6;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  ::google::protobuf::int32 datetime() const;
  void set_datetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateBidAsk)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_bidprice();
  void clear_has_bidprice();
  void set_has_bidquantity();
  void clear_has_bidquantity();
  void set_has_askprice();
  void clear_has_askprice();
  void set_has_askquantity();
  void clear_has_askquantity();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double bidprice_;
  ::google::protobuf::uint32 symbolid_;
  float bidquantity_;
  double askprice_;
  float askquantity_;
  ::google::protobuf::int32 datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateBidAsk_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateBidAsk_Int) */ {
 public:
  MarketDataUpdateBidAsk_Int();
  virtual ~MarketDataUpdateBidAsk_Int();

  MarketDataUpdateBidAsk_Int(const MarketDataUpdateBidAsk_Int& from);

  inline MarketDataUpdateBidAsk_Int& operator=(const MarketDataUpdateBidAsk_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateBidAsk_Int(MarketDataUpdateBidAsk_Int&& from) noexcept
    : MarketDataUpdateBidAsk_Int() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateBidAsk_Int& operator=(MarketDataUpdateBidAsk_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateBidAsk_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateBidAsk_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateBidAsk_Int*>(
               &_MarketDataUpdateBidAsk_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(MarketDataUpdateBidAsk_Int* other);
  friend void swap(MarketDataUpdateBidAsk_Int& a, MarketDataUpdateBidAsk_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateBidAsk_Int* New() const final {
    return CreateMaybeMessage<MarketDataUpdateBidAsk_Int>(NULL);
  }

  MarketDataUpdateBidAsk_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateBidAsk_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateBidAsk_Int& from);
  void MergeFrom(const MarketDataUpdateBidAsk_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateBidAsk_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 BidPrice = 2;
  bool has_bidprice() const;
  void clear_bidprice();
  static const int kBidPriceFieldNumber = 2;
  ::google::protobuf::int32 bidprice() const;
  void set_bidprice(::google::protobuf::int32 value);

  // optional int32 BidQuantity = 3;
  bool has_bidquantity() const;
  void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 3;
  ::google::protobuf::int32 bidquantity() const;
  void set_bidquantity(::google::protobuf::int32 value);

  // optional int32 AskPrice = 4;
  bool has_askprice() const;
  void clear_askprice();
  static const int kAskPriceFieldNumber = 4;
  ::google::protobuf::int32 askprice() const;
  void set_askprice(::google::protobuf::int32 value);

  // optional int32 AskQuantity = 5;
  bool has_askquantity() const;
  void clear_askquantity();
  static const int kAskQuantityFieldNumber = 5;
  ::google::protobuf::int32 askquantity() const;
  void set_askquantity(::google::protobuf::int32 value);

  // optional sfixed32 DateTime = 6;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  ::google::protobuf::int32 datetime() const;
  void set_datetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateBidAsk_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_bidprice();
  void clear_has_bidprice();
  void set_has_bidquantity();
  void clear_has_bidquantity();
  void set_has_askprice();
  void clear_has_askprice();
  void set_has_askquantity();
  void clear_has_askquantity();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 bidprice_;
  ::google::protobuf::int32 bidquantity_;
  ::google::protobuf::int32 askprice_;
  ::google::protobuf::int32 askquantity_;
  ::google::protobuf::int32 datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateBidAskCompact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateBidAskCompact) */ {
 public:
  MarketDataUpdateBidAskCompact();
  virtual ~MarketDataUpdateBidAskCompact();

  MarketDataUpdateBidAskCompact(const MarketDataUpdateBidAskCompact& from);

  inline MarketDataUpdateBidAskCompact& operator=(const MarketDataUpdateBidAskCompact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateBidAskCompact(MarketDataUpdateBidAskCompact&& from) noexcept
    : MarketDataUpdateBidAskCompact() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateBidAskCompact& operator=(MarketDataUpdateBidAskCompact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateBidAskCompact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateBidAskCompact* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateBidAskCompact*>(
               &_MarketDataUpdateBidAskCompact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(MarketDataUpdateBidAskCompact* other);
  friend void swap(MarketDataUpdateBidAskCompact& a, MarketDataUpdateBidAskCompact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateBidAskCompact* New() const final {
    return CreateMaybeMessage<MarketDataUpdateBidAskCompact>(NULL);
  }

  MarketDataUpdateBidAskCompact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateBidAskCompact>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateBidAskCompact& from);
  void MergeFrom(const MarketDataUpdateBidAskCompact& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateBidAskCompact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float BidPrice = 1;
  bool has_bidprice() const;
  void clear_bidprice();
  static const int kBidPriceFieldNumber = 1;
  float bidprice() const;
  void set_bidprice(float value);

  // optional float BidQuantity = 2;
  bool has_bidquantity() const;
  void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 2;
  float bidquantity() const;
  void set_bidquantity(float value);

  // optional float AskPrice = 3;
  bool has_askprice() const;
  void clear_askprice();
  static const int kAskPriceFieldNumber = 3;
  float askprice() const;
  void set_askprice(float value);

  // optional float AskQuantity = 4;
  bool has_askquantity() const;
  void clear_askquantity();
  static const int kAskQuantityFieldNumber = 4;
  float askquantity() const;
  void set_askquantity(float value);

  // optional sfixed32 DateTime = 5;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 5;
  ::google::protobuf::int32 datetime() const;
  void set_datetime(::google::protobuf::int32 value);

  // optional uint32 SymbolID = 6;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 6;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateBidAskCompact)
 private:
  void set_has_bidprice();
  void clear_has_bidprice();
  void set_has_bidquantity();
  void clear_has_bidquantity();
  void set_has_askprice();
  void clear_has_askprice();
  void set_has_askquantity();
  void clear_has_askquantity();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_symbolid();
  void clear_has_symbolid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float bidprice_;
  float bidquantity_;
  float askprice_;
  float askquantity_;
  ::google::protobuf::int32 datetime_;
  ::google::protobuf::uint32 symbolid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateTradeCompact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateTradeCompact) */ {
 public:
  MarketDataUpdateTradeCompact();
  virtual ~MarketDataUpdateTradeCompact();

  MarketDataUpdateTradeCompact(const MarketDataUpdateTradeCompact& from);

  inline MarketDataUpdateTradeCompact& operator=(const MarketDataUpdateTradeCompact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateTradeCompact(MarketDataUpdateTradeCompact&& from) noexcept
    : MarketDataUpdateTradeCompact() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateTradeCompact& operator=(MarketDataUpdateTradeCompact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTradeCompact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateTradeCompact* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateTradeCompact*>(
               &_MarketDataUpdateTradeCompact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(MarketDataUpdateTradeCompact* other);
  friend void swap(MarketDataUpdateTradeCompact& a, MarketDataUpdateTradeCompact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateTradeCompact* New() const final {
    return CreateMaybeMessage<MarketDataUpdateTradeCompact>(NULL);
  }

  MarketDataUpdateTradeCompact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateTradeCompact>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateTradeCompact& from);
  void MergeFrom(const MarketDataUpdateTradeCompact& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateTradeCompact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float Price = 1;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 1;
  float price() const;
  void set_price(float value);

  // optional float Volume = 2;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 2;
  float volume() const;
  void set_volume(float value);

  // optional sfixed32 DateTime = 3;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 3;
  ::google::protobuf::int32 datetime() const;
  void set_datetime(::google::protobuf::int32 value);

  // optional uint32 SymbolID = 4;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 4;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
  bool has_atbidorask() const;
  void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 5;
  ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTradeCompact)
 private:
  void set_has_price();
  void clear_has_price();
  void set_has_volume();
  void clear_has_volume();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_atbidorask();
  void clear_has_atbidorask();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float price_;
  float volume_;
  ::google::protobuf::int32 datetime_;
  ::google::protobuf::uint32 symbolid_;
  int atbidorask_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionVolume) */ {
 public:
  MarketDataUpdateSessionVolume();
  virtual ~MarketDataUpdateSessionVolume();

  MarketDataUpdateSessionVolume(const MarketDataUpdateSessionVolume& from);

  inline MarketDataUpdateSessionVolume& operator=(const MarketDataUpdateSessionVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionVolume(MarketDataUpdateSessionVolume&& from) noexcept
    : MarketDataUpdateSessionVolume() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionVolume& operator=(MarketDataUpdateSessionVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionVolume* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionVolume*>(
               &_MarketDataUpdateSessionVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(MarketDataUpdateSessionVolume* other);
  friend void swap(MarketDataUpdateSessionVolume& a, MarketDataUpdateSessionVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionVolume* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionVolume>(NULL);
  }

  MarketDataUpdateSessionVolume* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionVolume>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionVolume& from);
  void MergeFrom(const MarketDataUpdateSessionVolume& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionVolume* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double Volume = 2;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 2;
  double volume() const;
  void set_volume(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionVolume)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_volume();
  void clear_has_volume();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double volume_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateOpenInterest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateOpenInterest) */ {
 public:
  MarketDataUpdateOpenInterest();
  virtual ~MarketDataUpdateOpenInterest();

  MarketDataUpdateOpenInterest(const MarketDataUpdateOpenInterest& from);

  inline MarketDataUpdateOpenInterest& operator=(const MarketDataUpdateOpenInterest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateOpenInterest(MarketDataUpdateOpenInterest&& from) noexcept
    : MarketDataUpdateOpenInterest() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateOpenInterest& operator=(MarketDataUpdateOpenInterest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateOpenInterest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateOpenInterest* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateOpenInterest*>(
               &_MarketDataUpdateOpenInterest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(MarketDataUpdateOpenInterest* other);
  friend void swap(MarketDataUpdateOpenInterest& a, MarketDataUpdateOpenInterest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateOpenInterest* New() const final {
    return CreateMaybeMessage<MarketDataUpdateOpenInterest>(NULL);
  }

  MarketDataUpdateOpenInterest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateOpenInterest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateOpenInterest& from);
  void MergeFrom(const MarketDataUpdateOpenInterest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateOpenInterest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 OpenInterest = 2;
  bool has_openinterest() const;
  void clear_openinterest();
  static const int kOpenInterestFieldNumber = 2;
  ::google::protobuf::uint32 openinterest() const;
  void set_openinterest(::google::protobuf::uint32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateOpenInterest)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_openinterest();
  void clear_has_openinterest();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 openinterest_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionHigh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionHigh) */ {
 public:
  MarketDataUpdateSessionHigh();
  virtual ~MarketDataUpdateSessionHigh();

  MarketDataUpdateSessionHigh(const MarketDataUpdateSessionHigh& from);

  inline MarketDataUpdateSessionHigh& operator=(const MarketDataUpdateSessionHigh& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionHigh(MarketDataUpdateSessionHigh&& from) noexcept
    : MarketDataUpdateSessionHigh() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionHigh& operator=(MarketDataUpdateSessionHigh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionHigh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionHigh* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionHigh*>(
               &_MarketDataUpdateSessionHigh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(MarketDataUpdateSessionHigh* other);
  friend void swap(MarketDataUpdateSessionHigh& a, MarketDataUpdateSessionHigh& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionHigh* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionHigh>(NULL);
  }

  MarketDataUpdateSessionHigh* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionHigh>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionHigh& from);
  void MergeFrom(const MarketDataUpdateSessionHigh& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionHigh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  double price() const;
  void set_price(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionHigh)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionHigh_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionHigh_Int) */ {
 public:
  MarketDataUpdateSessionHigh_Int();
  virtual ~MarketDataUpdateSessionHigh_Int();

  MarketDataUpdateSessionHigh_Int(const MarketDataUpdateSessionHigh_Int& from);

  inline MarketDataUpdateSessionHigh_Int& operator=(const MarketDataUpdateSessionHigh_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionHigh_Int(MarketDataUpdateSessionHigh_Int&& from) noexcept
    : MarketDataUpdateSessionHigh_Int() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionHigh_Int& operator=(MarketDataUpdateSessionHigh_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionHigh_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionHigh_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionHigh_Int*>(
               &_MarketDataUpdateSessionHigh_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(MarketDataUpdateSessionHigh_Int* other);
  friend void swap(MarketDataUpdateSessionHigh_Int& a, MarketDataUpdateSessionHigh_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionHigh_Int* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionHigh_Int>(NULL);
  }

  MarketDataUpdateSessionHigh_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionHigh_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionHigh_Int& from);
  void MergeFrom(const MarketDataUpdateSessionHigh_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionHigh_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionHigh_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionLow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionLow) */ {
 public:
  MarketDataUpdateSessionLow();
  virtual ~MarketDataUpdateSessionLow();

  MarketDataUpdateSessionLow(const MarketDataUpdateSessionLow& from);

  inline MarketDataUpdateSessionLow& operator=(const MarketDataUpdateSessionLow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionLow(MarketDataUpdateSessionLow&& from) noexcept
    : MarketDataUpdateSessionLow() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionLow& operator=(MarketDataUpdateSessionLow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionLow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionLow* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionLow*>(
               &_MarketDataUpdateSessionLow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(MarketDataUpdateSessionLow* other);
  friend void swap(MarketDataUpdateSessionLow& a, MarketDataUpdateSessionLow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionLow* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionLow>(NULL);
  }

  MarketDataUpdateSessionLow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionLow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionLow& from);
  void MergeFrom(const MarketDataUpdateSessionLow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionLow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  double price() const;
  void set_price(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionLow)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionLow_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateSessionLow_Int) */ {
 public:
  MarketDataUpdateSessionLow_Int();
  virtual ~MarketDataUpdateSessionLow_Int();

  MarketDataUpdateSessionLow_Int(const MarketDataUpdateSessionLow_Int& from);

  inline MarketDataUpdateSessionLow_Int& operator=(const MarketDataUpdateSessionLow_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateSessionLow_Int(MarketDataUpdateSessionLow_Int&& from) noexcept
    : MarketDataUpdateSessionLow_Int() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateSessionLow_Int& operator=(MarketDataUpdateSessionLow_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionLow_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateSessionLow_Int* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateSessionLow_Int*>(
               &_MarketDataUpdateSessionLow_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(MarketDataUpdateSessionLow_Int* other);
  friend void swap(MarketDataUpdateSessionLow_Int& a, MarketDataUpdateSessionLow_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateSessionLow_Int* New() const final {
    return CreateMaybeMessage<MarketDataUpdateSessionLow_Int>(NULL);
  }

  MarketDataUpdateSessionLow_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateSessionLow_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateSessionLow_Int& from);
  void MergeFrom(const MarketDataUpdateSessionLow_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateSessionLow_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional uint32 TradingSessionDate = 3;
  bool has_tradingsessiondate() const;
  void clear_tradingsessiondate();
  static const int kTradingSessionDateFieldNumber = 3;
  ::google::protobuf::uint32 tradingsessiondate() const;
  void set_tradingsessiondate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionLow_Int)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_price();
  void clear_has_price();
  void set_has_tradingsessiondate();
  void clear_has_tradingsessiondate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::uint32 tradingsessiondate_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketDataUpdateLastTradeSnapshot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.MarketDataUpdateLastTradeSnapshot) */ {
 public:
  MarketDataUpdateLastTradeSnapshot();
  virtual ~MarketDataUpdateLastTradeSnapshot();

  MarketDataUpdateLastTradeSnapshot(const MarketDataUpdateLastTradeSnapshot& from);

  inline MarketDataUpdateLastTradeSnapshot& operator=(const MarketDataUpdateLastTradeSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketDataUpdateLastTradeSnapshot(MarketDataUpdateLastTradeSnapshot&& from) noexcept
    : MarketDataUpdateLastTradeSnapshot() {
    *this = ::std::move(from);
  }

  inline MarketDataUpdateLastTradeSnapshot& operator=(MarketDataUpdateLastTradeSnapshot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateLastTradeSnapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketDataUpdateLastTradeSnapshot* internal_default_instance() {
    return reinterpret_cast<const MarketDataUpdateLastTradeSnapshot*>(
               &_MarketDataUpdateLastTradeSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(MarketDataUpdateLastTradeSnapshot* other);
  friend void swap(MarketDataUpdateLastTradeSnapshot& a, MarketDataUpdateLastTradeSnapshot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketDataUpdateLastTradeSnapshot* New() const final {
    return CreateMaybeMessage<MarketDataUpdateLastTradeSnapshot>(NULL);
  }

  MarketDataUpdateLastTradeSnapshot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketDataUpdateLastTradeSnapshot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketDataUpdateLastTradeSnapshot& from);
  void MergeFrom(const MarketDataUpdateLastTradeSnapshot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDataUpdateLastTradeSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double LastTradePrice = 2;
  bool has_lasttradeprice() const;
  void clear_lasttradeprice();
  static const int kLastTradePriceFieldNumber = 2;
  double lasttradeprice() const;
  void set_lasttradeprice(double value);

  // optional double LastTradeVolume = 3;
  bool has_lasttradevolume() const;
  void clear_lasttradevolume();
  static const int kLastTradeVolumeFieldNumber = 3;
  double lasttradevolume() const;
  void set_lasttradevolume(double value);

  // optional double LastTradeDateTime = 4;
  bool has_lasttradedatetime() const;
  void clear_lasttradedatetime();
  static const int kLastTradeDateTimeFieldNumber = 4;
  double lasttradedatetime() const;
  void set_lasttradedatetime(double value);

  // optional uint32 SymbolID = 1;
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  ::google::protobuf::uint32 symbolid() const;
  void set_symbolid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateLastTradeSnapshot)
 private:
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_lasttradeprice();
  void clear_has_lasttradeprice();
  void set_has_lasttradevolume();
  void clear_has_lasttradevolume();
  void set_has_lasttradedatetime();
  void clear_has_lasttradedatetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double lasttradeprice_;
  double lasttradevolume_;
  double lasttradedatetime_;
  ::google::protobuf::uint32 symbolid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubmitNewSingleOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SubmitNewSingleOrder) */ {
 public:
  SubmitNewSingleOrder();
  virtual ~SubmitNewSingleOrder();

  SubmitNewSingleOrder(const SubmitNewSingleOrder& from);

  inline SubmitNewSingleOrder& operator=(const SubmitNewSingleOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubmitNewSingleOrder(SubmitNewSingleOrder&& from) noexcept
    : SubmitNewSingleOrder() {
    *this = ::std::move(from);
  }

  inline SubmitNewSingleOrder& operator=(SubmitNewSingleOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewSingleOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitNewSingleOrder* internal_default_instance() {
    return reinterpret_cast<const SubmitNewSingleOrder*>(
               &_SubmitNewSingleOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(SubmitNewSingleOrder* other);
  friend void swap(SubmitNewSingleOrder& a, SubmitNewSingleOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubmitNewSingleOrder* New() const final {
    return CreateMaybeMessage<SubmitNewSingleOrder>(NULL);
  }

  SubmitNewSingleOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubmitNewSingleOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubmitNewSingleOrder& from);
  void MergeFrom(const SubmitNewSingleOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitNewSingleOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string TradeAccount = 3;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 3;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string ClientOrderID = 4;
  bool has_clientorderid() const;
  void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 4;
  const ::std::string& clientorderid() const;
  void set_clientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid(::std::string&& value);
  #endif
  void set_clientorderid(const char* value);
  void set_clientorderid(const char* value, size_t size);
  ::std::string* mutable_clientorderid();
  ::std::string* release_clientorderid();
  void set_allocated_clientorderid(::std::string* clientorderid);

  // optional string FreeFormText = 14;
  bool has_freeformtext() const;
  void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 14;
  const ::std::string& freeformtext() const;
  void set_freeformtext(const ::std::string& value);
  #if LANG_CXX11
  void set_freeformtext(::std::string&& value);
  #endif
  void set_freeformtext(const char* value);
  void set_freeformtext(const char* value, size_t size);
  ::std::string* mutable_freeformtext();
  ::std::string* release_freeformtext();
  void set_allocated_freeformtext(::std::string* freeformtext);

  // optional .DTC_PB.OrderTypeEnum OrderType = 5;
  bool has_ordertype() const;
  void clear_ordertype();
  static const int kOrderTypeFieldNumber = 5;
  ::DTC_PB::OrderTypeEnum ordertype() const;
  void set_ordertype(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell = 6;
  bool has_buysell() const;
  void clear_buysell();
  static const int kBuySellFieldNumber = 6;
  ::DTC_PB::BuySellEnum buysell() const;
  void set_buysell(::DTC_PB::BuySellEnum value);

  // optional double Price1 = 7;
  bool has_price1() const;
  void clear_price1();
  static const int kPrice1FieldNumber = 7;
  double price1() const;
  void set_price1(double value);

  // optional double Price2 = 8;
  bool has_price2() const;
  void clear_price2();
  static const int kPrice2FieldNumber = 8;
  double price2() const;
  void set_price2(double value);

  // optional double Quantity = 9;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 9;
  double quantity() const;
  void set_quantity(double value);

  // optional sfixed64 GoodTillDateTime = 11;
  bool has_goodtilldatetime() const;
  void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 11;
  ::google::protobuf::int64 goodtilldatetime() const;
  void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 10;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 10;
  ::DTC_PB::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional uint32 IsAutomatedOrder = 12;
  bool has_isautomatedorder() const;
  void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 12;
  ::google::protobuf::uint32 isautomatedorder() const;
  void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional uint32 IsParentOrder = 13;
  bool has_isparentorder() const;
  void clear_isparentorder();
  static const int kIsParentOrderFieldNumber = 13;
  ::google::protobuf::uint32 isparentorder() const;
  void set_isparentorder(::google::protobuf::uint32 value);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 15;
  bool has_openorclose() const;
  void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 15;
  ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewSingleOrder)
 private:
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_clientorderid();
  void clear_has_clientorderid();
  void set_has_ordertype();
  void clear_has_ordertype();
  void set_has_buysell();
  void clear_has_buysell();
  void set_has_price1();
  void clear_has_price1();
  void set_has_price2();
  void clear_has_price2();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_timeinforce();
  void clear_has_timeinforce();
  void set_has_goodtilldatetime();
  void clear_has_goodtilldatetime();
  void set_has_isautomatedorder();
  void clear_has_isautomatedorder();
  void set_has_isparentorder();
  void clear_has_isparentorder();
  void set_has_freeformtext();
  void clear_has_freeformtext();
  void set_has_openorclose();
  void clear_has_openorclose();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_;
  ::google::protobuf::internal::ArenaStringPtr freeformtext_;
  int ordertype_;
  int buysell_;
  double price1_;
  double price2_;
  double quantity_;
  ::google::protobuf::int64 goodtilldatetime_;
  int timeinforce_;
  ::google::protobuf::uint32 isautomatedorder_;
  ::google::protobuf::uint32 isparentorder_;
  int openorclose_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubmitNewSingleOrderInt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SubmitNewSingleOrderInt) */ {
 public:
  SubmitNewSingleOrderInt();
  virtual ~SubmitNewSingleOrderInt();

  SubmitNewSingleOrderInt(const SubmitNewSingleOrderInt& from);

  inline SubmitNewSingleOrderInt& operator=(const SubmitNewSingleOrderInt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubmitNewSingleOrderInt(SubmitNewSingleOrderInt&& from) noexcept
    : SubmitNewSingleOrderInt() {
    *this = ::std::move(from);
  }

  inline SubmitNewSingleOrderInt& operator=(SubmitNewSingleOrderInt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewSingleOrderInt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitNewSingleOrderInt* internal_default_instance() {
    return reinterpret_cast<const SubmitNewSingleOrderInt*>(
               &_SubmitNewSingleOrderInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(SubmitNewSingleOrderInt* other);
  friend void swap(SubmitNewSingleOrderInt& a, SubmitNewSingleOrderInt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubmitNewSingleOrderInt* New() const final {
    return CreateMaybeMessage<SubmitNewSingleOrderInt>(NULL);
  }

  SubmitNewSingleOrderInt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubmitNewSingleOrderInt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubmitNewSingleOrderInt& from);
  void MergeFrom(const SubmitNewSingleOrderInt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitNewSingleOrderInt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string TradeAccount = 3;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 3;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string ClientOrderID = 4;
  bool has_clientorderid() const;
  void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 4;
  const ::std::string& clientorderid() const;
  void set_clientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid(::std::string&& value);
  #endif
  void set_clientorderid(const char* value);
  void set_clientorderid(const char* value, size_t size);
  ::std::string* mutable_clientorderid();
  ::std::string* release_clientorderid();
  void set_allocated_clientorderid(::std::string* clientorderid);

  // optional string FreeFormText = 15;
  bool has_freeformtext() const;
  void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 15;
  const ::std::string& freeformtext() const;
  void set_freeformtext(const ::std::string& value);
  #if LANG_CXX11
  void set_freeformtext(::std::string&& value);
  #endif
  void set_freeformtext(const char* value);
  void set_freeformtext(const char* value, size_t size);
  ::std::string* mutable_freeformtext();
  ::std::string* release_freeformtext();
  void set_allocated_freeformtext(::std::string* freeformtext);

  // optional .DTC_PB.OrderTypeEnum OrderType = 5;
  bool has_ordertype() const;
  void clear_ordertype();
  static const int kOrderTypeFieldNumber = 5;
  ::DTC_PB::OrderTypeEnum ordertype() const;
  void set_ordertype(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell = 6;
  bool has_buysell() const;
  void clear_buysell();
  static const int kBuySellFieldNumber = 6;
  ::DTC_PB::BuySellEnum buysell() const;
  void set_buysell(::DTC_PB::BuySellEnum value);

  // optional int64 Price1 = 7;
  bool has_price1() const;
  void clear_price1();
  static const int kPrice1FieldNumber = 7;
  ::google::protobuf::int64 price1() const;
  void set_price1(::google::protobuf::int64 value);

  // optional int64 Price2 = 8;
  bool has_price2() const;
  void clear_price2();
  static const int kPrice2FieldNumber = 8;
  ::google::protobuf::int64 price2() const;
  void set_price2(::google::protobuf::int64 value);

  // optional int64 Quantity = 10;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 10;
  ::google::protobuf::int64 quantity() const;
  void set_quantity(::google::protobuf::int64 value);

  // optional float Divisor = 9;
  bool has_divisor() const;
  void clear_divisor();
  static const int kDivisorFieldNumber = 9;
  float divisor() const;
  void set_divisor(float value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 11;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 11;
  ::DTC_PB::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional sfixed64 GoodTillDateTime = 12;
  bool has_goodtilldatetime() const;
  void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 12;
  ::google::protobuf::int64 goodtilldatetime() const;
  void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional uint32 IsAutomatedOrder = 13;
  bool has_isautomatedorder() const;
  void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 13;
  ::google::protobuf::uint32 isautomatedorder() const;
  void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional uint32 IsParentOrder = 14;
  bool has_isparentorder() const;
  void clear_isparentorder();
  static const int kIsParentOrderFieldNumber = 14;
  ::google::protobuf::uint32 isparentorder() const;
  void set_isparentorder(::google::protobuf::uint32 value);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 16;
  bool has_openorclose() const;
  void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 16;
  ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewSingleOrderInt)
 private:
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_clientorderid();
  void clear_has_clientorderid();
  void set_has_ordertype();
  void clear_has_ordertype();
  void set_has_buysell();
  void clear_has_buysell();
  void set_has_price1();
  void clear_has_price1();
  void set_has_price2();
  void clear_has_price2();
  void set_has_divisor();
  void clear_has_divisor();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_timeinforce();
  void clear_has_timeinforce();
  void set_has_goodtilldatetime();
  void clear_has_goodtilldatetime();
  void set_has_isautomatedorder();
  void clear_has_isautomatedorder();
  void set_has_isparentorder();
  void clear_has_isparentorder();
  void set_has_freeformtext();
  void clear_has_freeformtext();
  void set_has_openorclose();
  void clear_has_openorclose();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_;
  ::google::protobuf::internal::ArenaStringPtr freeformtext_;
  int ordertype_;
  int buysell_;
  ::google::protobuf::int64 price1_;
  ::google::protobuf::int64 price2_;
  ::google::protobuf::int64 quantity_;
  float divisor_;
  int timeinforce_;
  ::google::protobuf::int64 goodtilldatetime_;
  ::google::protobuf::uint32 isautomatedorder_;
  ::google::protobuf::uint32 isparentorder_;
  int openorclose_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelReplaceOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.CancelReplaceOrder) */ {
 public:
  CancelReplaceOrder();
  virtual ~CancelReplaceOrder();

  CancelReplaceOrder(const CancelReplaceOrder& from);

  inline CancelReplaceOrder& operator=(const CancelReplaceOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CancelReplaceOrder(CancelReplaceOrder&& from) noexcept
    : CancelReplaceOrder() {
    *this = ::std::move(from);
  }

  inline CancelReplaceOrder& operator=(CancelReplaceOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelReplaceOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelReplaceOrder* internal_default_instance() {
    return reinterpret_cast<const CancelReplaceOrder*>(
               &_CancelReplaceOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(CancelReplaceOrder* other);
  friend void swap(CancelReplaceOrder& a, CancelReplaceOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelReplaceOrder* New() const final {
    return CreateMaybeMessage<CancelReplaceOrder>(NULL);
  }

  CancelReplaceOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CancelReplaceOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CancelReplaceOrder& from);
  void MergeFrom(const CancelReplaceOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelReplaceOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 1;
  bool has_serverorderid() const;
  void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 1;
  const ::std::string& serverorderid() const;
  void set_serverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverorderid(::std::string&& value);
  #endif
  void set_serverorderid(const char* value);
  void set_serverorderid(const char* value, size_t size);
  ::std::string* mutable_serverorderid();
  ::std::string* release_serverorderid();
  void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 2;
  bool has_clientorderid() const;
  void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 2;
  const ::std::string& clientorderid() const;
  void set_clientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid(::std::string&& value);
  #endif
  void set_clientorderid(const char* value);
  void set_clientorderid(const char* value, size_t size);
  ::std::string* mutable_clientorderid();
  ::std::string* release_clientorderid();
  void set_allocated_clientorderid(::std::string* clientorderid);

  // optional double Price1 = 3;
  bool has_price1() const;
  void clear_price1();
  static const int kPrice1FieldNumber = 3;
  double price1() const;
  void set_price1(double value);

  // optional double Price2 = 4;
  bool has_price2() const;
  void clear_price2();
  static const int kPrice2FieldNumber = 4;
  double price2() const;
  void set_price2(double value);

  // optional double Quantity = 5;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 5;
  double quantity() const;
  void set_quantity(double value);

  // optional uint32 Price1IsSet = 6;
  bool has_price1isset() const;
  void clear_price1isset();
  static const int kPrice1IsSetFieldNumber = 6;
  ::google::protobuf::uint32 price1isset() const;
  void set_price1isset(::google::protobuf::uint32 value);

  // optional uint32 Price2IsSet = 7;
  bool has_price2isset() const;
  void clear_price2isset();
  static const int kPrice2IsSetFieldNumber = 7;
  ::google::protobuf::uint32 price2isset() const;
  void set_price2isset(::google::protobuf::uint32 value);

  // optional uint64 GoodTillDateTime = 10;
  bool has_goodtilldatetime() const;
  void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 10;
  ::google::protobuf::uint64 goodtilldatetime() const;
  void set_goodtilldatetime(::google::protobuf::uint64 value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 9;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 9;
  ::DTC_PB::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional uint32 UpdatePrice1OffsetToParent = 11;
  bool has_updateprice1offsettoparent() const;
  void clear_updateprice1offsettoparent();
  static const int kUpdatePrice1OffsetToParentFieldNumber = 11;
  ::google::protobuf::uint32 updateprice1offsettoparent() const;
  void set_updateprice1offsettoparent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.CancelReplaceOrder)
 private:
  void set_has_serverorderid();
  void clear_has_serverorderid();
  void set_has_clientorderid();
  void clear_has_clientorderid();
  void set_has_price1();
  void clear_has_price1();
  void set_has_price2();
  void clear_has_price2();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_price1isset();
  void clear_has_price1isset();
  void set_has_price2isset();
  void clear_has_price2isset();
  void set_has_timeinforce();
  void clear_has_timeinforce();
  void set_has_goodtilldatetime();
  void clear_has_goodtilldatetime();
  void set_has_updateprice1offsettoparent();
  void clear_has_updateprice1offsettoparent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverorderid_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_;
  double price1_;
  double price2_;
  double quantity_;
  ::google::protobuf::uint32 price1isset_;
  ::google::protobuf::uint32 price2isset_;
  ::google::protobuf::uint64 goodtilldatetime_;
  int timeinforce_;
  ::google::protobuf::uint32 updateprice1offsettoparent_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelReplaceOrderInt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.CancelReplaceOrderInt) */ {
 public:
  CancelReplaceOrderInt();
  virtual ~CancelReplaceOrderInt();

  CancelReplaceOrderInt(const CancelReplaceOrderInt& from);

  inline CancelReplaceOrderInt& operator=(const CancelReplaceOrderInt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CancelReplaceOrderInt(CancelReplaceOrderInt&& from) noexcept
    : CancelReplaceOrderInt() {
    *this = ::std::move(from);
  }

  inline CancelReplaceOrderInt& operator=(CancelReplaceOrderInt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelReplaceOrderInt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelReplaceOrderInt* internal_default_instance() {
    return reinterpret_cast<const CancelReplaceOrderInt*>(
               &_CancelReplaceOrderInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(CancelReplaceOrderInt* other);
  friend void swap(CancelReplaceOrderInt& a, CancelReplaceOrderInt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelReplaceOrderInt* New() const final {
    return CreateMaybeMessage<CancelReplaceOrderInt>(NULL);
  }

  CancelReplaceOrderInt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CancelReplaceOrderInt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CancelReplaceOrderInt& from);
  void MergeFrom(const CancelReplaceOrderInt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelReplaceOrderInt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 1;
  bool has_serverorderid() const;
  void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 1;
  const ::std::string& serverorderid() const;
  void set_serverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverorderid(::std::string&& value);
  #endif
  void set_serverorderid(const char* value);
  void set_serverorderid(const char* value, size_t size);
  ::std::string* mutable_serverorderid();
  ::std::string* release_serverorderid();
  void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 2;
  bool has_clientorderid() const;
  void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 2;
  const ::std::string& clientorderid() const;
  void set_clientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid(::std::string&& value);
  #endif
  void set_clientorderid(const char* value);
  void set_clientorderid(const char* value, size_t size);
  ::std::string* mutable_clientorderid();
  ::std::string* release_clientorderid();
  void set_allocated_clientorderid(::std::string* clientorderid);

  // optional int64 Price1 = 3;
  bool has_price1() const;
  void clear_price1();
  static const int kPrice1FieldNumber = 3;
  ::google::protobuf::int64 price1() const;
  void set_price1(::google::protobuf::int64 value);

  // optional int64 Price2 = 4;
  bool has_price2() const;
  void clear_price2();
  static const int kPrice2FieldNumber = 4;
  ::google::protobuf::int64 price2() const;
  void set_price2(::google::protobuf::int64 value);

  // optional int64 Quantity = 6;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  ::google::protobuf::int64 quantity() const;
  void set_quantity(::google::protobuf::int64 value);

  // optional float Divisor = 5;
  bool has_divisor() const;
  void clear_divisor();
  static const int kDivisorFieldNumber = 5;
  float divisor() const;
  void set_divisor(float value);

  // optional uint32 Price1IsSet = 7;
  bool has_price1isset() const;
  void clear_price1isset();
  static const int kPrice1IsSetFieldNumber = 7;
  ::google::protobuf::uint32 price1isset() const;
  void set_price1isset(::google::protobuf::uint32 value);

  // optional uint32 Price2IsSet = 8;
  bool has_price2isset() const;
  void clear_price2isset();
  static const int kPrice2IsSetFieldNumber = 8;
  ::google::protobuf::uint32 price2isset() const;
  void set_price2isset(::google::protobuf::uint32 value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 10;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 10;
  ::DTC_PB::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional uint64 GoodTillDateTime = 11;
  bool has_goodtilldatetime() const;
  void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 11;
  ::google::protobuf::uint64 goodtilldatetime() const;
  void set_goodtilldatetime(::google::protobuf::uint64 value);

  // optional uint32 UpdatePrice1OffsetToParent = 12;
  bool has_updateprice1offsettoparent() const;
  void clear_updateprice1offsettoparent();
  static const int kUpdatePrice1OffsetToParentFieldNumber = 12;
  ::google::protobuf::uint32 updateprice1offsettoparent() const;
  void set_updateprice1offsettoparent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.CancelReplaceOrderInt)
 private:
  void set_has_serverorderid();
  void clear_has_serverorderid();
  void set_has_clientorderid();
  void clear_has_clientorderid();
  void set_has_price1();
  void clear_has_price1();
  void set_has_price2();
  void clear_has_price2();
  void set_has_divisor();
  void clear_has_divisor();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_price1isset();
  void clear_has_price1isset();
  void set_has_price2isset();
  void clear_has_price2isset();
  void set_has_timeinforce();
  void clear_has_timeinforce();
  void set_has_goodtilldatetime();
  void clear_has_goodtilldatetime();
  void set_has_updateprice1offsettoparent();
  void clear_has_updateprice1offsettoparent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverorderid_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_;
  ::google::protobuf::int64 price1_;
  ::google::protobuf::int64 price2_;
  ::google::protobuf::int64 quantity_;
  float divisor_;
  ::google::protobuf::uint32 price1isset_;
  ::google::protobuf::uint32 price2isset_;
  int timeinforce_;
  ::google::protobuf::uint64 goodtilldatetime_;
  ::google::protobuf::uint32 updateprice1offsettoparent_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.CancelOrder) */ {
 public:
  CancelOrder();
  virtual ~CancelOrder();

  CancelOrder(const CancelOrder& from);

  inline CancelOrder& operator=(const CancelOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CancelOrder(CancelOrder&& from) noexcept
    : CancelOrder() {
    *this = ::std::move(from);
  }

  inline CancelOrder& operator=(CancelOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelOrder* internal_default_instance() {
    return reinterpret_cast<const CancelOrder*>(
               &_CancelOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(CancelOrder* other);
  friend void swap(CancelOrder& a, CancelOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelOrder* New() const final {
    return CreateMaybeMessage<CancelOrder>(NULL);
  }

  CancelOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CancelOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CancelOrder& from);
  void MergeFrom(const CancelOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 1;
  bool has_serverorderid() const;
  void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 1;
  const ::std::string& serverorderid() const;
  void set_serverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverorderid(::std::string&& value);
  #endif
  void set_serverorderid(const char* value);
  void set_serverorderid(const char* value, size_t size);
  ::std::string* mutable_serverorderid();
  ::std::string* release_serverorderid();
  void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 2;
  bool has_clientorderid() const;
  void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 2;
  const ::std::string& clientorderid() const;
  void set_clientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid(::std::string&& value);
  #endif
  void set_clientorderid(const char* value);
  void set_clientorderid(const char* value, size_t size);
  ::std::string* mutable_clientorderid();
  ::std::string* release_clientorderid();
  void set_allocated_clientorderid(::std::string* clientorderid);

  // @@protoc_insertion_point(class_scope:DTC_PB.CancelOrder)
 private:
  void set_has_serverorderid();
  void clear_has_serverorderid();
  void set_has_clientorderid();
  void clear_has_clientorderid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverorderid_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubmitNewOCOOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SubmitNewOCOOrder) */ {
 public:
  SubmitNewOCOOrder();
  virtual ~SubmitNewOCOOrder();

  SubmitNewOCOOrder(const SubmitNewOCOOrder& from);

  inline SubmitNewOCOOrder& operator=(const SubmitNewOCOOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubmitNewOCOOrder(SubmitNewOCOOrder&& from) noexcept
    : SubmitNewOCOOrder() {
    *this = ::std::move(from);
  }

  inline SubmitNewOCOOrder& operator=(SubmitNewOCOOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewOCOOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitNewOCOOrder* internal_default_instance() {
    return reinterpret_cast<const SubmitNewOCOOrder*>(
               &_SubmitNewOCOOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(SubmitNewOCOOrder* other);
  friend void swap(SubmitNewOCOOrder& a, SubmitNewOCOOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubmitNewOCOOrder* New() const final {
    return CreateMaybeMessage<SubmitNewOCOOrder>(NULL);
  }

  SubmitNewOCOOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubmitNewOCOOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubmitNewOCOOrder& from);
  void MergeFrom(const SubmitNewOCOOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitNewOCOOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string ClientOrderID_1 = 3;
  bool has_clientorderid_1() const;
  void clear_clientorderid_1();
  static const int kClientOrderID1FieldNumber = 3;
  const ::std::string& clientorderid_1() const;
  void set_clientorderid_1(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid_1(::std::string&& value);
  #endif
  void set_clientorderid_1(const char* value);
  void set_clientorderid_1(const char* value, size_t size);
  ::std::string* mutable_clientorderid_1();
  ::std::string* release_clientorderid_1();
  void set_allocated_clientorderid_1(::std::string* clientorderid_1);

  // optional string ClientOrderID_2 = 9;
  bool has_clientorderid_2() const;
  void clear_clientorderid_2();
  static const int kClientOrderID2FieldNumber = 9;
  const ::std::string& clientorderid_2() const;
  void set_clientorderid_2(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid_2(::std::string&& value);
  #endif
  void set_clientorderid_2(const char* value);
  void set_clientorderid_2(const char* value, size_t size);
  ::std::string* mutable_clientorderid_2();
  ::std::string* release_clientorderid_2();
  void set_allocated_clientorderid_2(::std::string* clientorderid_2);

  // optional string TradeAccount = 17;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 17;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string ParentTriggerClientOrderID = 19;
  bool has_parenttriggerclientorderid() const;
  void clear_parenttriggerclientorderid();
  static const int kParentTriggerClientOrderIDFieldNumber = 19;
  const ::std::string& parenttriggerclientorderid() const;
  void set_parenttriggerclientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_parenttriggerclientorderid(::std::string&& value);
  #endif
  void set_parenttriggerclientorderid(const char* value);
  void set_parenttriggerclientorderid(const char* value, size_t size);
  ::std::string* mutable_parenttriggerclientorderid();
  ::std::string* release_parenttriggerclientorderid();
  void set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid);

  // optional string FreeFormText = 20;
  bool has_freeformtext() const;
  void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 20;
  const ::std::string& freeformtext() const;
  void set_freeformtext(const ::std::string& value);
  #if LANG_CXX11
  void set_freeformtext(::std::string&& value);
  #endif
  void set_freeformtext(const char* value);
  void set_freeformtext(const char* value, size_t size);
  ::std::string* mutable_freeformtext();
  ::std::string* release_freeformtext();
  void set_allocated_freeformtext(::std::string* freeformtext);

  // optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
  bool has_ordertype_1() const;
  void clear_ordertype_1();
  static const int kOrderType1FieldNumber = 4;
  ::DTC_PB::OrderTypeEnum ordertype_1() const;
  void set_ordertype_1(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_1 = 5;
  bool has_buysell_1() const;
  void clear_buysell_1();
  static const int kBuySell1FieldNumber = 5;
  ::DTC_PB::BuySellEnum buysell_1() const;
  void set_buysell_1(::DTC_PB::BuySellEnum value);

  // optional double Price1_1 = 6;
  bool has_price1_1() const;
  void clear_price1_1();
  static const int kPrice11FieldNumber = 6;
  double price1_1() const;
  void set_price1_1(double value);

  // optional double Price2_1 = 7;
  bool has_price2_1() const;
  void clear_price2_1();
  static const int kPrice21FieldNumber = 7;
  double price2_1() const;
  void set_price2_1(double value);

  // optional double Quantity_1 = 8;
  bool has_quantity_1() const;
  void clear_quantity_1();
  static const int kQuantity1FieldNumber = 8;
  double quantity_1() const;
  void set_quantity_1(double value);

  // optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
  bool has_ordertype_2() const;
  void clear_ordertype_2();
  static const int kOrderType2FieldNumber = 10;
  ::DTC_PB::OrderTypeEnum ordertype_2() const;
  void set_ordertype_2(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_2 = 11;
  bool has_buysell_2() const;
  void clear_buysell_2();
  static const int kBuySell2FieldNumber = 11;
  ::DTC_PB::BuySellEnum buysell_2() const;
  void set_buysell_2(::DTC_PB::BuySellEnum value);

  // optional double Price1_2 = 12;
  bool has_price1_2() const;
  void clear_price1_2();
  static const int kPrice12FieldNumber = 12;
  double price1_2() const;
  void set_price1_2(double value);

  // optional double Price2_2 = 13;
  bool has_price2_2() const;
  void clear_price2_2();
  static const int kPrice22FieldNumber = 13;
  double price2_2() const;
  void set_price2_2(double value);

  // optional double Quantity_2 = 14;
  bool has_quantity_2() const;
  void clear_quantity_2();
  static const int kQuantity2FieldNumber = 14;
  double quantity_2() const;
  void set_quantity_2(double value);

  // optional sfixed64 GoodTillDateTime = 16;
  bool has_goodtilldatetime() const;
  void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 16;
  ::google::protobuf::int64 goodtilldatetime() const;
  void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 15;
  ::DTC_PB::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional uint32 IsAutomatedOrder = 18;
  bool has_isautomatedorder() const;
  void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 18;
  ::google::protobuf::uint32 isautomatedorder() const;
  void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 21;
  bool has_openorclose() const;
  void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 21;
  ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // optional .DTC_PB.PartialFillHandlingEnum PartialFillHandling = 22;
  bool has_partialfillhandling() const;
  void clear_partialfillhandling();
  static const int kPartialFillHandlingFieldNumber = 22;
  ::DTC_PB::PartialFillHandlingEnum partialfillhandling() const;
  void set_partialfillhandling(::DTC_PB::PartialFillHandlingEnum value);

  // optional double OffsetFromParent1 = 24;
  bool has_offsetfromparent1() const;
  void clear_offsetfromparent1();
  static const int kOffsetFromParent1FieldNumber = 24;
  double offsetfromparent1() const;
  void set_offsetfromparent1(double value);

  // optional double OffsetFromParent2 = 25;
  bool has_offsetfromparent2() const;
  void clear_offsetfromparent2();
  static const int kOffsetFromParent2FieldNumber = 25;
  double offsetfromparent2() const;
  void set_offsetfromparent2(double value);

  // optional uint32 UseOffsets = 23;
  bool has_useoffsets() const;
  void clear_useoffsets();
  static const int kUseOffsetsFieldNumber = 23;
  ::google::protobuf::uint32 useoffsets() const;
  void set_useoffsets(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewOCOOrder)
 private:
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_clientorderid_1();
  void clear_has_clientorderid_1();
  void set_has_ordertype_1();
  void clear_has_ordertype_1();
  void set_has_buysell_1();
  void clear_has_buysell_1();
  void set_has_price1_1();
  void clear_has_price1_1();
  void set_has_price2_1();
  void clear_has_price2_1();
  void set_has_quantity_1();
  void clear_has_quantity_1();
  void set_has_clientorderid_2();
  void clear_has_clientorderid_2();
  void set_has_ordertype_2();
  void clear_has_ordertype_2();
  void set_has_buysell_2();
  void clear_has_buysell_2();
  void set_has_price1_2();
  void clear_has_price1_2();
  void set_has_price2_2();
  void clear_has_price2_2();
  void set_has_quantity_2();
  void clear_has_quantity_2();
  void set_has_timeinforce();
  void clear_has_timeinforce();
  void set_has_goodtilldatetime();
  void clear_has_goodtilldatetime();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_isautomatedorder();
  void clear_has_isautomatedorder();
  void set_has_parenttriggerclientorderid();
  void clear_has_parenttriggerclientorderid();
  void set_has_freeformtext();
  void clear_has_freeformtext();
  void set_has_openorclose();
  void clear_has_openorclose();
  void set_has_partialfillhandling();
  void clear_has_partialfillhandling();
  void set_has_useoffsets();
  void clear_has_useoffsets();
  void set_has_offsetfromparent1();
  void clear_has_offsetfromparent1();
  void set_has_offsetfromparent2();
  void clear_has_offsetfromparent2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_1_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_2_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr parenttriggerclientorderid_;
  ::google::protobuf::internal::ArenaStringPtr freeformtext_;
  int ordertype_1_;
  int buysell_1_;
  double price1_1_;
  double price2_1_;
  double quantity_1_;
  int ordertype_2_;
  int buysell_2_;
  double price1_2_;
  double price2_2_;
  double quantity_2_;
  ::google::protobuf::int64 goodtilldatetime_;
  int timeinforce_;
  ::google::protobuf::uint32 isautomatedorder_;
  int openorclose_;
  int partialfillhandling_;
  double offsetfromparent1_;
  double offsetfromparent2_;
  ::google::protobuf::uint32 useoffsets_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubmitNewOCOOrderInt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SubmitNewOCOOrderInt) */ {
 public:
  SubmitNewOCOOrderInt();
  virtual ~SubmitNewOCOOrderInt();

  SubmitNewOCOOrderInt(const SubmitNewOCOOrderInt& from);

  inline SubmitNewOCOOrderInt& operator=(const SubmitNewOCOOrderInt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubmitNewOCOOrderInt(SubmitNewOCOOrderInt&& from) noexcept
    : SubmitNewOCOOrderInt() {
    *this = ::std::move(from);
  }

  inline SubmitNewOCOOrderInt& operator=(SubmitNewOCOOrderInt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewOCOOrderInt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitNewOCOOrderInt* internal_default_instance() {
    return reinterpret_cast<const SubmitNewOCOOrderInt*>(
               &_SubmitNewOCOOrderInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(SubmitNewOCOOrderInt* other);
  friend void swap(SubmitNewOCOOrderInt& a, SubmitNewOCOOrderInt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubmitNewOCOOrderInt* New() const final {
    return CreateMaybeMessage<SubmitNewOCOOrderInt>(NULL);
  }

  SubmitNewOCOOrderInt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubmitNewOCOOrderInt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubmitNewOCOOrderInt& from);
  void MergeFrom(const SubmitNewOCOOrderInt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitNewOCOOrderInt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string ClientOrderID_1 = 3;
  bool has_clientorderid_1() const;
  void clear_clientorderid_1();
  static const int kClientOrderID1FieldNumber = 3;
  const ::std::string& clientorderid_1() const;
  void set_clientorderid_1(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid_1(::std::string&& value);
  #endif
  void set_clientorderid_1(const char* value);
  void set_clientorderid_1(const char* value, size_t size);
  ::std::string* mutable_clientorderid_1();
  ::std::string* release_clientorderid_1();
  void set_allocated_clientorderid_1(::std::string* clientorderid_1);

  // optional string ClientOrderID_2 = 9;
  bool has_clientorderid_2() const;
  void clear_clientorderid_2();
  static const int kClientOrderID2FieldNumber = 9;
  const ::std::string& clientorderid_2() const;
  void set_clientorderid_2(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid_2(::std::string&& value);
  #endif
  void set_clientorderid_2(const char* value);
  void set_clientorderid_2(const char* value, size_t size);
  ::std::string* mutable_clientorderid_2();
  ::std::string* release_clientorderid_2();
  void set_allocated_clientorderid_2(::std::string* clientorderid_2);

  // optional string TradeAccount = 17;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 17;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string ParentTriggerClientOrderID = 19;
  bool has_parenttriggerclientorderid() const;
  void clear_parenttriggerclientorderid();
  static const int kParentTriggerClientOrderIDFieldNumber = 19;
  const ::std::string& parenttriggerclientorderid() const;
  void set_parenttriggerclientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_parenttriggerclientorderid(::std::string&& value);
  #endif
  void set_parenttriggerclientorderid(const char* value);
  void set_parenttriggerclientorderid(const char* value, size_t size);
  ::std::string* mutable_parenttriggerclientorderid();
  ::std::string* release_parenttriggerclientorderid();
  void set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid);

  // optional string FreeFormText = 20;
  bool has_freeformtext() const;
  void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 20;
  const ::std::string& freeformtext() const;
  void set_freeformtext(const ::std::string& value);
  #if LANG_CXX11
  void set_freeformtext(::std::string&& value);
  #endif
  void set_freeformtext(const char* value);
  void set_freeformtext(const char* value, size_t size);
  ::std::string* mutable_freeformtext();
  ::std::string* release_freeformtext();
  void set_allocated_freeformtext(::std::string* freeformtext);

  // optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
  bool has_ordertype_1() const;
  void clear_ordertype_1();
  static const int kOrderType1FieldNumber = 4;
  ::DTC_PB::OrderTypeEnum ordertype_1() const;
  void set_ordertype_1(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_1 = 5;
  bool has_buysell_1() const;
  void clear_buysell_1();
  static const int kBuySell1FieldNumber = 5;
  ::DTC_PB::BuySellEnum buysell_1() const;
  void set_buysell_1(::DTC_PB::BuySellEnum value);

  // optional int64 Price1_1 = 6;
  bool has_price1_1() const;
  void clear_price1_1();
  static const int kPrice11FieldNumber = 6;
  ::google::protobuf::int64 price1_1() const;
  void set_price1_1(::google::protobuf::int64 value);

  // optional int64 Price2_1 = 7;
  bool has_price2_1() const;
  void clear_price2_1();
  static const int kPrice21FieldNumber = 7;
  ::google::protobuf::int64 price2_1() const;
  void set_price2_1(::google::protobuf::int64 value);

  // optional int64 Quantity_1 = 8;
  bool has_quantity_1() const;
  void clear_quantity_1();
  static const int kQuantity1FieldNumber = 8;
  ::google::protobuf::int64 quantity_1() const;
  void set_quantity_1(::google::protobuf::int64 value);

  // optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
  bool has_ordertype_2() const;
  void clear_ordertype_2();
  static const int kOrderType2FieldNumber = 10;
  ::DTC_PB::OrderTypeEnum ordertype_2() const;
  void set_ordertype_2(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_2 = 11;
  bool has_buysell_2() const;
  void clear_buysell_2();
  static const int kBuySell2FieldNumber = 11;
  ::DTC_PB::BuySellEnum buysell_2() const;
  void set_buysell_2(::DTC_PB::BuySellEnum value);

  // optional int64 Price1_2 = 12;
  bool has_price1_2() const;
  void clear_price1_2();
  static const int kPrice12FieldNumber = 12;
  ::google::protobuf::int64 price1_2() const;
  void set_price1_2(::google::protobuf::int64 value);

  // optional int64 Price2_2 = 13;
  bool has_price2_2() const;
  void clear_price2_2();
  static const int kPrice22FieldNumber = 13;
  ::google::protobuf::int64 price2_2() const;
  void set_price2_2(::google::protobuf::int64 value);

  // optional int64 Quantity_2 = 14;
  bool has_quantity_2() const;
  void clear_quantity_2();
  static const int kQuantity2FieldNumber = 14;
  ::google::protobuf::int64 quantity_2() const;
  void set_quantity_2(::google::protobuf::int64 value);

  // optional sfixed64 GoodTillDateTime = 16;
  bool has_goodtilldatetime() const;
  void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 16;
  ::google::protobuf::int64 goodtilldatetime() const;
  void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 15;
  ::DTC_PB::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional uint32 IsAutomatedOrder = 18;
  bool has_isautomatedorder() const;
  void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 18;
  ::google::protobuf::uint32 isautomatedorder() const;
  void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional float Divisor = 21;
  bool has_divisor() const;
  void clear_divisor();
  static const int kDivisorFieldNumber = 21;
  float divisor() const;
  void set_divisor(float value);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 22;
  bool has_openorclose() const;
  void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 22;
  ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // optional .DTC_PB.PartialFillHandlingEnum PartialFillHandling = 23;
  bool has_partialfillhandling() const;
  void clear_partialfillhandling();
  static const int kPartialFillHandlingFieldNumber = 23;
  ::DTC_PB::PartialFillHandlingEnum partialfillhandling() const;
  void set_partialfillhandling(::DTC_PB::PartialFillHandlingEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewOCOOrderInt)
 private:
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_clientorderid_1();
  void clear_has_clientorderid_1();
  void set_has_ordertype_1();
  void clear_has_ordertype_1();
  void set_has_buysell_1();
  void clear_has_buysell_1();
  void set_has_price1_1();
  void clear_has_price1_1();
  void set_has_price2_1();
  void clear_has_price2_1();
  void set_has_quantity_1();
  void clear_has_quantity_1();
  void set_has_clientorderid_2();
  void clear_has_clientorderid_2();
  void set_has_ordertype_2();
  void clear_has_ordertype_2();
  void set_has_buysell_2();
  void clear_has_buysell_2();
  void set_has_price1_2();
  void clear_has_price1_2();
  void set_has_price2_2();
  void clear_has_price2_2();
  void set_has_quantity_2();
  void clear_has_quantity_2();
  void set_has_timeinforce();
  void clear_has_timeinforce();
  void set_has_goodtilldatetime();
  void clear_has_goodtilldatetime();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_isautomatedorder();
  void clear_has_isautomatedorder();
  void set_has_parenttriggerclientorderid();
  void clear_has_parenttriggerclientorderid();
  void set_has_freeformtext();
  void clear_has_freeformtext();
  void set_has_divisor();
  void clear_has_divisor();
  void set_has_openorclose();
  void clear_has_openorclose();
  void set_has_partialfillhandling();
  void clear_has_partialfillhandling();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_1_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_2_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr parenttriggerclientorderid_;
  ::google::protobuf::internal::ArenaStringPtr freeformtext_;
  int ordertype_1_;
  int buysell_1_;
  ::google::protobuf::int64 price1_1_;
  ::google::protobuf::int64 price2_1_;
  ::google::protobuf::int64 quantity_1_;
  int ordertype_2_;
  int buysell_2_;
  ::google::protobuf::int64 price1_2_;
  ::google::protobuf::int64 price2_2_;
  ::google::protobuf::int64 quantity_2_;
  ::google::protobuf::int64 goodtilldatetime_;
  int timeinforce_;
  ::google::protobuf::uint32 isautomatedorder_;
  float divisor_;
  int openorclose_;
  int partialfillhandling_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenOrdersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.OpenOrdersRequest) */ {
 public:
  OpenOrdersRequest();
  virtual ~OpenOrdersRequest();

  OpenOrdersRequest(const OpenOrdersRequest& from);

  inline OpenOrdersRequest& operator=(const OpenOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenOrdersRequest(OpenOrdersRequest&& from) noexcept
    : OpenOrdersRequest() {
    *this = ::std::move(from);
  }

  inline OpenOrdersRequest& operator=(OpenOrdersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenOrdersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const OpenOrdersRequest*>(
               &_OpenOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(OpenOrdersRequest* other);
  friend void swap(OpenOrdersRequest& a, OpenOrdersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenOrdersRequest* New() const final {
    return CreateMaybeMessage<OpenOrdersRequest>(NULL);
  }

  OpenOrdersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpenOrdersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpenOrdersRequest& from);
  void MergeFrom(const OpenOrdersRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenOrdersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 3;
  bool has_serverorderid() const;
  void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 3;
  const ::std::string& serverorderid() const;
  void set_serverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverorderid(::std::string&& value);
  #endif
  void set_serverorderid(const char* value);
  void set_serverorderid(const char* value, size_t size);
  ::std::string* mutable_serverorderid();
  ::std::string* release_serverorderid();
  void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string TradeAccount = 4;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 4;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 RequestAllOrders = 2;
  bool has_requestallorders() const;
  void clear_requestallorders();
  static const int kRequestAllOrdersFieldNumber = 2;
  ::google::protobuf::int32 requestallorders() const;
  void set_requestallorders(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.OpenOrdersRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_requestallorders();
  void clear_has_requestallorders();
  void set_has_serverorderid();
  void clear_has_serverorderid();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverorderid_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 requestallorders_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalOrderFillsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalOrderFillsRequest) */ {
 public:
  HistoricalOrderFillsRequest();
  virtual ~HistoricalOrderFillsRequest();

  HistoricalOrderFillsRequest(const HistoricalOrderFillsRequest& from);

  inline HistoricalOrderFillsRequest& operator=(const HistoricalOrderFillsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalOrderFillsRequest(HistoricalOrderFillsRequest&& from) noexcept
    : HistoricalOrderFillsRequest() {
    *this = ::std::move(from);
  }

  inline HistoricalOrderFillsRequest& operator=(HistoricalOrderFillsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalOrderFillsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalOrderFillsRequest* internal_default_instance() {
    return reinterpret_cast<const HistoricalOrderFillsRequest*>(
               &_HistoricalOrderFillsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(HistoricalOrderFillsRequest* other);
  friend void swap(HistoricalOrderFillsRequest& a, HistoricalOrderFillsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalOrderFillsRequest* New() const final {
    return CreateMaybeMessage<HistoricalOrderFillsRequest>(NULL);
  }

  HistoricalOrderFillsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalOrderFillsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalOrderFillsRequest& from);
  void MergeFrom(const HistoricalOrderFillsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalOrderFillsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 2;
  bool has_serverorderid() const;
  void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 2;
  const ::std::string& serverorderid() const;
  void set_serverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverorderid(::std::string&& value);
  #endif
  void set_serverorderid(const char* value);
  void set_serverorderid(const char* value, size_t size);
  ::std::string* mutable_serverorderid();
  ::std::string* release_serverorderid();
  void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string TradeAccount = 4;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 4;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 NumberOfDays = 3;
  bool has_numberofdays() const;
  void clear_numberofdays();
  static const int kNumberOfDaysFieldNumber = 3;
  ::google::protobuf::int32 numberofdays() const;
  void set_numberofdays(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalOrderFillsRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_serverorderid();
  void clear_has_serverorderid();
  void set_has_numberofdays();
  void clear_has_numberofdays();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverorderid_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 numberofdays_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalOrderFillsReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalOrderFillsReject) */ {
 public:
  HistoricalOrderFillsReject();
  virtual ~HistoricalOrderFillsReject();

  HistoricalOrderFillsReject(const HistoricalOrderFillsReject& from);

  inline HistoricalOrderFillsReject& operator=(const HistoricalOrderFillsReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalOrderFillsReject(HistoricalOrderFillsReject&& from) noexcept
    : HistoricalOrderFillsReject() {
    *this = ::std::move(from);
  }

  inline HistoricalOrderFillsReject& operator=(HistoricalOrderFillsReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalOrderFillsReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalOrderFillsReject* internal_default_instance() {
    return reinterpret_cast<const HistoricalOrderFillsReject*>(
               &_HistoricalOrderFillsReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(HistoricalOrderFillsReject* other);
  friend void swap(HistoricalOrderFillsReject& a, HistoricalOrderFillsReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalOrderFillsReject* New() const final {
    return CreateMaybeMessage<HistoricalOrderFillsReject>(NULL);
  }

  HistoricalOrderFillsReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalOrderFillsReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalOrderFillsReject& from);
  void MergeFrom(const HistoricalOrderFillsReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalOrderFillsReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalOrderFillsReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CurrentPositionsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.CurrentPositionsRequest) */ {
 public:
  CurrentPositionsRequest();
  virtual ~CurrentPositionsRequest();

  CurrentPositionsRequest(const CurrentPositionsRequest& from);

  inline CurrentPositionsRequest& operator=(const CurrentPositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurrentPositionsRequest(CurrentPositionsRequest&& from) noexcept
    : CurrentPositionsRequest() {
    *this = ::std::move(from);
  }

  inline CurrentPositionsRequest& operator=(CurrentPositionsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentPositionsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrentPositionsRequest* internal_default_instance() {
    return reinterpret_cast<const CurrentPositionsRequest*>(
               &_CurrentPositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(CurrentPositionsRequest* other);
  friend void swap(CurrentPositionsRequest& a, CurrentPositionsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurrentPositionsRequest* New() const final {
    return CreateMaybeMessage<CurrentPositionsRequest>(NULL);
  }

  CurrentPositionsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CurrentPositionsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CurrentPositionsRequest& from);
  void MergeFrom(const CurrentPositionsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentPositionsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TradeAccount = 2;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 2;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.CurrentPositionsRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CurrentPositionsReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.CurrentPositionsReject) */ {
 public:
  CurrentPositionsReject();
  virtual ~CurrentPositionsReject();

  CurrentPositionsReject(const CurrentPositionsReject& from);

  inline CurrentPositionsReject& operator=(const CurrentPositionsReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurrentPositionsReject(CurrentPositionsReject&& from) noexcept
    : CurrentPositionsReject() {
    *this = ::std::move(from);
  }

  inline CurrentPositionsReject& operator=(CurrentPositionsReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentPositionsReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrentPositionsReject* internal_default_instance() {
    return reinterpret_cast<const CurrentPositionsReject*>(
               &_CurrentPositionsReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(CurrentPositionsReject* other);
  friend void swap(CurrentPositionsReject& a, CurrentPositionsReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurrentPositionsReject* New() const final {
    return CreateMaybeMessage<CurrentPositionsReject>(NULL);
  }

  CurrentPositionsReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CurrentPositionsReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CurrentPositionsReject& from);
  void MergeFrom(const CurrentPositionsReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentPositionsReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.CurrentPositionsReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.OrderUpdate) */ {
 public:
  OrderUpdate();
  virtual ~OrderUpdate();

  OrderUpdate(const OrderUpdate& from);

  inline OrderUpdate& operator=(const OrderUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderUpdate(OrderUpdate&& from) noexcept
    : OrderUpdate() {
    *this = ::std::move(from);
  }

  inline OrderUpdate& operator=(OrderUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderUpdate* internal_default_instance() {
    return reinterpret_cast<const OrderUpdate*>(
               &_OrderUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(OrderUpdate* other);
  friend void swap(OrderUpdate& a, OrderUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderUpdate* New() const final {
    return CreateMaybeMessage<OrderUpdate>(NULL);
  }

  OrderUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderUpdate& from);
  void MergeFrom(const OrderUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 4;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 5;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 5;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string PreviousServerOrderID = 6;
  bool has_previousserverorderid() const;
  void clear_previousserverorderid();
  static const int kPreviousServerOrderIDFieldNumber = 6;
  const ::std::string& previousserverorderid() const;
  void set_previousserverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_previousserverorderid(::std::string&& value);
  #endif
  void set_previousserverorderid(const char* value);
  void set_previousserverorderid(const char* value, size_t size);
  ::std::string* mutable_previousserverorderid();
  ::std::string* release_previousserverorderid();
  void set_allocated_previousserverorderid(::std::string* previousserverorderid);

  // optional string ServerOrderID = 7;
  bool has_serverorderid() const;
  void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 7;
  const ::std::string& serverorderid() const;
  void set_serverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverorderid(::std::string&& value);
  #endif
  void set_serverorderid(const char* value);
  void set_serverorderid(const char* value, size_t size);
  ::std::string* mutable_serverorderid();
  ::std::string* release_serverorderid();
  void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 8;
  bool has_clientorderid() const;
  void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 8;
  const ::std::string& clientorderid() const;
  void set_clientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientorderid(::std::string&& value);
  #endif
  void set_clientorderid(const char* value);
  void set_clientorderid(const char* value, size_t size);
  ::std::string* mutable_clientorderid();
  ::std::string* release_clientorderid();
  void set_allocated_clientorderid(::std::string* clientorderid);

  // optional string ExchangeOrderID = 9;
  bool has_exchangeorderid() const;
  void clear_exchangeorderid();
  static const int kExchangeOrderIDFieldNumber = 9;
  const ::std::string& exchangeorderid() const;
  void set_exchangeorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_exchangeorderid(::std::string&& value);
  #endif
  void set_exchangeorderid(const char* value);
  void set_exchangeorderid(const char* value, size_t size);
  ::std::string* mutable_exchangeorderid();
  ::std::string* release_exchangeorderid();
  void set_allocated_exchangeorderid(::std::string* exchangeorderid);

  // optional string LastFillExecutionID = 25;
  bool has_lastfillexecutionid() const;
  void clear_lastfillexecutionid();
  static const int kLastFillExecutionIDFieldNumber = 25;
  const ::std::string& lastfillexecutionid() const;
  void set_lastfillexecutionid(const ::std::string& value);
  #if LANG_CXX11
  void set_lastfillexecutionid(::std::string&& value);
  #endif
  void set_lastfillexecutionid(const char* value);
  void set_lastfillexecutionid(const char* value, size_t size);
  ::std::string* mutable_lastfillexecutionid();
  ::std::string* release_lastfillexecutionid();
  void set_allocated_lastfillexecutionid(::std::string* lastfillexecutionid);

  // optional string TradeAccount = 26;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 26;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string InfoText = 27;
  bool has_infotext() const;
  void clear_infotext();
  static const int kInfoTextFieldNumber = 27;
  const ::std::string& infotext() const;
  void set_infotext(const ::std::string& value);
  #if LANG_CXX11
  void set_infotext(::std::string&& value);
  #endif
  void set_infotext(const char* value);
  void set_infotext(const char* value, size_t size);
  ::std::string* mutable_infotext();
  ::std::string* release_infotext();
  void set_allocated_infotext(::std::string* infotext);

  // optional string ParentServerOrderID = 29;
  bool has_parentserverorderid() const;
  void clear_parentserverorderid();
  static const int kParentServerOrderIDFieldNumber = 29;
  const ::std::string& parentserverorderid() const;
  void set_parentserverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_parentserverorderid(::std::string&& value);
  #endif
  void set_parentserverorderid(const char* value);
  void set_parentserverorderid(const char* value, size_t size);
  ::std::string* mutable_parentserverorderid();
  ::std::string* release_parentserverorderid();
  void set_allocated_parentserverorderid(::std::string* parentserverorderid);

  // optional string OCOLinkedOrderServerOrderID = 30;
  bool has_ocolinkedorderserverorderid() const;
  void clear_ocolinkedorderserverorderid();
  static const int kOCOLinkedOrderServerOrderIDFieldNumber = 30;
  const ::std::string& ocolinkedorderserverorderid() const;
  void set_ocolinkedorderserverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_ocolinkedorderserverorderid(::std::string&& value);
  #endif
  void set_ocolinkedorderserverorderid(const char* value);
  void set_ocolinkedorderserverorderid(const char* value, size_t size);
  ::std::string* mutable_ocolinkedorderserverorderid();
  ::std::string* release_ocolinkedorderserverorderid();
  void set_allocated_ocolinkedorderserverorderid(::std::string* ocolinkedorderserverorderid);

  // optional string PreviousClientOrderID = 32;
  bool has_previousclientorderid() const;
  void clear_previousclientorderid();
  static const int kPreviousClientOrderIDFieldNumber = 32;
  const ::std::string& previousclientorderid() const;
  void set_previousclientorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_previousclientorderid(::std::string&& value);
  #endif
  void set_previousclientorderid(const char* value);
  void set_previousclientorderid(const char* value, size_t size);
  ::std::string* mutable_previousclientorderid();
  ::std::string* release_previousclientorderid();
  void set_allocated_previousclientorderid(::std::string* previousclientorderid);

  // optional string FreeFormText = 33;
  bool has_freeformtext() const;
  void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 33;
  const ::std::string& freeformtext() const;
  void set_freeformtext(const ::std::string& value);
  #if LANG_CXX11
  void set_freeformtext(::std::string&& value);
  #endif
  void set_freeformtext(const char* value);
  void set_freeformtext(const char* value, size_t size);
  ::std::string* mutable_freeformtext();
  ::std::string* release_freeformtext();
  void set_allocated_freeformtext(::std::string* freeformtext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumMessages = 2;
  bool has_totalnummessages() const;
  void clear_totalnummessages();
  static const int kTotalNumMessagesFieldNumber = 2;
  ::google::protobuf::int32 totalnummessages() const;
  void set_totalnummessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 3;
  bool has_messagenumber() const;
  void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 3;
  ::google::protobuf::int32 messagenumber() const;
  void set_messagenumber(::google::protobuf::int32 value);

  // optional .DTC_PB.OrderStatusEnum OrderStatus = 10;
  bool has_orderstatus() const;
  void clear_orderstatus();
  static const int kOrderStatusFieldNumber = 10;
  ::DTC_PB::OrderStatusEnum orderstatus() const;
  void set_orderstatus(::DTC_PB::OrderStatusEnum value);

  // optional .DTC_PB.OrderUpdateReasonEnum OrderUpdateReason = 11;
  bool has_orderupdatereason() const;
  void clear_orderupdatereason();
  static const int kOrderUpdateReasonFieldNumber = 11;
  ::DTC_PB::OrderUpdateReasonEnum orderupdatereason() const;
  void set_orderupdatereason(::DTC_PB::OrderUpdateReasonEnum value);

  // optional .DTC_PB.OrderTypeEnum OrderType = 12;
  bool has_ordertype() const;
  void clear_ordertype();
  static const int kOrderTypeFieldNumber = 12;
  ::DTC_PB::OrderTypeEnum ordertype() const;
  void set_ordertype(::DTC_PB::OrderTypeEnum value);

  // optional double Price1 = 14;
  bool has_price1() const;
  void clear_price1();
  static const int kPrice1FieldNumber = 14;
  double price1() const;
  void set_price1(double value);

  // optional .DTC_PB.BuySellEnum BuySell = 13;
  bool has_buysell() const;
  void clear_buysell();
  static const int kBuySellFieldNumber = 13;
  ::DTC_PB::BuySellEnum buysell() const;
  void set_buysell(::DTC_PB::BuySellEnum value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 16;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 16;
  ::DTC_PB::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional double Price2 = 15;
  bool has_price2() const;
  void clear_price2();
  static const int kPrice2FieldNumber = 15;
  double price2() const;
  void set_price2(double value);

  // optional sfixed64 GoodTillDateTime = 17;
  bool has_goodtilldatetime() const;
  void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 17;
  ::google::protobuf::int64 goodtilldatetime() const;
  void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional double OrderQuantity = 18;
  bool has_orderquantity() const;
  void clear_orderquantity();
  static const int kOrderQuantityFieldNumber = 18;
  double orderquantity() const;
  void set_orderquantity(double value);

  // optional double FilledQuantity = 19;
  bool has_filledquantity() const;
  void clear_filledquantity();
  static const int kFilledQuantityFieldNumber = 19;
  double filledquantity() const;
  void set_filledquantity(double value);

  // optional double RemainingQuantity = 20;
  bool has_remainingquantity() const;
  void clear_remainingquantity();
  static const int kRemainingQuantityFieldNumber = 20;
  double remainingquantity() const;
  void set_remainingquantity(double value);

  // optional double AverageFillPrice = 21;
  bool has_averagefillprice() const;
  void clear_averagefillprice();
  static const int kAverageFillPriceFieldNumber = 21;
  double averagefillprice() const;
  void set_averagefillprice(double value);

  // optional double LastFillPrice = 22;
  bool has_lastfillprice() const;
  void clear_lastfillprice();
  static const int kLastFillPriceFieldNumber = 22;
  double lastfillprice() const;
  void set_lastfillprice(double value);

  // optional sfixed64 LastFillDateTime = 23;
  bool has_lastfilldatetime() const;
  void clear_lastfilldatetime();
  static const int kLastFillDateTimeFieldNumber = 23;
  ::google::protobuf::int64 lastfilldatetime() const;
  void set_lastfilldatetime(::google::protobuf::int64 value);

  // optional double LastFillQuantity = 24;
  bool has_lastfillquantity() const;
  void clear_lastfillquantity();
  static const int kLastFillQuantityFieldNumber = 24;
  double lastfillquantity() const;
  void set_lastfillquantity(double value);

  // optional uint32 NoOrders = 28;
  bool has_noorders() const;
  void clear_noorders();
  static const int kNoOrdersFieldNumber = 28;
  ::google::protobuf::uint32 noorders() const;
  void set_noorders(::google::protobuf::uint32 value);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 31;
  bool has_openorclose() const;
  void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 31;
  ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // optional sfixed64 OrderReceivedDateTime = 34;
  bool has_orderreceiveddatetime() const;
  void clear_orderreceiveddatetime();
  static const int kOrderReceivedDateTimeFieldNumber = 34;
  ::google::protobuf::int64 orderreceiveddatetime() const;
  void set_orderreceiveddatetime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.OrderUpdate)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_totalnummessages();
  void clear_has_totalnummessages();
  void set_has_messagenumber();
  void clear_has_messagenumber();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_previousserverorderid();
  void clear_has_previousserverorderid();
  void set_has_serverorderid();
  void clear_has_serverorderid();
  void set_has_clientorderid();
  void clear_has_clientorderid();
  void set_has_exchangeorderid();
  void clear_has_exchangeorderid();
  void set_has_orderstatus();
  void clear_has_orderstatus();
  void set_has_orderupdatereason();
  void clear_has_orderupdatereason();
  void set_has_ordertype();
  void clear_has_ordertype();
  void set_has_buysell();
  void clear_has_buysell();
  void set_has_price1();
  void clear_has_price1();
  void set_has_price2();
  void clear_has_price2();
  void set_has_timeinforce();
  void clear_has_timeinforce();
  void set_has_goodtilldatetime();
  void clear_has_goodtilldatetime();
  void set_has_orderquantity();
  void clear_has_orderquantity();
  void set_has_filledquantity();
  void clear_has_filledquantity();
  void set_has_remainingquantity();
  void clear_has_remainingquantity();
  void set_has_averagefillprice();
  void clear_has_averagefillprice();
  void set_has_lastfillprice();
  void clear_has_lastfillprice();
  void set_has_lastfilldatetime();
  void clear_has_lastfilldatetime();
  void set_has_lastfillquantity();
  void clear_has_lastfillquantity();
  void set_has_lastfillexecutionid();
  void clear_has_lastfillexecutionid();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_infotext();
  void clear_has_infotext();
  void set_has_noorders();
  void clear_has_noorders();
  void set_has_parentserverorderid();
  void clear_has_parentserverorderid();
  void set_has_ocolinkedorderserverorderid();
  void clear_has_ocolinkedorderserverorderid();
  void set_has_openorclose();
  void clear_has_openorclose();
  void set_has_previousclientorderid();
  void clear_has_previousclientorderid();
  void set_has_freeformtext();
  void clear_has_freeformtext();
  void set_has_orderreceiveddatetime();
  void clear_has_orderreceiveddatetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr previousserverorderid_;
  ::google::protobuf::internal::ArenaStringPtr serverorderid_;
  ::google::protobuf::internal::ArenaStringPtr clientorderid_;
  ::google::protobuf::internal::ArenaStringPtr exchangeorderid_;
  ::google::protobuf::internal::ArenaStringPtr lastfillexecutionid_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr infotext_;
  ::google::protobuf::internal::ArenaStringPtr parentserverorderid_;
  ::google::protobuf::internal::ArenaStringPtr ocolinkedorderserverorderid_;
  ::google::protobuf::internal::ArenaStringPtr previousclientorderid_;
  ::google::protobuf::internal::ArenaStringPtr freeformtext_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnummessages_;
  ::google::protobuf::int32 messagenumber_;
  int orderstatus_;
  int orderupdatereason_;
  int ordertype_;
  double price1_;
  int buysell_;
  int timeinforce_;
  double price2_;
  ::google::protobuf::int64 goodtilldatetime_;
  double orderquantity_;
  double filledquantity_;
  double remainingquantity_;
  double averagefillprice_;
  double lastfillprice_;
  ::google::protobuf::int64 lastfilldatetime_;
  double lastfillquantity_;
  ::google::protobuf::uint32 noorders_;
  int openorclose_;
  ::google::protobuf::int64 orderreceiveddatetime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenOrdersReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.OpenOrdersReject) */ {
 public:
  OpenOrdersReject();
  virtual ~OpenOrdersReject();

  OpenOrdersReject(const OpenOrdersReject& from);

  inline OpenOrdersReject& operator=(const OpenOrdersReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenOrdersReject(OpenOrdersReject&& from) noexcept
    : OpenOrdersReject() {
    *this = ::std::move(from);
  }

  inline OpenOrdersReject& operator=(OpenOrdersReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenOrdersReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenOrdersReject* internal_default_instance() {
    return reinterpret_cast<const OpenOrdersReject*>(
               &_OpenOrdersReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(OpenOrdersReject* other);
  friend void swap(OpenOrdersReject& a, OpenOrdersReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenOrdersReject* New() const final {
    return CreateMaybeMessage<OpenOrdersReject>(NULL);
  }

  OpenOrdersReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpenOrdersReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpenOrdersReject& from);
  void MergeFrom(const OpenOrdersReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenOrdersReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.OpenOrdersReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalOrderFillResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalOrderFillResponse) */ {
 public:
  HistoricalOrderFillResponse();
  virtual ~HistoricalOrderFillResponse();

  HistoricalOrderFillResponse(const HistoricalOrderFillResponse& from);

  inline HistoricalOrderFillResponse& operator=(const HistoricalOrderFillResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalOrderFillResponse(HistoricalOrderFillResponse&& from) noexcept
    : HistoricalOrderFillResponse() {
    *this = ::std::move(from);
  }

  inline HistoricalOrderFillResponse& operator=(HistoricalOrderFillResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalOrderFillResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalOrderFillResponse* internal_default_instance() {
    return reinterpret_cast<const HistoricalOrderFillResponse*>(
               &_HistoricalOrderFillResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(HistoricalOrderFillResponse* other);
  friend void swap(HistoricalOrderFillResponse& a, HistoricalOrderFillResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalOrderFillResponse* New() const final {
    return CreateMaybeMessage<HistoricalOrderFillResponse>(NULL);
  }

  HistoricalOrderFillResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalOrderFillResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalOrderFillResponse& from);
  void MergeFrom(const HistoricalOrderFillResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalOrderFillResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 4;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 5;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 5;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string ServerOrderID = 6;
  bool has_serverorderid() const;
  void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 6;
  const ::std::string& serverorderid() const;
  void set_serverorderid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverorderid(::std::string&& value);
  #endif
  void set_serverorderid(const char* value);
  void set_serverorderid(const char* value, size_t size);
  ::std::string* mutable_serverorderid();
  ::std::string* release_serverorderid();
  void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string UniqueExecutionID = 11;
  bool has_uniqueexecutionid() const;
  void clear_uniqueexecutionid();
  static const int kUniqueExecutionIDFieldNumber = 11;
  const ::std::string& uniqueexecutionid() const;
  void set_uniqueexecutionid(const ::std::string& value);
  #if LANG_CXX11
  void set_uniqueexecutionid(::std::string&& value);
  #endif
  void set_uniqueexecutionid(const char* value);
  void set_uniqueexecutionid(const char* value, size_t size);
  ::std::string* mutable_uniqueexecutionid();
  ::std::string* release_uniqueexecutionid();
  void set_allocated_uniqueexecutionid(::std::string* uniqueexecutionid);

  // optional string TradeAccount = 12;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 12;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string InfoText = 15;
  bool has_infotext() const;
  void clear_infotext();
  static const int kInfoTextFieldNumber = 15;
  const ::std::string& infotext() const;
  void set_infotext(const ::std::string& value);
  #if LANG_CXX11
  void set_infotext(::std::string&& value);
  #endif
  void set_infotext(const char* value);
  void set_infotext(const char* value, size_t size);
  ::std::string* mutable_infotext();
  ::std::string* release_infotext();
  void set_allocated_infotext(::std::string* infotext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumberMessages = 2;
  bool has_totalnumbermessages() const;
  void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 2;
  ::google::protobuf::int32 totalnumbermessages() const;
  void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 3;
  bool has_messagenumber() const;
  void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 3;
  ::google::protobuf::int32 messagenumber() const;
  void set_messagenumber(::google::protobuf::int32 value);

  // optional .DTC_PB.BuySellEnum BuySell = 7;
  bool has_buysell() const;
  void clear_buysell();
  static const int kBuySellFieldNumber = 7;
  ::DTC_PB::BuySellEnum buysell() const;
  void set_buysell(::DTC_PB::BuySellEnum value);

  // optional double Price = 8;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 8;
  double price() const;
  void set_price(double value);

  // optional sfixed64 DateTime = 9;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 9;
  ::google::protobuf::int64 datetime() const;
  void set_datetime(::google::protobuf::int64 value);

  // optional double Quantity = 10;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 10;
  double quantity() const;
  void set_quantity(double value);

  // optional .DTC_PB.OpenCloseTradeEnum OpenClose = 13;
  bool has_openclose() const;
  void clear_openclose();
  static const int kOpenCloseFieldNumber = 13;
  ::DTC_PB::OpenCloseTradeEnum openclose() const;
  void set_openclose(::DTC_PB::OpenCloseTradeEnum value);

  // optional uint32 NoOrderFills = 14;
  bool has_noorderfills() const;
  void clear_noorderfills();
  static const int kNoOrderFillsFieldNumber = 14;
  ::google::protobuf::uint32 noorderfills() const;
  void set_noorderfills(::google::protobuf::uint32 value);

  // optional double HighPriceDuringPosition = 16;
  bool has_highpriceduringposition() const;
  void clear_highpriceduringposition();
  static const int kHighPriceDuringPositionFieldNumber = 16;
  double highpriceduringposition() const;
  void set_highpriceduringposition(double value);

  // optional double LowPriceDuringPosition = 17;
  bool has_lowpriceduringposition() const;
  void clear_lowpriceduringposition();
  static const int kLowPriceDuringPositionFieldNumber = 17;
  double lowpriceduringposition() const;
  void set_lowpriceduringposition(double value);

  // optional double PositionQuantity = 18;
  bool has_positionquantity() const;
  void clear_positionquantity();
  static const int kPositionQuantityFieldNumber = 18;
  double positionquantity() const;
  void set_positionquantity(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalOrderFillResponse)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_totalnumbermessages();
  void clear_has_totalnumbermessages();
  void set_has_messagenumber();
  void clear_has_messagenumber();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_serverorderid();
  void clear_has_serverorderid();
  void set_has_buysell();
  void clear_has_buysell();
  void set_has_price();
  void clear_has_price();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_uniqueexecutionid();
  void clear_has_uniqueexecutionid();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_openclose();
  void clear_has_openclose();
  void set_has_noorderfills();
  void clear_has_noorderfills();
  void set_has_infotext();
  void clear_has_infotext();
  void set_has_highpriceduringposition();
  void clear_has_highpriceduringposition();
  void set_has_lowpriceduringposition();
  void clear_has_lowpriceduringposition();
  void set_has_positionquantity();
  void clear_has_positionquantity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr serverorderid_;
  ::google::protobuf::internal::ArenaStringPtr uniqueexecutionid_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr infotext_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnumbermessages_;
  ::google::protobuf::int32 messagenumber_;
  int buysell_;
  double price_;
  ::google::protobuf::int64 datetime_;
  double quantity_;
  int openclose_;
  ::google::protobuf::uint32 noorderfills_;
  double highpriceduringposition_;
  double lowpriceduringposition_;
  double positionquantity_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.PositionUpdate) */ {
 public:
  PositionUpdate();
  virtual ~PositionUpdate();

  PositionUpdate(const PositionUpdate& from);

  inline PositionUpdate& operator=(const PositionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionUpdate(PositionUpdate&& from) noexcept
    : PositionUpdate() {
    *this = ::std::move(from);
  }

  inline PositionUpdate& operator=(PositionUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionUpdate* internal_default_instance() {
    return reinterpret_cast<const PositionUpdate*>(
               &_PositionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(PositionUpdate* other);
  friend void swap(PositionUpdate& a, PositionUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionUpdate* New() const final {
    return CreateMaybeMessage<PositionUpdate>(NULL);
  }

  PositionUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionUpdate& from);
  void MergeFrom(const PositionUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 4;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 5;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 5;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string PositionIdentifier = 8;
  bool has_positionidentifier() const;
  void clear_positionidentifier();
  static const int kPositionIdentifierFieldNumber = 8;
  const ::std::string& positionidentifier() const;
  void set_positionidentifier(const ::std::string& value);
  #if LANG_CXX11
  void set_positionidentifier(::std::string&& value);
  #endif
  void set_positionidentifier(const char* value);
  void set_positionidentifier(const char* value, size_t size);
  ::std::string* mutable_positionidentifier();
  ::std::string* release_positionidentifier();
  void set_allocated_positionidentifier(::std::string* positionidentifier);

  // optional string TradeAccount = 9;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 9;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumberMessages = 2;
  bool has_totalnumbermessages() const;
  void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 2;
  ::google::protobuf::int32 totalnumbermessages() const;
  void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional double Quantity = 6;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  double quantity() const;
  void set_quantity(double value);

  // optional int32 MessageNumber = 3;
  bool has_messagenumber() const;
  void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 3;
  ::google::protobuf::int32 messagenumber() const;
  void set_messagenumber(::google::protobuf::int32 value);

  // optional uint32 NoPositions = 10;
  bool has_nopositions() const;
  void clear_nopositions();
  static const int kNoPositionsFieldNumber = 10;
  ::google::protobuf::uint32 nopositions() const;
  void set_nopositions(::google::protobuf::uint32 value);

  // optional double AveragePrice = 7;
  bool has_averageprice() const;
  void clear_averageprice();
  static const int kAveragePriceFieldNumber = 7;
  double averageprice() const;
  void set_averageprice(double value);

  // optional double MarginRequirement = 12;
  bool has_marginrequirement() const;
  void clear_marginrequirement();
  static const int kMarginRequirementFieldNumber = 12;
  double marginrequirement() const;
  void set_marginrequirement(double value);

  // optional uint32 Unsolicited = 11;
  bool has_unsolicited() const;
  void clear_unsolicited();
  static const int kUnsolicitedFieldNumber = 11;
  ::google::protobuf::uint32 unsolicited() const;
  void set_unsolicited(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.PositionUpdate)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_totalnumbermessages();
  void clear_has_totalnumbermessages();
  void set_has_messagenumber();
  void clear_has_messagenumber();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_averageprice();
  void clear_has_averageprice();
  void set_has_positionidentifier();
  void clear_has_positionidentifier();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_nopositions();
  void clear_has_nopositions();
  void set_has_unsolicited();
  void clear_has_unsolicited();
  void set_has_marginrequirement();
  void clear_has_marginrequirement();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr positionidentifier_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnumbermessages_;
  double quantity_;
  ::google::protobuf::int32 messagenumber_;
  ::google::protobuf::uint32 nopositions_;
  double averageprice_;
  double marginrequirement_;
  ::google::protobuf::uint32 unsolicited_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradeAccountsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.TradeAccountsRequest) */ {
 public:
  TradeAccountsRequest();
  virtual ~TradeAccountsRequest();

  TradeAccountsRequest(const TradeAccountsRequest& from);

  inline TradeAccountsRequest& operator=(const TradeAccountsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeAccountsRequest(TradeAccountsRequest&& from) noexcept
    : TradeAccountsRequest() {
    *this = ::std::move(from);
  }

  inline TradeAccountsRequest& operator=(TradeAccountsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeAccountsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeAccountsRequest* internal_default_instance() {
    return reinterpret_cast<const TradeAccountsRequest*>(
               &_TradeAccountsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(TradeAccountsRequest* other);
  friend void swap(TradeAccountsRequest& a, TradeAccountsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeAccountsRequest* New() const final {
    return CreateMaybeMessage<TradeAccountsRequest>(NULL);
  }

  TradeAccountsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradeAccountsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradeAccountsRequest& from);
  void MergeFrom(const TradeAccountsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeAccountsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.TradeAccountsRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradeAccountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.TradeAccountResponse) */ {
 public:
  TradeAccountResponse();
  virtual ~TradeAccountResponse();

  TradeAccountResponse(const TradeAccountResponse& from);

  inline TradeAccountResponse& operator=(const TradeAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeAccountResponse(TradeAccountResponse&& from) noexcept
    : TradeAccountResponse() {
    *this = ::std::move(from);
  }

  inline TradeAccountResponse& operator=(TradeAccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeAccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeAccountResponse* internal_default_instance() {
    return reinterpret_cast<const TradeAccountResponse*>(
               &_TradeAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(TradeAccountResponse* other);
  friend void swap(TradeAccountResponse& a, TradeAccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeAccountResponse* New() const final {
    return CreateMaybeMessage<TradeAccountResponse>(NULL);
  }

  TradeAccountResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradeAccountResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradeAccountResponse& from);
  void MergeFrom(const TradeAccountResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeAccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TradeAccount = 3;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 3;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional int32 TotalNumberMessages = 1;
  bool has_totalnumbermessages() const;
  void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 1;
  ::google::protobuf::int32 totalnumbermessages() const;
  void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 2;
  bool has_messagenumber() const;
  void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 2;
  ::google::protobuf::int32 messagenumber() const;
  void set_messagenumber(::google::protobuf::int32 value);

  // optional int32 RequestID = 4;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 4;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.TradeAccountResponse)
 private:
  void set_has_totalnumbermessages();
  void clear_has_totalnumbermessages();
  void set_has_messagenumber();
  void clear_has_messagenumber();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_requestid();
  void clear_has_requestid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::int32 totalnumbermessages_;
  ::google::protobuf::int32 messagenumber_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.ExchangeListRequest) */ {
 public:
  ExchangeListRequest();
  virtual ~ExchangeListRequest();

  ExchangeListRequest(const ExchangeListRequest& from);

  inline ExchangeListRequest& operator=(const ExchangeListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeListRequest(ExchangeListRequest&& from) noexcept
    : ExchangeListRequest() {
    *this = ::std::move(from);
  }

  inline ExchangeListRequest& operator=(ExchangeListRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeListRequest* internal_default_instance() {
    return reinterpret_cast<const ExchangeListRequest*>(
               &_ExchangeListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(ExchangeListRequest* other);
  friend void swap(ExchangeListRequest& a, ExchangeListRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeListRequest* New() const final {
    return CreateMaybeMessage<ExchangeListRequest>(NULL);
  }

  ExchangeListRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeListRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeListRequest& from);
  void MergeFrom(const ExchangeListRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.ExchangeListRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeListResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.ExchangeListResponse) */ {
 public:
  ExchangeListResponse();
  virtual ~ExchangeListResponse();

  ExchangeListResponse(const ExchangeListResponse& from);

  inline ExchangeListResponse& operator=(const ExchangeListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeListResponse(ExchangeListResponse&& from) noexcept
    : ExchangeListResponse() {
    *this = ::std::move(from);
  }

  inline ExchangeListResponse& operator=(ExchangeListResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeListResponse* internal_default_instance() {
    return reinterpret_cast<const ExchangeListResponse*>(
               &_ExchangeListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(ExchangeListResponse* other);
  friend void swap(ExchangeListResponse& a, ExchangeListResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeListResponse* New() const final {
    return CreateMaybeMessage<ExchangeListResponse>(NULL);
  }

  ExchangeListResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeListResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeListResponse& from);
  void MergeFrom(const ExchangeListResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Exchange = 2;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string Description = 4;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional uint32 IsFinalMessage = 3;
  bool has_isfinalmessage() const;
  void clear_isfinalmessage();
  static const int kIsFinalMessageFieldNumber = 3;
  ::google::protobuf::uint32 isfinalmessage() const;
  void set_isfinalmessage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.ExchangeListResponse)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_isfinalmessage();
  void clear_has_isfinalmessage();
  void set_has_description();
  void clear_has_description();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::uint32 isfinalmessage_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolsForExchangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SymbolsForExchangeRequest) */ {
 public:
  SymbolsForExchangeRequest();
  virtual ~SymbolsForExchangeRequest();

  SymbolsForExchangeRequest(const SymbolsForExchangeRequest& from);

  inline SymbolsForExchangeRequest& operator=(const SymbolsForExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolsForExchangeRequest(SymbolsForExchangeRequest&& from) noexcept
    : SymbolsForExchangeRequest() {
    *this = ::std::move(from);
  }

  inline SymbolsForExchangeRequest& operator=(SymbolsForExchangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolsForExchangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SymbolsForExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const SymbolsForExchangeRequest*>(
               &_SymbolsForExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(SymbolsForExchangeRequest* other);
  friend void swap(SymbolsForExchangeRequest& a, SymbolsForExchangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolsForExchangeRequest* New() const final {
    return CreateMaybeMessage<SymbolsForExchangeRequest>(NULL);
  }

  SymbolsForExchangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SymbolsForExchangeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SymbolsForExchangeRequest& from);
  void MergeFrom(const SymbolsForExchangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolsForExchangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Exchange = 2;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string Symbol = 5;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 5;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
  bool has_securitytype() const;
  void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 3;
  ::DTC_PB::SecurityTypeEnum securitytype() const;
  void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // optional .DTC_PB.RequestActionEnum RequestAction = 4;
  bool has_requestaction() const;
  void clear_requestaction();
  static const int kRequestActionFieldNumber = 4;
  ::DTC_PB::RequestActionEnum requestaction() const;
  void set_requestaction(::DTC_PB::RequestActionEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SymbolsForExchangeRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_securitytype();
  void clear_has_securitytype();
  void set_has_requestaction();
  void clear_has_requestaction();
  void set_has_symbol();
  void clear_has_symbol();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  int requestaction_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnderlyingSymbolsForExchangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.UnderlyingSymbolsForExchangeRequest) */ {
 public:
  UnderlyingSymbolsForExchangeRequest();
  virtual ~UnderlyingSymbolsForExchangeRequest();

  UnderlyingSymbolsForExchangeRequest(const UnderlyingSymbolsForExchangeRequest& from);

  inline UnderlyingSymbolsForExchangeRequest& operator=(const UnderlyingSymbolsForExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnderlyingSymbolsForExchangeRequest(UnderlyingSymbolsForExchangeRequest&& from) noexcept
    : UnderlyingSymbolsForExchangeRequest() {
    *this = ::std::move(from);
  }

  inline UnderlyingSymbolsForExchangeRequest& operator=(UnderlyingSymbolsForExchangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnderlyingSymbolsForExchangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnderlyingSymbolsForExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const UnderlyingSymbolsForExchangeRequest*>(
               &_UnderlyingSymbolsForExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(UnderlyingSymbolsForExchangeRequest* other);
  friend void swap(UnderlyingSymbolsForExchangeRequest& a, UnderlyingSymbolsForExchangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnderlyingSymbolsForExchangeRequest* New() const final {
    return CreateMaybeMessage<UnderlyingSymbolsForExchangeRequest>(NULL);
  }

  UnderlyingSymbolsForExchangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnderlyingSymbolsForExchangeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnderlyingSymbolsForExchangeRequest& from);
  void MergeFrom(const UnderlyingSymbolsForExchangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnderlyingSymbolsForExchangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Exchange = 2;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
  bool has_securitytype() const;
  void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 3;
  ::DTC_PB::SecurityTypeEnum securitytype() const;
  void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.UnderlyingSymbolsForExchangeRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_securitytype();
  void clear_has_securitytype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolsForUnderlyingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SymbolsForUnderlyingRequest) */ {
 public:
  SymbolsForUnderlyingRequest();
  virtual ~SymbolsForUnderlyingRequest();

  SymbolsForUnderlyingRequest(const SymbolsForUnderlyingRequest& from);

  inline SymbolsForUnderlyingRequest& operator=(const SymbolsForUnderlyingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolsForUnderlyingRequest(SymbolsForUnderlyingRequest&& from) noexcept
    : SymbolsForUnderlyingRequest() {
    *this = ::std::move(from);
  }

  inline SymbolsForUnderlyingRequest& operator=(SymbolsForUnderlyingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolsForUnderlyingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SymbolsForUnderlyingRequest* internal_default_instance() {
    return reinterpret_cast<const SymbolsForUnderlyingRequest*>(
               &_SymbolsForUnderlyingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(SymbolsForUnderlyingRequest* other);
  friend void swap(SymbolsForUnderlyingRequest& a, SymbolsForUnderlyingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolsForUnderlyingRequest* New() const final {
    return CreateMaybeMessage<SymbolsForUnderlyingRequest>(NULL);
  }

  SymbolsForUnderlyingRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SymbolsForUnderlyingRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SymbolsForUnderlyingRequest& from);
  void MergeFrom(const SymbolsForUnderlyingRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolsForUnderlyingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UnderlyingSymbol = 2;
  bool has_underlyingsymbol() const;
  void clear_underlyingsymbol();
  static const int kUnderlyingSymbolFieldNumber = 2;
  const ::std::string& underlyingsymbol() const;
  void set_underlyingsymbol(const ::std::string& value);
  #if LANG_CXX11
  void set_underlyingsymbol(::std::string&& value);
  #endif
  void set_underlyingsymbol(const char* value);
  void set_underlyingsymbol(const char* value, size_t size);
  ::std::string* mutable_underlyingsymbol();
  ::std::string* release_underlyingsymbol();
  void set_allocated_underlyingsymbol(::std::string* underlyingsymbol);

  // optional string Exchange = 3;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
  bool has_securitytype() const;
  void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 4;
  ::DTC_PB::SecurityTypeEnum securitytype() const;
  void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SymbolsForUnderlyingRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_underlyingsymbol();
  void clear_has_underlyingsymbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_securitytype();
  void clear_has_securitytype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr underlyingsymbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolSearchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SymbolSearchRequest) */ {
 public:
  SymbolSearchRequest();
  virtual ~SymbolSearchRequest();

  SymbolSearchRequest(const SymbolSearchRequest& from);

  inline SymbolSearchRequest& operator=(const SymbolSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolSearchRequest(SymbolSearchRequest&& from) noexcept
    : SymbolSearchRequest() {
    *this = ::std::move(from);
  }

  inline SymbolSearchRequest& operator=(SymbolSearchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolSearchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SymbolSearchRequest* internal_default_instance() {
    return reinterpret_cast<const SymbolSearchRequest*>(
               &_SymbolSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(SymbolSearchRequest* other);
  friend void swap(SymbolSearchRequest& a, SymbolSearchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolSearchRequest* New() const final {
    return CreateMaybeMessage<SymbolSearchRequest>(NULL);
  }

  SymbolSearchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SymbolSearchRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SymbolSearchRequest& from);
  void MergeFrom(const SymbolSearchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolSearchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string SearchText = 2;
  bool has_searchtext() const;
  void clear_searchtext();
  static const int kSearchTextFieldNumber = 2;
  const ::std::string& searchtext() const;
  void set_searchtext(const ::std::string& value);
  #if LANG_CXX11
  void set_searchtext(::std::string&& value);
  #endif
  void set_searchtext(const char* value);
  void set_searchtext(const char* value, size_t size);
  ::std::string* mutable_searchtext();
  ::std::string* release_searchtext();
  void set_allocated_searchtext(::std::string* searchtext);

  // optional string Exchange = 3;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
  bool has_securitytype() const;
  void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 4;
  ::DTC_PB::SecurityTypeEnum securitytype() const;
  void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // optional .DTC_PB.SearchTypeEnum SearchType = 5;
  bool has_searchtype() const;
  void clear_searchtype();
  static const int kSearchTypeFieldNumber = 5;
  ::DTC_PB::SearchTypeEnum searchtype() const;
  void set_searchtype(::DTC_PB::SearchTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SymbolSearchRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_searchtext();
  void clear_has_searchtext();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_securitytype();
  void clear_has_securitytype();
  void set_has_searchtype();
  void clear_has_searchtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr searchtext_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  int searchtype_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityDefinitionForSymbolRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SecurityDefinitionForSymbolRequest) */ {
 public:
  SecurityDefinitionForSymbolRequest();
  virtual ~SecurityDefinitionForSymbolRequest();

  SecurityDefinitionForSymbolRequest(const SecurityDefinitionForSymbolRequest& from);

  inline SecurityDefinitionForSymbolRequest& operator=(const SecurityDefinitionForSymbolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityDefinitionForSymbolRequest(SecurityDefinitionForSymbolRequest&& from) noexcept
    : SecurityDefinitionForSymbolRequest() {
    *this = ::std::move(from);
  }

  inline SecurityDefinitionForSymbolRequest& operator=(SecurityDefinitionForSymbolRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionForSymbolRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityDefinitionForSymbolRequest* internal_default_instance() {
    return reinterpret_cast<const SecurityDefinitionForSymbolRequest*>(
               &_SecurityDefinitionForSymbolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(SecurityDefinitionForSymbolRequest* other);
  friend void swap(SecurityDefinitionForSymbolRequest& a, SecurityDefinitionForSymbolRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityDefinitionForSymbolRequest* New() const final {
    return CreateMaybeMessage<SecurityDefinitionForSymbolRequest>(NULL);
  }

  SecurityDefinitionForSymbolRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityDefinitionForSymbolRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityDefinitionForSymbolRequest& from);
  void MergeFrom(const SecurityDefinitionForSymbolRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityDefinitionForSymbolRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 2;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 3;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SecurityDefinitionForSymbolRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityDefinitionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SecurityDefinitionResponse) */ {
 public:
  SecurityDefinitionResponse();
  virtual ~SecurityDefinitionResponse();

  SecurityDefinitionResponse(const SecurityDefinitionResponse& from);

  inline SecurityDefinitionResponse& operator=(const SecurityDefinitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityDefinitionResponse(SecurityDefinitionResponse&& from) noexcept
    : SecurityDefinitionResponse() {
    *this = ::std::move(from);
  }

  inline SecurityDefinitionResponse& operator=(SecurityDefinitionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityDefinitionResponse* internal_default_instance() {
    return reinterpret_cast<const SecurityDefinitionResponse*>(
               &_SecurityDefinitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(SecurityDefinitionResponse* other);
  friend void swap(SecurityDefinitionResponse& a, SecurityDefinitionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityDefinitionResponse* New() const final {
    return CreateMaybeMessage<SecurityDefinitionResponse>(NULL);
  }

  SecurityDefinitionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityDefinitionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityDefinitionResponse& from);
  void MergeFrom(const SecurityDefinitionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityDefinitionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 2;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 3;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional string Description = 5;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 5;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string UnderlyingSymbol = 12;
  bool has_underlyingsymbol() const;
  void clear_underlyingsymbol();
  static const int kUnderlyingSymbolFieldNumber = 12;
  const ::std::string& underlyingsymbol() const;
  void set_underlyingsymbol(const ::std::string& value);
  #if LANG_CXX11
  void set_underlyingsymbol(::std::string&& value);
  #endif
  void set_underlyingsymbol(const char* value);
  void set_underlyingsymbol(const char* value, size_t size);
  ::std::string* mutable_underlyingsymbol();
  ::std::string* release_underlyingsymbol();
  void set_allocated_underlyingsymbol(::std::string* underlyingsymbol);

  // optional string ExchangeSymbol = 25;
  bool has_exchangesymbol() const;
  void clear_exchangesymbol();
  static const int kExchangeSymbolFieldNumber = 25;
  const ::std::string& exchangesymbol() const;
  void set_exchangesymbol(const ::std::string& value);
  #if LANG_CXX11
  void set_exchangesymbol(::std::string&& value);
  #endif
  void set_exchangesymbol(const char* value);
  void set_exchangesymbol(const char* value, size_t size);
  ::std::string* mutable_exchangesymbol();
  ::std::string* release_exchangesymbol();
  void set_allocated_exchangesymbol(::std::string* exchangesymbol);

  // optional string Currency = 28;
  bool has_currency() const;
  void clear_currency();
  static const int kCurrencyFieldNumber = 28;
  const ::std::string& currency() const;
  void set_currency(const ::std::string& value);
  #if LANG_CXX11
  void set_currency(::std::string&& value);
  #endif
  void set_currency(const char* value);
  void set_currency(const char* value, size_t size);
  ::std::string* mutable_currency();
  ::std::string* release_currency();
  void set_allocated_currency(::std::string* currency);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
  bool has_securitytype() const;
  void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 4;
  ::DTC_PB::SecurityTypeEnum securitytype() const;
  void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // optional float MinPriceIncrement = 6;
  bool has_minpriceincrement() const;
  void clear_minpriceincrement();
  static const int kMinPriceIncrementFieldNumber = 6;
  float minpriceincrement() const;
  void set_minpriceincrement(float value);

  // optional float CurrencyValuePerIncrement = 8;
  bool has_currencyvalueperincrement() const;
  void clear_currencyvalueperincrement();
  static const int kCurrencyValuePerIncrementFieldNumber = 8;
  float currencyvalueperincrement() const;
  void set_currencyvalueperincrement(float value);

  // optional uint32 IsFinalMessage = 9;
  bool has_isfinalmessage() const;
  void clear_isfinalmessage();
  static const int kIsFinalMessageFieldNumber = 9;
  ::google::protobuf::uint32 isfinalmessage() const;
  void set_isfinalmessage(::google::protobuf::uint32 value);

  // optional float FloatToIntPriceMultiplier = 10;
  bool has_floattointpricemultiplier() const;
  void clear_floattointpricemultiplier();
  static const int kFloatToIntPriceMultiplierFieldNumber = 10;
  float floattointpricemultiplier() const;
  void set_floattointpricemultiplier(float value);

  // optional float IntToFloatPriceDivisor = 11;
  bool has_inttofloatpricedivisor() const;
  void clear_inttofloatpricedivisor();
  static const int kIntToFloatPriceDivisorFieldNumber = 11;
  float inttofloatpricedivisor() const;
  void set_inttofloatpricedivisor(float value);

  // optional uint32 UpdatesBidAskOnly = 13;
  bool has_updatesbidaskonly() const;
  void clear_updatesbidaskonly();
  static const int kUpdatesBidAskOnlyFieldNumber = 13;
  ::google::protobuf::uint32 updatesbidaskonly() const;
  void set_updatesbidaskonly(::google::protobuf::uint32 value);

  // optional float StrikePrice = 14;
  bool has_strikeprice() const;
  void clear_strikeprice();
  static const int kStrikePriceFieldNumber = 14;
  float strikeprice() const;
  void set_strikeprice(float value);

  // optional .DTC_PB.PutCallEnum PutOrCall = 15;
  bool has_putorcall() const;
  void clear_putorcall();
  static const int kPutOrCallFieldNumber = 15;
  ::DTC_PB::PutCallEnum putorcall() const;
  void set_putorcall(::DTC_PB::PutCallEnum value);

  // optional uint32 ShortInterest = 16;
  bool has_shortinterest() const;
  void clear_shortinterest();
  static const int kShortInterestFieldNumber = 16;
  ::google::protobuf::uint32 shortinterest() const;
  void set_shortinterest(::google::protobuf::uint32 value);

  // optional sfixed32 SecurityExpirationDate = 17;
  bool has_securityexpirationdate() const;
  void clear_securityexpirationdate();
  static const int kSecurityExpirationDateFieldNumber = 17;
  ::google::protobuf::int32 securityexpirationdate() const;
  void set_securityexpirationdate(::google::protobuf::int32 value);

  // optional float BuyRolloverInterest = 18;
  bool has_buyrolloverinterest() const;
  void clear_buyrolloverinterest();
  static const int kBuyRolloverInterestFieldNumber = 18;
  float buyrolloverinterest() const;
  void set_buyrolloverinterest(float value);

  // optional float SellRolloverInterest = 19;
  bool has_sellrolloverinterest() const;
  void clear_sellrolloverinterest();
  static const int kSellRolloverInterestFieldNumber = 19;
  float sellrolloverinterest() const;
  void set_sellrolloverinterest(float value);

  // optional float EarningsPerShare = 20;
  bool has_earningspershare() const;
  void clear_earningspershare();
  static const int kEarningsPerShareFieldNumber = 20;
  float earningspershare() const;
  void set_earningspershare(float value);

  // optional uint32 SharesOutstanding = 21;
  bool has_sharesoutstanding() const;
  void clear_sharesoutstanding();
  static const int kSharesOutstandingFieldNumber = 21;
  ::google::protobuf::uint32 sharesoutstanding() const;
  void set_sharesoutstanding(::google::protobuf::uint32 value);

  // optional float IntToFloatQuantityDivisor = 22;
  bool has_inttofloatquantitydivisor() const;
  void clear_inttofloatquantitydivisor();
  static const int kIntToFloatQuantityDivisorFieldNumber = 22;
  float inttofloatquantitydivisor() const;
  void set_inttofloatquantitydivisor(float value);

  // optional uint32 HasMarketDepthData = 23;
  bool has_hasmarketdepthdata() const;
  void clear_hasmarketdepthdata();
  static const int kHasMarketDepthDataFieldNumber = 23;
  ::google::protobuf::uint32 hasmarketdepthdata() const;
  void set_hasmarketdepthdata(::google::protobuf::uint32 value);

  // optional float DisplayPriceMultiplier = 24;
  bool has_displaypricemultiplier() const;
  void clear_displaypricemultiplier();
  static const int kDisplayPriceMultiplierFieldNumber = 24;
  float displaypricemultiplier() const;
  void set_displaypricemultiplier(float value);

  // optional float InitialMarginRequirement = 26;
  bool has_initialmarginrequirement() const;
  void clear_initialmarginrequirement();
  static const int kInitialMarginRequirementFieldNumber = 26;
  float initialmarginrequirement() const;
  void set_initialmarginrequirement(float value);

  // optional float MaintenanceMarginRequirement = 27;
  bool has_maintenancemarginrequirement() const;
  void clear_maintenancemarginrequirement();
  static const int kMaintenanceMarginRequirementFieldNumber = 27;
  float maintenancemarginrequirement() const;
  void set_maintenancemarginrequirement(float value);

  // optional .DTC_PB.PriceDisplayFormatEnum PriceDisplayFormat = 7;
  bool has_pricedisplayformat() const;
  void clear_pricedisplayformat();
  static const int kPriceDisplayFormatFieldNumber = 7;
  ::DTC_PB::PriceDisplayFormatEnum pricedisplayformat() const;
  void set_pricedisplayformat(::DTC_PB::PriceDisplayFormatEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SecurityDefinitionResponse)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_securitytype();
  void clear_has_securitytype();
  void set_has_description();
  void clear_has_description();
  void set_has_minpriceincrement();
  void clear_has_minpriceincrement();
  void set_has_pricedisplayformat();
  void clear_has_pricedisplayformat();
  void set_has_currencyvalueperincrement();
  void clear_has_currencyvalueperincrement();
  void set_has_isfinalmessage();
  void clear_has_isfinalmessage();
  void set_has_floattointpricemultiplier();
  void clear_has_floattointpricemultiplier();
  void set_has_inttofloatpricedivisor();
  void clear_has_inttofloatpricedivisor();
  void set_has_underlyingsymbol();
  void clear_has_underlyingsymbol();
  void set_has_updatesbidaskonly();
  void clear_has_updatesbidaskonly();
  void set_has_strikeprice();
  void clear_has_strikeprice();
  void set_has_putorcall();
  void clear_has_putorcall();
  void set_has_shortinterest();
  void clear_has_shortinterest();
  void set_has_securityexpirationdate();
  void clear_has_securityexpirationdate();
  void set_has_buyrolloverinterest();
  void clear_has_buyrolloverinterest();
  void set_has_sellrolloverinterest();
  void clear_has_sellrolloverinterest();
  void set_has_earningspershare();
  void clear_has_earningspershare();
  void set_has_sharesoutstanding();
  void clear_has_sharesoutstanding();
  void set_has_inttofloatquantitydivisor();
  void clear_has_inttofloatquantitydivisor();
  void set_has_hasmarketdepthdata();
  void clear_has_hasmarketdepthdata();
  void set_has_displaypricemultiplier();
  void clear_has_displaypricemultiplier();
  void set_has_exchangesymbol();
  void clear_has_exchangesymbol();
  void set_has_initialmarginrequirement();
  void clear_has_initialmarginrequirement();
  void set_has_maintenancemarginrequirement();
  void clear_has_maintenancemarginrequirement();
  void set_has_currency();
  void clear_has_currency();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr underlyingsymbol_;
  ::google::protobuf::internal::ArenaStringPtr exchangesymbol_;
  ::google::protobuf::internal::ArenaStringPtr currency_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  float minpriceincrement_;
  float currencyvalueperincrement_;
  ::google::protobuf::uint32 isfinalmessage_;
  float floattointpricemultiplier_;
  float inttofloatpricedivisor_;
  ::google::protobuf::uint32 updatesbidaskonly_;
  float strikeprice_;
  int putorcall_;
  ::google::protobuf::uint32 shortinterest_;
  ::google::protobuf::int32 securityexpirationdate_;
  float buyrolloverinterest_;
  float sellrolloverinterest_;
  float earningspershare_;
  ::google::protobuf::uint32 sharesoutstanding_;
  float inttofloatquantitydivisor_;
  ::google::protobuf::uint32 hasmarketdepthdata_;
  float displaypricemultiplier_;
  float initialmarginrequirement_;
  float maintenancemarginrequirement_;
  int pricedisplayformat_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecurityDefinitionReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.SecurityDefinitionReject) */ {
 public:
  SecurityDefinitionReject();
  virtual ~SecurityDefinitionReject();

  SecurityDefinitionReject(const SecurityDefinitionReject& from);

  inline SecurityDefinitionReject& operator=(const SecurityDefinitionReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecurityDefinitionReject(SecurityDefinitionReject&& from) noexcept
    : SecurityDefinitionReject() {
    *this = ::std::move(from);
  }

  inline SecurityDefinitionReject& operator=(SecurityDefinitionReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityDefinitionReject* internal_default_instance() {
    return reinterpret_cast<const SecurityDefinitionReject*>(
               &_SecurityDefinitionReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(SecurityDefinitionReject* other);
  friend void swap(SecurityDefinitionReject& a, SecurityDefinitionReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecurityDefinitionReject* New() const final {
    return CreateMaybeMessage<SecurityDefinitionReject>(NULL);
  }

  SecurityDefinitionReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecurityDefinitionReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SecurityDefinitionReject& from);
  void MergeFrom(const SecurityDefinitionReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityDefinitionReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SecurityDefinitionReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountBalanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.AccountBalanceRequest) */ {
 public:
  AccountBalanceRequest();
  virtual ~AccountBalanceRequest();

  AccountBalanceRequest(const AccountBalanceRequest& from);

  inline AccountBalanceRequest& operator=(const AccountBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountBalanceRequest(AccountBalanceRequest&& from) noexcept
    : AccountBalanceRequest() {
    *this = ::std::move(from);
  }

  inline AccountBalanceRequest& operator=(AccountBalanceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBalanceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const AccountBalanceRequest*>(
               &_AccountBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(AccountBalanceRequest* other);
  friend void swap(AccountBalanceRequest& a, AccountBalanceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountBalanceRequest* New() const final {
    return CreateMaybeMessage<AccountBalanceRequest>(NULL);
  }

  AccountBalanceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountBalanceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountBalanceRequest& from);
  void MergeFrom(const AccountBalanceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountBalanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TradeAccount = 2;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 2;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.AccountBalanceRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountBalanceReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.AccountBalanceReject) */ {
 public:
  AccountBalanceReject();
  virtual ~AccountBalanceReject();

  AccountBalanceReject(const AccountBalanceReject& from);

  inline AccountBalanceReject& operator=(const AccountBalanceReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountBalanceReject(AccountBalanceReject&& from) noexcept
    : AccountBalanceReject() {
    *this = ::std::move(from);
  }

  inline AccountBalanceReject& operator=(AccountBalanceReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBalanceReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountBalanceReject* internal_default_instance() {
    return reinterpret_cast<const AccountBalanceReject*>(
               &_AccountBalanceReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(AccountBalanceReject* other);
  friend void swap(AccountBalanceReject& a, AccountBalanceReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountBalanceReject* New() const final {
    return CreateMaybeMessage<AccountBalanceReject>(NULL);
  }

  AccountBalanceReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountBalanceReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountBalanceReject& from);
  void MergeFrom(const AccountBalanceReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountBalanceReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.AccountBalanceReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountBalanceUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.AccountBalanceUpdate) */ {
 public:
  AccountBalanceUpdate();
  virtual ~AccountBalanceUpdate();

  AccountBalanceUpdate(const AccountBalanceUpdate& from);

  inline AccountBalanceUpdate& operator=(const AccountBalanceUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountBalanceUpdate(AccountBalanceUpdate&& from) noexcept
    : AccountBalanceUpdate() {
    *this = ::std::move(from);
  }

  inline AccountBalanceUpdate& operator=(AccountBalanceUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBalanceUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountBalanceUpdate* internal_default_instance() {
    return reinterpret_cast<const AccountBalanceUpdate*>(
               &_AccountBalanceUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(AccountBalanceUpdate* other);
  friend void swap(AccountBalanceUpdate& a, AccountBalanceUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountBalanceUpdate* New() const final {
    return CreateMaybeMessage<AccountBalanceUpdate>(NULL);
  }

  AccountBalanceUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountBalanceUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountBalanceUpdate& from);
  void MergeFrom(const AccountBalanceUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountBalanceUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string AccountCurrency = 4;
  bool has_accountcurrency() const;
  void clear_accountcurrency();
  static const int kAccountCurrencyFieldNumber = 4;
  const ::std::string& accountcurrency() const;
  void set_accountcurrency(const ::std::string& value);
  #if LANG_CXX11
  void set_accountcurrency(::std::string&& value);
  #endif
  void set_accountcurrency(const char* value);
  void set_accountcurrency(const char* value, size_t size);
  ::std::string* mutable_accountcurrency();
  ::std::string* release_accountcurrency();
  void set_allocated_accountcurrency(::std::string* accountcurrency);

  // optional string TradeAccount = 5;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 5;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string InfoText = 14;
  bool has_infotext() const;
  void clear_infotext();
  static const int kInfoTextFieldNumber = 14;
  const ::std::string& infotext() const;
  void set_infotext(const ::std::string& value);
  #if LANG_CXX11
  void set_infotext(::std::string&& value);
  #endif
  void set_infotext(const char* value);
  void set_infotext(const char* value, size_t size);
  ::std::string* mutable_infotext();
  ::std::string* release_infotext();
  void set_allocated_infotext(::std::string* infotext);

  // optional double CashBalance = 2;
  bool has_cashbalance() const;
  void clear_cashbalance();
  static const int kCashBalanceFieldNumber = 2;
  double cashbalance() const;
  void set_cashbalance(double value);

  // optional double BalanceAvailableForNewPositions = 3;
  bool has_balanceavailablefornewpositions() const;
  void clear_balanceavailablefornewpositions();
  static const int kBalanceAvailableForNewPositionsFieldNumber = 3;
  double balanceavailablefornewpositions() const;
  void set_balanceavailablefornewpositions(double value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumberMessages = 8;
  bool has_totalnumbermessages() const;
  void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 8;
  ::google::protobuf::int32 totalnumbermessages() const;
  void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional double SecuritiesValue = 6;
  bool has_securitiesvalue() const;
  void clear_securitiesvalue();
  static const int kSecuritiesValueFieldNumber = 6;
  double securitiesvalue() const;
  void set_securitiesvalue(double value);

  // optional double MarginRequirement = 7;
  bool has_marginrequirement() const;
  void clear_marginrequirement();
  static const int kMarginRequirementFieldNumber = 7;
  double marginrequirement() const;
  void set_marginrequirement(double value);

  // optional int32 MessageNumber = 9;
  bool has_messagenumber() const;
  void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 9;
  ::google::protobuf::int32 messagenumber() const;
  void set_messagenumber(::google::protobuf::int32 value);

  // optional uint32 NoAccountBalances = 10;
  bool has_noaccountbalances() const;
  void clear_noaccountbalances();
  static const int kNoAccountBalancesFieldNumber = 10;
  ::google::protobuf::uint32 noaccountbalances() const;
  void set_noaccountbalances(::google::protobuf::uint32 value);

  // optional double OpenPositionsProfitLoss = 12;
  bool has_openpositionsprofitloss() const;
  void clear_openpositionsprofitloss();
  static const int kOpenPositionsProfitLossFieldNumber = 12;
  double openpositionsprofitloss() const;
  void set_openpositionsprofitloss(double value);

  // optional double DailyProfitLoss = 13;
  bool has_dailyprofitloss() const;
  void clear_dailyprofitloss();
  static const int kDailyProfitLossFieldNumber = 13;
  double dailyprofitloss() const;
  void set_dailyprofitloss(double value);

  // optional uint32 Unsolicited = 11;
  bool has_unsolicited() const;
  void clear_unsolicited();
  static const int kUnsolicitedFieldNumber = 11;
  ::google::protobuf::uint32 unsolicited() const;
  void set_unsolicited(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.AccountBalanceUpdate)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_cashbalance();
  void clear_has_cashbalance();
  void set_has_balanceavailablefornewpositions();
  void clear_has_balanceavailablefornewpositions();
  void set_has_accountcurrency();
  void clear_has_accountcurrency();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_securitiesvalue();
  void clear_has_securitiesvalue();
  void set_has_marginrequirement();
  void clear_has_marginrequirement();
  void set_has_totalnumbermessages();
  void clear_has_totalnumbermessages();
  void set_has_messagenumber();
  void clear_has_messagenumber();
  void set_has_noaccountbalances();
  void clear_has_noaccountbalances();
  void set_has_unsolicited();
  void clear_has_unsolicited();
  void set_has_openpositionsprofitloss();
  void clear_has_openpositionsprofitloss();
  void set_has_dailyprofitloss();
  void clear_has_dailyprofitloss();
  void set_has_infotext();
  void clear_has_infotext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr accountcurrency_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr infotext_;
  double cashbalance_;
  double balanceavailablefornewpositions_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnumbermessages_;
  double securitiesvalue_;
  double marginrequirement_;
  ::google::protobuf::int32 messagenumber_;
  ::google::protobuf::uint32 noaccountbalances_;
  double openpositionsprofitloss_;
  double dailyprofitloss_;
  ::google::protobuf::uint32 unsolicited_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalAccountBalancesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalAccountBalancesRequest) */ {
 public:
  HistoricalAccountBalancesRequest();
  virtual ~HistoricalAccountBalancesRequest();

  HistoricalAccountBalancesRequest(const HistoricalAccountBalancesRequest& from);

  inline HistoricalAccountBalancesRequest& operator=(const HistoricalAccountBalancesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalAccountBalancesRequest(HistoricalAccountBalancesRequest&& from) noexcept
    : HistoricalAccountBalancesRequest() {
    *this = ::std::move(from);
  }

  inline HistoricalAccountBalancesRequest& operator=(HistoricalAccountBalancesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalAccountBalancesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalAccountBalancesRequest* internal_default_instance() {
    return reinterpret_cast<const HistoricalAccountBalancesRequest*>(
               &_HistoricalAccountBalancesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(HistoricalAccountBalancesRequest* other);
  friend void swap(HistoricalAccountBalancesRequest& a, HistoricalAccountBalancesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalAccountBalancesRequest* New() const final {
    return CreateMaybeMessage<HistoricalAccountBalancesRequest>(NULL);
  }

  HistoricalAccountBalancesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalAccountBalancesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalAccountBalancesRequest& from);
  void MergeFrom(const HistoricalAccountBalancesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalAccountBalancesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TradeAccount = 2;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 2;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional sfixed64 StartDateTime = 3;
  bool has_startdatetime() const;
  void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 3;
  ::google::protobuf::int64 startdatetime() const;
  void set_startdatetime(::google::protobuf::int64 value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalAccountBalancesRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_startdatetime();
  void clear_has_startdatetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::int64 startdatetime_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalAccountBalancesReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalAccountBalancesReject) */ {
 public:
  HistoricalAccountBalancesReject();
  virtual ~HistoricalAccountBalancesReject();

  HistoricalAccountBalancesReject(const HistoricalAccountBalancesReject& from);

  inline HistoricalAccountBalancesReject& operator=(const HistoricalAccountBalancesReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalAccountBalancesReject(HistoricalAccountBalancesReject&& from) noexcept
    : HistoricalAccountBalancesReject() {
    *this = ::std::move(from);
  }

  inline HistoricalAccountBalancesReject& operator=(HistoricalAccountBalancesReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalAccountBalancesReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalAccountBalancesReject* internal_default_instance() {
    return reinterpret_cast<const HistoricalAccountBalancesReject*>(
               &_HistoricalAccountBalancesReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(HistoricalAccountBalancesReject* other);
  friend void swap(HistoricalAccountBalancesReject& a, HistoricalAccountBalancesReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalAccountBalancesReject* New() const final {
    return CreateMaybeMessage<HistoricalAccountBalancesReject>(NULL);
  }

  HistoricalAccountBalancesReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalAccountBalancesReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalAccountBalancesReject& from);
  void MergeFrom(const HistoricalAccountBalancesReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalAccountBalancesReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalAccountBalancesReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalAccountBalanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalAccountBalanceResponse) */ {
 public:
  HistoricalAccountBalanceResponse();
  virtual ~HistoricalAccountBalanceResponse();

  HistoricalAccountBalanceResponse(const HistoricalAccountBalanceResponse& from);

  inline HistoricalAccountBalanceResponse& operator=(const HistoricalAccountBalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalAccountBalanceResponse(HistoricalAccountBalanceResponse&& from) noexcept
    : HistoricalAccountBalanceResponse() {
    *this = ::std::move(from);
  }

  inline HistoricalAccountBalanceResponse& operator=(HistoricalAccountBalanceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalAccountBalanceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalAccountBalanceResponse* internal_default_instance() {
    return reinterpret_cast<const HistoricalAccountBalanceResponse*>(
               &_HistoricalAccountBalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(HistoricalAccountBalanceResponse* other);
  friend void swap(HistoricalAccountBalanceResponse& a, HistoricalAccountBalanceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalAccountBalanceResponse* New() const final {
    return CreateMaybeMessage<HistoricalAccountBalanceResponse>(NULL);
  }

  HistoricalAccountBalanceResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalAccountBalanceResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalAccountBalanceResponse& from);
  void MergeFrom(const HistoricalAccountBalanceResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalAccountBalanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string AccountCurrency = 4;
  bool has_accountcurrency() const;
  void clear_accountcurrency();
  static const int kAccountCurrencyFieldNumber = 4;
  const ::std::string& accountcurrency() const;
  void set_accountcurrency(const ::std::string& value);
  #if LANG_CXX11
  void set_accountcurrency(::std::string&& value);
  #endif
  void set_accountcurrency(const char* value);
  void set_accountcurrency(const char* value, size_t size);
  ::std::string* mutable_accountcurrency();
  ::std::string* release_accountcurrency();
  void set_allocated_accountcurrency(::std::string* accountcurrency);

  // optional string TradeAccount = 5;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 5;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string InfoText = 9;
  bool has_infotext() const;
  void clear_infotext();
  static const int kInfoTextFieldNumber = 9;
  const ::std::string& infotext() const;
  void set_infotext(const ::std::string& value);
  #if LANG_CXX11
  void set_infotext(::std::string&& value);
  #endif
  void set_infotext(const char* value);
  void set_infotext(const char* value, size_t size);
  ::std::string* mutable_infotext();
  ::std::string* release_infotext();
  void set_allocated_infotext(::std::string* infotext);

  // optional string TransactionId = 10;
  bool has_transactionid() const;
  void clear_transactionid();
  static const int kTransactionIdFieldNumber = 10;
  const ::std::string& transactionid() const;
  void set_transactionid(const ::std::string& value);
  #if LANG_CXX11
  void set_transactionid(::std::string&& value);
  #endif
  void set_transactionid(const char* value);
  void set_transactionid(const char* value, size_t size);
  ::std::string* mutable_transactionid();
  ::std::string* release_transactionid();
  void set_allocated_transactionid(::std::string* transactionid);

  // optional double DateTime = 2;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 2;
  double datetime() const;
  void set_datetime(double value);

  // optional double CashBalance = 3;
  bool has_cashbalance() const;
  void clear_cashbalance();
  static const int kCashBalanceFieldNumber = 3;
  double cashbalance() const;
  void set_cashbalance(double value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumberMessages = 6;
  bool has_totalnumbermessages() const;
  void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 6;
  ::google::protobuf::int32 totalnumbermessages() const;
  void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 7;
  bool has_messagenumber() const;
  void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 7;
  ::google::protobuf::int32 messagenumber() const;
  void set_messagenumber(::google::protobuf::int32 value);

  // optional uint32 NoAccountBalances = 8;
  bool has_noaccountbalances() const;
  void clear_noaccountbalances();
  static const int kNoAccountBalancesFieldNumber = 8;
  ::google::protobuf::uint32 noaccountbalances() const;
  void set_noaccountbalances(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalAccountBalanceResponse)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_cashbalance();
  void clear_has_cashbalance();
  void set_has_accountcurrency();
  void clear_has_accountcurrency();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();
  void set_has_totalnumbermessages();
  void clear_has_totalnumbermessages();
  void set_has_messagenumber();
  void clear_has_messagenumber();
  void set_has_noaccountbalances();
  void clear_has_noaccountbalances();
  void set_has_infotext();
  void clear_has_infotext();
  void set_has_transactionid();
  void clear_has_transactionid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr accountcurrency_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  ::google::protobuf::internal::ArenaStringPtr infotext_;
  ::google::protobuf::internal::ArenaStringPtr transactionid_;
  double datetime_;
  double cashbalance_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnumbermessages_;
  ::google::protobuf::int32 messagenumber_;
  ::google::protobuf::uint32 noaccountbalances_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.UserMessage) */ {
 public:
  UserMessage();
  virtual ~UserMessage();

  UserMessage(const UserMessage& from);

  inline UserMessage& operator=(const UserMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserMessage(UserMessage&& from) noexcept
    : UserMessage() {
    *this = ::std::move(from);
  }

  inline UserMessage& operator=(UserMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserMessage* internal_default_instance() {
    return reinterpret_cast<const UserMessage*>(
               &_UserMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(UserMessage* other);
  friend void swap(UserMessage& a, UserMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserMessage* New() const final {
    return CreateMaybeMessage<UserMessage>(NULL);
  }

  UserMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserMessage& from);
  void MergeFrom(const UserMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserMessage = 1;
  bool has_usermessage() const;
  void clear_usermessage();
  static const int kUserMessageFieldNumber = 1;
  const ::std::string& usermessage() const;
  void set_usermessage(const ::std::string& value);
  #if LANG_CXX11
  void set_usermessage(::std::string&& value);
  #endif
  void set_usermessage(const char* value);
  void set_usermessage(const char* value, size_t size);
  ::std::string* mutable_usermessage();
  ::std::string* release_usermessage();
  void set_allocated_usermessage(::std::string* usermessage);

  // optional uint32 IsPopupMessage = 2;
  bool has_ispopupmessage() const;
  void clear_ispopupmessage();
  static const int kIsPopupMessageFieldNumber = 2;
  ::google::protobuf::uint32 ispopupmessage() const;
  void set_ispopupmessage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.UserMessage)
 private:
  void set_has_usermessage();
  void clear_has_usermessage();
  void set_has_ispopupmessage();
  void clear_has_ispopupmessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr usermessage_;
  ::google::protobuf::uint32 ispopupmessage_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GeneralLogMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.GeneralLogMessage) */ {
 public:
  GeneralLogMessage();
  virtual ~GeneralLogMessage();

  GeneralLogMessage(const GeneralLogMessage& from);

  inline GeneralLogMessage& operator=(const GeneralLogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralLogMessage(GeneralLogMessage&& from) noexcept
    : GeneralLogMessage() {
    *this = ::std::move(from);
  }

  inline GeneralLogMessage& operator=(GeneralLogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralLogMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralLogMessage* internal_default_instance() {
    return reinterpret_cast<const GeneralLogMessage*>(
               &_GeneralLogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(GeneralLogMessage* other);
  friend void swap(GeneralLogMessage& a, GeneralLogMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralLogMessage* New() const final {
    return CreateMaybeMessage<GeneralLogMessage>(NULL);
  }

  GeneralLogMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GeneralLogMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GeneralLogMessage& from);
  void MergeFrom(const GeneralLogMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneralLogMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MessageText = 3;
  bool has_messagetext() const;
  void clear_messagetext();
  static const int kMessageTextFieldNumber = 3;
  const ::std::string& messagetext() const;
  void set_messagetext(const ::std::string& value);
  #if LANG_CXX11
  void set_messagetext(::std::string&& value);
  #endif
  void set_messagetext(const char* value);
  void set_messagetext(const char* value, size_t size);
  ::std::string* mutable_messagetext();
  ::std::string* release_messagetext();
  void set_allocated_messagetext(::std::string* messagetext);

  // @@protoc_insertion_point(class_scope:DTC_PB.GeneralLogMessage)
 private:
  void set_has_messagetext();
  void clear_has_messagetext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messagetext_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JournalEntryAdd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.JournalEntryAdd) */ {
 public:
  JournalEntryAdd();
  virtual ~JournalEntryAdd();

  JournalEntryAdd(const JournalEntryAdd& from);

  inline JournalEntryAdd& operator=(const JournalEntryAdd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JournalEntryAdd(JournalEntryAdd&& from) noexcept
    : JournalEntryAdd() {
    *this = ::std::move(from);
  }

  inline JournalEntryAdd& operator=(JournalEntryAdd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JournalEntryAdd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JournalEntryAdd* internal_default_instance() {
    return reinterpret_cast<const JournalEntryAdd*>(
               &_JournalEntryAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(JournalEntryAdd* other);
  friend void swap(JournalEntryAdd& a, JournalEntryAdd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JournalEntryAdd* New() const final {
    return CreateMaybeMessage<JournalEntryAdd>(NULL);
  }

  JournalEntryAdd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JournalEntryAdd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JournalEntryAdd& from);
  void MergeFrom(const JournalEntryAdd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JournalEntryAdd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string JournalEntry = 1;
  bool has_journalentry() const;
  void clear_journalentry();
  static const int kJournalEntryFieldNumber = 1;
  const ::std::string& journalentry() const;
  void set_journalentry(const ::std::string& value);
  #if LANG_CXX11
  void set_journalentry(::std::string&& value);
  #endif
  void set_journalentry(const char* value);
  void set_journalentry(const char* value, size_t size);
  ::std::string* mutable_journalentry();
  ::std::string* release_journalentry();
  void set_allocated_journalentry(::std::string* journalentry);

  // optional sfixed64 DateTime = 2;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 2;
  ::google::protobuf::int64 datetime() const;
  void set_datetime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.JournalEntryAdd)
 private:
  void set_has_journalentry();
  void clear_has_journalentry();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr journalentry_;
  ::google::protobuf::int64 datetime_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JournalEntriesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.JournalEntriesRequest) */ {
 public:
  JournalEntriesRequest();
  virtual ~JournalEntriesRequest();

  JournalEntriesRequest(const JournalEntriesRequest& from);

  inline JournalEntriesRequest& operator=(const JournalEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JournalEntriesRequest(JournalEntriesRequest&& from) noexcept
    : JournalEntriesRequest() {
    *this = ::std::move(from);
  }

  inline JournalEntriesRequest& operator=(JournalEntriesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JournalEntriesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JournalEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const JournalEntriesRequest*>(
               &_JournalEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(JournalEntriesRequest* other);
  friend void swap(JournalEntriesRequest& a, JournalEntriesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JournalEntriesRequest* New() const final {
    return CreateMaybeMessage<JournalEntriesRequest>(NULL);
  }

  JournalEntriesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JournalEntriesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JournalEntriesRequest& from);
  void MergeFrom(const JournalEntriesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JournalEntriesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 StartDateTime = 2;
  bool has_startdatetime() const;
  void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 2;
  ::google::protobuf::int64 startdatetime() const;
  void set_startdatetime(::google::protobuf::int64 value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.JournalEntriesRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_startdatetime();
  void clear_has_startdatetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 startdatetime_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JournalEntriesReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.JournalEntriesReject) */ {
 public:
  JournalEntriesReject();
  virtual ~JournalEntriesReject();

  JournalEntriesReject(const JournalEntriesReject& from);

  inline JournalEntriesReject& operator=(const JournalEntriesReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JournalEntriesReject(JournalEntriesReject&& from) noexcept
    : JournalEntriesReject() {
    *this = ::std::move(from);
  }

  inline JournalEntriesReject& operator=(JournalEntriesReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JournalEntriesReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JournalEntriesReject* internal_default_instance() {
    return reinterpret_cast<const JournalEntriesReject*>(
               &_JournalEntriesReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(JournalEntriesReject* other);
  friend void swap(JournalEntriesReject& a, JournalEntriesReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JournalEntriesReject* New() const final {
    return CreateMaybeMessage<JournalEntriesReject>(NULL);
  }

  JournalEntriesReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JournalEntriesReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JournalEntriesReject& from);
  void MergeFrom(const JournalEntriesReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JournalEntriesReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.JournalEntriesReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JournalEntryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.JournalEntryResponse) */ {
 public:
  JournalEntryResponse();
  virtual ~JournalEntryResponse();

  JournalEntryResponse(const JournalEntryResponse& from);

  inline JournalEntryResponse& operator=(const JournalEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JournalEntryResponse(JournalEntryResponse&& from) noexcept
    : JournalEntryResponse() {
    *this = ::std::move(from);
  }

  inline JournalEntryResponse& operator=(JournalEntryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JournalEntryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JournalEntryResponse* internal_default_instance() {
    return reinterpret_cast<const JournalEntryResponse*>(
               &_JournalEntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(JournalEntryResponse* other);
  friend void swap(JournalEntryResponse& a, JournalEntryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JournalEntryResponse* New() const final {
    return CreateMaybeMessage<JournalEntryResponse>(NULL);
  }

  JournalEntryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JournalEntryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JournalEntryResponse& from);
  void MergeFrom(const JournalEntryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JournalEntryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string JournalEntry = 1;
  bool has_journalentry() const;
  void clear_journalentry();
  static const int kJournalEntryFieldNumber = 1;
  const ::std::string& journalentry() const;
  void set_journalentry(const ::std::string& value);
  #if LANG_CXX11
  void set_journalentry(::std::string&& value);
  #endif
  void set_journalentry(const char* value);
  void set_journalentry(const char* value, size_t size);
  ::std::string* mutable_journalentry();
  ::std::string* release_journalentry();
  void set_allocated_journalentry(::std::string* journalentry);

  // optional sfixed64 DateTime = 2;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 2;
  ::google::protobuf::int64 datetime() const;
  void set_datetime(::google::protobuf::int64 value);

  // optional uint32 IsFinalResponse = 3;
  bool has_isfinalresponse() const;
  void clear_isfinalresponse();
  static const int kIsFinalResponseFieldNumber = 3;
  ::google::protobuf::uint32 isfinalresponse() const;
  void set_isfinalresponse(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.JournalEntryResponse)
 private:
  void set_has_journalentry();
  void clear_has_journalentry();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_isfinalresponse();
  void clear_has_isfinalresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr journalentry_;
  ::google::protobuf::int64 datetime_;
  ::google::protobuf::uint32 isfinalresponse_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AlertMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.AlertMessage) */ {
 public:
  AlertMessage();
  virtual ~AlertMessage();

  AlertMessage(const AlertMessage& from);

  inline AlertMessage& operator=(const AlertMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AlertMessage(AlertMessage&& from) noexcept
    : AlertMessage() {
    *this = ::std::move(from);
  }

  inline AlertMessage& operator=(AlertMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AlertMessage* internal_default_instance() {
    return reinterpret_cast<const AlertMessage*>(
               &_AlertMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(AlertMessage* other);
  friend void swap(AlertMessage& a, AlertMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AlertMessage* New() const final {
    return CreateMaybeMessage<AlertMessage>(NULL);
  }

  AlertMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AlertMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AlertMessage& from);
  void MergeFrom(const AlertMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlertMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MessageText = 3;
  bool has_messagetext() const;
  void clear_messagetext();
  static const int kMessageTextFieldNumber = 3;
  const ::std::string& messagetext() const;
  void set_messagetext(const ::std::string& value);
  #if LANG_CXX11
  void set_messagetext(::std::string&& value);
  #endif
  void set_messagetext(const char* value);
  void set_messagetext(const char* value, size_t size);
  ::std::string* mutable_messagetext();
  ::std::string* release_messagetext();
  void set_allocated_messagetext(::std::string* messagetext);

  // optional string TradeAccount = 4;
  bool has_tradeaccount() const;
  void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 4;
  const ::std::string& tradeaccount() const;
  void set_tradeaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_tradeaccount(::std::string&& value);
  #endif
  void set_tradeaccount(const char* value);
  void set_tradeaccount(const char* value, size_t size);
  ::std::string* mutable_tradeaccount();
  ::std::string* release_tradeaccount();
  void set_allocated_tradeaccount(::std::string* tradeaccount);

  // @@protoc_insertion_point(class_scope:DTC_PB.AlertMessage)
 private:
  void set_has_messagetext();
  void clear_has_messagetext();
  void set_has_tradeaccount();
  void clear_has_tradeaccount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messagetext_;
  ::google::protobuf::internal::ArenaStringPtr tradeaccount_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataRequest) */ {
 public:
  HistoricalPriceDataRequest();
  virtual ~HistoricalPriceDataRequest();

  HistoricalPriceDataRequest(const HistoricalPriceDataRequest& from);

  inline HistoricalPriceDataRequest& operator=(const HistoricalPriceDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataRequest(HistoricalPriceDataRequest&& from) noexcept
    : HistoricalPriceDataRequest() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataRequest& operator=(HistoricalPriceDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataRequest* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataRequest*>(
               &_HistoricalPriceDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(HistoricalPriceDataRequest* other);
  friend void swap(HistoricalPriceDataRequest& a, HistoricalPriceDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataRequest* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataRequest>(NULL);
  }

  HistoricalPriceDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataRequest& from);
  void MergeFrom(const HistoricalPriceDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 2;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 3;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 4;
  bool has_recordinterval() const;
  void clear_recordinterval();
  static const int kRecordIntervalFieldNumber = 4;
  ::DTC_PB::HistoricalDataIntervalEnum recordinterval() const;
  void set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value);

  // optional sfixed64 StartDateTime = 5;
  bool has_startdatetime() const;
  void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 5;
  ::google::protobuf::int64 startdatetime() const;
  void set_startdatetime(::google::protobuf::int64 value);

  // optional sfixed64 EndDateTime = 6;
  bool has_enddatetime() const;
  void clear_enddatetime();
  static const int kEndDateTimeFieldNumber = 6;
  ::google::protobuf::int64 enddatetime() const;
  void set_enddatetime(::google::protobuf::int64 value);

  // optional uint32 MaxDaysToReturn = 7;
  bool has_maxdaystoreturn() const;
  void clear_maxdaystoreturn();
  static const int kMaxDaysToReturnFieldNumber = 7;
  ::google::protobuf::uint32 maxdaystoreturn() const;
  void set_maxdaystoreturn(::google::protobuf::uint32 value);

  // optional uint32 UseZLibCompression = 8;
  bool has_usezlibcompression() const;
  void clear_usezlibcompression();
  static const int kUseZLibCompressionFieldNumber = 8;
  ::google::protobuf::uint32 usezlibcompression() const;
  void set_usezlibcompression(::google::protobuf::uint32 value);

  // optional uint32 RequestDividendAdjustedStockData = 9;
  bool has_requestdividendadjustedstockdata() const;
  void clear_requestdividendadjustedstockdata();
  static const int kRequestDividendAdjustedStockDataFieldNumber = 9;
  ::google::protobuf::uint32 requestdividendadjustedstockdata() const;
  void set_requestdividendadjustedstockdata(::google::protobuf::uint32 value);

  // optional uint32 Flag_1 = 10;
  bool has_flag_1() const;
  void clear_flag_1();
  static const int kFlag1FieldNumber = 10;
  ::google::protobuf::uint32 flag_1() const;
  void set_flag_1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataRequest)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_recordinterval();
  void clear_has_recordinterval();
  void set_has_startdatetime();
  void clear_has_startdatetime();
  void set_has_enddatetime();
  void clear_has_enddatetime();
  void set_has_maxdaystoreturn();
  void clear_has_maxdaystoreturn();
  void set_has_usezlibcompression();
  void clear_has_usezlibcompression();
  void set_has_requestdividendadjustedstockdata();
  void clear_has_requestdividendadjustedstockdata();
  void set_has_flag_1();
  void clear_has_flag_1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  ::google::protobuf::int32 requestid_;
  int recordinterval_;
  ::google::protobuf::int64 startdatetime_;
  ::google::protobuf::int64 enddatetime_;
  ::google::protobuf::uint32 maxdaystoreturn_;
  ::google::protobuf::uint32 usezlibcompression_;
  ::google::protobuf::uint32 requestdividendadjustedstockdata_;
  ::google::protobuf::uint32 flag_1_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataResponseHeader) */ {
 public:
  HistoricalPriceDataResponseHeader();
  virtual ~HistoricalPriceDataResponseHeader();

  HistoricalPriceDataResponseHeader(const HistoricalPriceDataResponseHeader& from);

  inline HistoricalPriceDataResponseHeader& operator=(const HistoricalPriceDataResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataResponseHeader(HistoricalPriceDataResponseHeader&& from) noexcept
    : HistoricalPriceDataResponseHeader() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataResponseHeader& operator=(HistoricalPriceDataResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataResponseHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataResponseHeader* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataResponseHeader*>(
               &_HistoricalPriceDataResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(HistoricalPriceDataResponseHeader* other);
  friend void swap(HistoricalPriceDataResponseHeader& a, HistoricalPriceDataResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataResponseHeader* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataResponseHeader>(NULL);
  }

  HistoricalPriceDataResponseHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataResponseHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataResponseHeader& from);
  void MergeFrom(const HistoricalPriceDataResponseHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 2;
  bool has_recordinterval() const;
  void clear_recordinterval();
  static const int kRecordIntervalFieldNumber = 2;
  ::DTC_PB::HistoricalDataIntervalEnum recordinterval() const;
  void set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value);

  // optional uint32 UseZLibCompression = 3;
  bool has_usezlibcompression() const;
  void clear_usezlibcompression();
  static const int kUseZLibCompressionFieldNumber = 3;
  ::google::protobuf::uint32 usezlibcompression() const;
  void set_usezlibcompression(::google::protobuf::uint32 value);

  // optional uint32 NoRecordsToReturn = 4;
  bool has_norecordstoreturn() const;
  void clear_norecordstoreturn();
  static const int kNoRecordsToReturnFieldNumber = 4;
  ::google::protobuf::uint32 norecordstoreturn() const;
  void set_norecordstoreturn(::google::protobuf::uint32 value);

  // optional float IntToFloatPriceDivisor = 5;
  bool has_inttofloatpricedivisor() const;
  void clear_inttofloatpricedivisor();
  static const int kIntToFloatPriceDivisorFieldNumber = 5;
  float inttofloatpricedivisor() const;
  void set_inttofloatpricedivisor(float value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataResponseHeader)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_recordinterval();
  void clear_has_recordinterval();
  void set_has_usezlibcompression();
  void clear_has_usezlibcompression();
  void set_has_norecordstoreturn();
  void clear_has_norecordstoreturn();
  void set_has_inttofloatpricedivisor();
  void clear_has_inttofloatpricedivisor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 requestid_;
  int recordinterval_;
  ::google::protobuf::uint32 usezlibcompression_;
  ::google::protobuf::uint32 norecordstoreturn_;
  float inttofloatpricedivisor_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataReject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataReject) */ {
 public:
  HistoricalPriceDataReject();
  virtual ~HistoricalPriceDataReject();

  HistoricalPriceDataReject(const HistoricalPriceDataReject& from);

  inline HistoricalPriceDataReject& operator=(const HistoricalPriceDataReject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataReject(HistoricalPriceDataReject&& from) noexcept
    : HistoricalPriceDataReject() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataReject& operator=(HistoricalPriceDataReject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataReject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataReject* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataReject*>(
               &_HistoricalPriceDataReject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(HistoricalPriceDataReject* other);
  friend void swap(HistoricalPriceDataReject& a, HistoricalPriceDataReject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataReject* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataReject>(NULL);
  }

  HistoricalPriceDataReject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataReject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataReject& from);
  void MergeFrom(const HistoricalPriceDataReject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataReject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RejectText = 2;
  bool has_rejecttext() const;
  void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  const ::std::string& rejecttext() const;
  void set_rejecttext(const ::std::string& value);
  #if LANG_CXX11
  void set_rejecttext(::std::string&& value);
  #endif
  void set_rejecttext(const char* value);
  void set_rejecttext(const char* value, size_t size);
  ::std::string* mutable_rejecttext();
  ::std::string* release_rejecttext();
  void set_allocated_rejecttext(::std::string* rejecttext);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.HistoricalPriceDataRejectReasonCodeEnum RejectReasonCode = 3;
  bool has_rejectreasoncode() const;
  void clear_rejectreasoncode();
  static const int kRejectReasonCodeFieldNumber = 3;
  ::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum rejectreasoncode() const;
  void set_rejectreasoncode(::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum value);

  // optional uint32 RetryTimeInSeconds = 4;
  bool has_retrytimeinseconds() const;
  void clear_retrytimeinseconds();
  static const int kRetryTimeInSecondsFieldNumber = 4;
  ::google::protobuf::uint32 retrytimeinseconds() const;
  void set_retrytimeinseconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataReject)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_rejecttext();
  void clear_has_rejecttext();
  void set_has_rejectreasoncode();
  void clear_has_rejectreasoncode();
  void set_has_retrytimeinseconds();
  void clear_has_retrytimeinseconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rejecttext_;
  ::google::protobuf::int32 requestid_;
  int rejectreasoncode_;
  ::google::protobuf::uint32 retrytimeinseconds_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataRecordResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataRecordResponse) */ {
 public:
  HistoricalPriceDataRecordResponse();
  virtual ~HistoricalPriceDataRecordResponse();

  HistoricalPriceDataRecordResponse(const HistoricalPriceDataRecordResponse& from);

  inline HistoricalPriceDataRecordResponse& operator=(const HistoricalPriceDataRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataRecordResponse(HistoricalPriceDataRecordResponse&& from) noexcept
    : HistoricalPriceDataRecordResponse() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataRecordResponse& operator=(HistoricalPriceDataRecordResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataRecordResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataRecordResponse* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataRecordResponse*>(
               &_HistoricalPriceDataRecordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  void Swap(HistoricalPriceDataRecordResponse* other);
  friend void swap(HistoricalPriceDataRecordResponse& a, HistoricalPriceDataRecordResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataRecordResponse* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataRecordResponse>(NULL);
  }

  HistoricalPriceDataRecordResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataRecordResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataRecordResponse& from);
  void MergeFrom(const HistoricalPriceDataRecordResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataRecordResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 StartDateTime = 2;
  bool has_startdatetime() const;
  void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 2;
  ::google::protobuf::int64 startdatetime() const;
  void set_startdatetime(::google::protobuf::int64 value);

  // optional double OpenPrice = 3;
  bool has_openprice() const;
  void clear_openprice();
  static const int kOpenPriceFieldNumber = 3;
  double openprice() const;
  void set_openprice(double value);

  // optional double HighPrice = 4;
  bool has_highprice() const;
  void clear_highprice();
  static const int kHighPriceFieldNumber = 4;
  double highprice() const;
  void set_highprice(double value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional uint32 NumTrades = 8;
  bool has_numtrades() const;
  void clear_numtrades();
  static const int kNumTradesFieldNumber = 8;
  ::google::protobuf::uint32 numtrades() const;
  void set_numtrades(::google::protobuf::uint32 value);

  // optional double LowPrice = 5;
  bool has_lowprice() const;
  void clear_lowprice();
  static const int kLowPriceFieldNumber = 5;
  double lowprice() const;
  void set_lowprice(double value);

  // optional double LastPrice = 6;
  bool has_lastprice() const;
  void clear_lastprice();
  static const int kLastPriceFieldNumber = 6;
  double lastprice() const;
  void set_lastprice(double value);

  // optional double Volume = 7;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 7;
  double volume() const;
  void set_volume(double value);

  // optional double BidVolume = 9;
  bool has_bidvolume() const;
  void clear_bidvolume();
  static const int kBidVolumeFieldNumber = 9;
  double bidvolume() const;
  void set_bidvolume(double value);

  // optional double AskVolume = 10;
  bool has_askvolume() const;
  void clear_askvolume();
  static const int kAskVolumeFieldNumber = 10;
  double askvolume() const;
  void set_askvolume(double value);

  // optional uint32 IsFinalRecord = 11;
  bool has_isfinalrecord() const;
  void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 11;
  ::google::protobuf::uint32 isfinalrecord() const;
  void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataRecordResponse)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_startdatetime();
  void clear_has_startdatetime();
  void set_has_openprice();
  void clear_has_openprice();
  void set_has_highprice();
  void clear_has_highprice();
  void set_has_lowprice();
  void clear_has_lowprice();
  void set_has_lastprice();
  void clear_has_lastprice();
  void set_has_volume();
  void clear_has_volume();
  void set_has_numtrades();
  void clear_has_numtrades();
  void set_has_bidvolume();
  void clear_has_bidvolume();
  void set_has_askvolume();
  void clear_has_askvolume();
  void set_has_isfinalrecord();
  void clear_has_isfinalrecord();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 startdatetime_;
  double openprice_;
  double highprice_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::uint32 numtrades_;
  double lowprice_;
  double lastprice_;
  double volume_;
  double bidvolume_;
  double askvolume_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataTickRecordResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataTickRecordResponse) */ {
 public:
  HistoricalPriceDataTickRecordResponse();
  virtual ~HistoricalPriceDataTickRecordResponse();

  HistoricalPriceDataTickRecordResponse(const HistoricalPriceDataTickRecordResponse& from);

  inline HistoricalPriceDataTickRecordResponse& operator=(const HistoricalPriceDataTickRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataTickRecordResponse(HistoricalPriceDataTickRecordResponse&& from) noexcept
    : HistoricalPriceDataTickRecordResponse() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataTickRecordResponse& operator=(HistoricalPriceDataTickRecordResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataTickRecordResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataTickRecordResponse* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataTickRecordResponse*>(
               &_HistoricalPriceDataTickRecordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  void Swap(HistoricalPriceDataTickRecordResponse* other);
  friend void swap(HistoricalPriceDataTickRecordResponse& a, HistoricalPriceDataTickRecordResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataTickRecordResponse* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataTickRecordResponse>(NULL);
  }

  HistoricalPriceDataTickRecordResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataTickRecordResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataTickRecordResponse& from);
  void MergeFrom(const HistoricalPriceDataTickRecordResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataTickRecordResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double DateTime = 2;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 2;
  double datetime() const;
  void set_datetime(double value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 3;
  bool has_atbidorask() const;
  void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 3;
  ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  double price() const;
  void set_price(double value);

  // optional double Volume = 5;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 5;
  double volume() const;
  void set_volume(double value);

  // optional uint32 IsFinalRecord = 6;
  bool has_isfinalrecord() const;
  void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 6;
  ::google::protobuf::uint32 isfinalrecord() const;
  void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataTickRecordResponse)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_atbidorask();
  void clear_has_atbidorask();
  void set_has_price();
  void clear_has_price();
  void set_has_volume();
  void clear_has_volume();
  void set_has_isfinalrecord();
  void clear_has_isfinalrecord();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double datetime_;
  ::google::protobuf::int32 requestid_;
  int atbidorask_;
  double price_;
  double volume_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataRecordResponse_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataRecordResponse_Int) */ {
 public:
  HistoricalPriceDataRecordResponse_Int();
  virtual ~HistoricalPriceDataRecordResponse_Int();

  HistoricalPriceDataRecordResponse_Int(const HistoricalPriceDataRecordResponse_Int& from);

  inline HistoricalPriceDataRecordResponse_Int& operator=(const HistoricalPriceDataRecordResponse_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataRecordResponse_Int(HistoricalPriceDataRecordResponse_Int&& from) noexcept
    : HistoricalPriceDataRecordResponse_Int() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataRecordResponse_Int& operator=(HistoricalPriceDataRecordResponse_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataRecordResponse_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataRecordResponse_Int* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataRecordResponse_Int*>(
               &_HistoricalPriceDataRecordResponse_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  void Swap(HistoricalPriceDataRecordResponse_Int* other);
  friend void swap(HistoricalPriceDataRecordResponse_Int& a, HistoricalPriceDataRecordResponse_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataRecordResponse_Int* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataRecordResponse_Int>(NULL);
  }

  HistoricalPriceDataRecordResponse_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataRecordResponse_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataRecordResponse_Int& from);
  void MergeFrom(const HistoricalPriceDataRecordResponse_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataRecordResponse_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 StartDateTime = 2;
  bool has_startdatetime() const;
  void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 2;
  ::google::protobuf::int64 startdatetime() const;
  void set_startdatetime(::google::protobuf::int64 value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 OpenPrice = 3;
  bool has_openprice() const;
  void clear_openprice();
  static const int kOpenPriceFieldNumber = 3;
  ::google::protobuf::int32 openprice() const;
  void set_openprice(::google::protobuf::int32 value);

  // optional int32 HighPrice = 4;
  bool has_highprice() const;
  void clear_highprice();
  static const int kHighPriceFieldNumber = 4;
  ::google::protobuf::int32 highprice() const;
  void set_highprice(::google::protobuf::int32 value);

  // optional int32 LowPrice = 5;
  bool has_lowprice() const;
  void clear_lowprice();
  static const int kLowPriceFieldNumber = 5;
  ::google::protobuf::int32 lowprice() const;
  void set_lowprice(::google::protobuf::int32 value);

  // optional int32 LastPrice = 6;
  bool has_lastprice() const;
  void clear_lastprice();
  static const int kLastPriceFieldNumber = 6;
  ::google::protobuf::int32 lastprice() const;
  void set_lastprice(::google::protobuf::int32 value);

  // optional int32 Volume = 7;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 7;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // optional uint32 NumTrades = 8;
  bool has_numtrades() const;
  void clear_numtrades();
  static const int kNumTradesFieldNumber = 8;
  ::google::protobuf::uint32 numtrades() const;
  void set_numtrades(::google::protobuf::uint32 value);

  // optional int32 BidVolume = 9;
  bool has_bidvolume() const;
  void clear_bidvolume();
  static const int kBidVolumeFieldNumber = 9;
  ::google::protobuf::int32 bidvolume() const;
  void set_bidvolume(::google::protobuf::int32 value);

  // optional int32 AskVolume = 10;
  bool has_askvolume() const;
  void clear_askvolume();
  static const int kAskVolumeFieldNumber = 10;
  ::google::protobuf::int32 askvolume() const;
  void set_askvolume(::google::protobuf::int32 value);

  // optional uint32 IsFinalRecord = 11;
  bool has_isfinalrecord() const;
  void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 11;
  ::google::protobuf::uint32 isfinalrecord() const;
  void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataRecordResponse_Int)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_startdatetime();
  void clear_has_startdatetime();
  void set_has_openprice();
  void clear_has_openprice();
  void set_has_highprice();
  void clear_has_highprice();
  void set_has_lowprice();
  void clear_has_lowprice();
  void set_has_lastprice();
  void clear_has_lastprice();
  void set_has_volume();
  void clear_has_volume();
  void set_has_numtrades();
  void clear_has_numtrades();
  void set_has_bidvolume();
  void clear_has_bidvolume();
  void set_has_askvolume();
  void clear_has_askvolume();
  void set_has_isfinalrecord();
  void clear_has_isfinalrecord();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 startdatetime_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 openprice_;
  ::google::protobuf::int32 highprice_;
  ::google::protobuf::int32 lowprice_;
  ::google::protobuf::int32 lastprice_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::uint32 numtrades_;
  ::google::protobuf::int32 bidvolume_;
  ::google::protobuf::int32 askvolume_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataTickRecordResponse_Int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataTickRecordResponse_Int) */ {
 public:
  HistoricalPriceDataTickRecordResponse_Int();
  virtual ~HistoricalPriceDataTickRecordResponse_Int();

  HistoricalPriceDataTickRecordResponse_Int(const HistoricalPriceDataTickRecordResponse_Int& from);

  inline HistoricalPriceDataTickRecordResponse_Int& operator=(const HistoricalPriceDataTickRecordResponse_Int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataTickRecordResponse_Int(HistoricalPriceDataTickRecordResponse_Int&& from) noexcept
    : HistoricalPriceDataTickRecordResponse_Int() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataTickRecordResponse_Int& operator=(HistoricalPriceDataTickRecordResponse_Int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataTickRecordResponse_Int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataTickRecordResponse_Int* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataTickRecordResponse_Int*>(
               &_HistoricalPriceDataTickRecordResponse_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  void Swap(HistoricalPriceDataTickRecordResponse_Int* other);
  friend void swap(HistoricalPriceDataTickRecordResponse_Int& a, HistoricalPriceDataTickRecordResponse_Int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataTickRecordResponse_Int* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataTickRecordResponse_Int>(NULL);
  }

  HistoricalPriceDataTickRecordResponse_Int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataTickRecordResponse_Int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataTickRecordResponse_Int& from);
  void MergeFrom(const HistoricalPriceDataTickRecordResponse_Int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataTickRecordResponse_Int* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double DateTime = 2;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 2;
  double datetime() const;
  void set_datetime(double value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // optional int32 Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional int32 Volume = 4;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
  bool has_atbidorask() const;
  void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 5;
  ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional uint32 IsFinalRecord = 6;
  bool has_isfinalrecord() const;
  void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 6;
  ::google::protobuf::uint32 isfinalrecord() const;
  void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataTickRecordResponse_Int)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_datetime();
  void clear_has_datetime();
  void set_has_price();
  void clear_has_price();
  void set_has_volume();
  void clear_has_volume();
  void set_has_atbidorask();
  void clear_has_atbidorask();
  void set_has_isfinalrecord();
  void clear_has_isfinalrecord();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double datetime_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 volume_;
  int atbidorask_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoricalPriceDataResponseTrailer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DTC_PB.HistoricalPriceDataResponseTrailer) */ {
 public:
  HistoricalPriceDataResponseTrailer();
  virtual ~HistoricalPriceDataResponseTrailer();

  HistoricalPriceDataResponseTrailer(const HistoricalPriceDataResponseTrailer& from);

  inline HistoricalPriceDataResponseTrailer& operator=(const HistoricalPriceDataResponseTrailer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoricalPriceDataResponseTrailer(HistoricalPriceDataResponseTrailer&& from) noexcept
    : HistoricalPriceDataResponseTrailer() {
    *this = ::std::move(from);
  }

  inline HistoricalPriceDataResponseTrailer& operator=(HistoricalPriceDataResponseTrailer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataResponseTrailer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoricalPriceDataResponseTrailer* internal_default_instance() {
    return reinterpret_cast<const HistoricalPriceDataResponseTrailer*>(
               &_HistoricalPriceDataResponseTrailer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  void Swap(HistoricalPriceDataResponseTrailer* other);
  friend void swap(HistoricalPriceDataResponseTrailer& a, HistoricalPriceDataResponseTrailer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoricalPriceDataResponseTrailer* New() const final {
    return CreateMaybeMessage<HistoricalPriceDataResponseTrailer>(NULL);
  }

  HistoricalPriceDataResponseTrailer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoricalPriceDataResponseTrailer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoricalPriceDataResponseTrailer& from);
  void MergeFrom(const HistoricalPriceDataResponseTrailer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalPriceDataResponseTrailer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double FinalRecordLastDateTime = 2;
  bool has_finalrecordlastdatetime() const;
  void clear_finalrecordlastdatetime();
  static const int kFinalRecordLastDateTimeFieldNumber = 2;
  double finalrecordlastdatetime() const;
  void set_finalrecordlastdatetime(double value);

  // optional int32 RequestID = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataResponseTrailer)
 private:
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_finalrecordlastdatetime();
  void clear_has_finalrecordlastdatetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double finalrecordlastdatetime_;
  ::google::protobuf::int32 requestid_;
  friend struct ::protobuf_DTCProtocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EncodingRequest

// optional int32 ProtocolVersion = 1;
inline bool EncodingRequest::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncodingRequest::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncodingRequest::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncodingRequest::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 EncodingRequest::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingRequest.ProtocolVersion)
  return protocolversion_;
}
inline void EncodingRequest::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingRequest.ProtocolVersion)
}

// optional .DTC_PB.EncodingEnum Encoding = 2;
inline bool EncodingRequest::has_encoding() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncodingRequest::set_has_encoding() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncodingRequest::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncodingRequest::clear_encoding() {
  encoding_ = 0;
  clear_has_encoding();
}
inline ::DTC_PB::EncodingEnum EncodingRequest::encoding() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingRequest.Encoding)
  return static_cast< ::DTC_PB::EncodingEnum >(encoding_);
}
inline void EncodingRequest::set_encoding(::DTC_PB::EncodingEnum value) {
  assert(::DTC_PB::EncodingEnum_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingRequest.Encoding)
}

// optional string ProtocolType = 3;
inline bool EncodingRequest::has_protocoltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncodingRequest::set_has_protocoltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncodingRequest::clear_has_protocoltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncodingRequest::clear_protocoltype() {
  protocoltype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocoltype();
}
inline const ::std::string& EncodingRequest::protocoltype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingRequest.ProtocolType)
  return protocoltype_.GetNoArena();
}
inline void EncodingRequest::set_protocoltype(const ::std::string& value) {
  set_has_protocoltype();
  protocoltype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingRequest.ProtocolType)
}
#if LANG_CXX11
inline void EncodingRequest::set_protocoltype(::std::string&& value) {
  set_has_protocoltype();
  protocoltype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.EncodingRequest.ProtocolType)
}
#endif
inline void EncodingRequest::set_protocoltype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocoltype();
  protocoltype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.EncodingRequest.ProtocolType)
}
inline void EncodingRequest::set_protocoltype(const char* value, size_t size) {
  set_has_protocoltype();
  protocoltype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.EncodingRequest.ProtocolType)
}
inline ::std::string* EncodingRequest::mutable_protocoltype() {
  set_has_protocoltype();
  // @@protoc_insertion_point(field_mutable:DTC_PB.EncodingRequest.ProtocolType)
  return protocoltype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncodingRequest::release_protocoltype() {
  // @@protoc_insertion_point(field_release:DTC_PB.EncodingRequest.ProtocolType)
  if (!has_protocoltype()) {
    return NULL;
  }
  clear_has_protocoltype();
  return protocoltype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncodingRequest::set_allocated_protocoltype(::std::string* protocoltype) {
  if (protocoltype != NULL) {
    set_has_protocoltype();
  } else {
    clear_has_protocoltype();
  }
  protocoltype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocoltype);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.EncodingRequest.ProtocolType)
}

// -------------------------------------------------------------------

// EncodingResponse

// optional int32 ProtocolVersion = 1;
inline bool EncodingResponse::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncodingResponse::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncodingResponse::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncodingResponse::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 EncodingResponse::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingResponse.ProtocolVersion)
  return protocolversion_;
}
inline void EncodingResponse::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingResponse.ProtocolVersion)
}

// optional .DTC_PB.EncodingEnum Encoding = 2;
inline bool EncodingResponse::has_encoding() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncodingResponse::set_has_encoding() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncodingResponse::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncodingResponse::clear_encoding() {
  encoding_ = 0;
  clear_has_encoding();
}
inline ::DTC_PB::EncodingEnum EncodingResponse::encoding() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingResponse.Encoding)
  return static_cast< ::DTC_PB::EncodingEnum >(encoding_);
}
inline void EncodingResponse::set_encoding(::DTC_PB::EncodingEnum value) {
  assert(::DTC_PB::EncodingEnum_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingResponse.Encoding)
}

// optional string ProtocolType = 3;
inline bool EncodingResponse::has_protocoltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncodingResponse::set_has_protocoltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncodingResponse::clear_has_protocoltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncodingResponse::clear_protocoltype() {
  protocoltype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocoltype();
}
inline const ::std::string& EncodingResponse::protocoltype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingResponse.ProtocolType)
  return protocoltype_.GetNoArena();
}
inline void EncodingResponse::set_protocoltype(const ::std::string& value) {
  set_has_protocoltype();
  protocoltype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingResponse.ProtocolType)
}
#if LANG_CXX11
inline void EncodingResponse::set_protocoltype(::std::string&& value) {
  set_has_protocoltype();
  protocoltype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.EncodingResponse.ProtocolType)
}
#endif
inline void EncodingResponse::set_protocoltype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocoltype();
  protocoltype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.EncodingResponse.ProtocolType)
}
inline void EncodingResponse::set_protocoltype(const char* value, size_t size) {
  set_has_protocoltype();
  protocoltype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.EncodingResponse.ProtocolType)
}
inline ::std::string* EncodingResponse::mutable_protocoltype() {
  set_has_protocoltype();
  // @@protoc_insertion_point(field_mutable:DTC_PB.EncodingResponse.ProtocolType)
  return protocoltype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncodingResponse::release_protocoltype() {
  // @@protoc_insertion_point(field_release:DTC_PB.EncodingResponse.ProtocolType)
  if (!has_protocoltype()) {
    return NULL;
  }
  clear_has_protocoltype();
  return protocoltype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncodingResponse::set_allocated_protocoltype(::std::string* protocoltype) {
  if (protocoltype != NULL) {
    set_has_protocoltype();
  } else {
    clear_has_protocoltype();
  }
  protocoltype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocoltype);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.EncodingResponse.ProtocolType)
}

// -------------------------------------------------------------------

// LogonRequest

// optional int32 ProtocolVersion = 1;
inline bool LogonRequest::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogonRequest::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogonRequest::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogonRequest::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 LogonRequest::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.ProtocolVersion)
  return protocolversion_;
}
inline void LogonRequest::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.ProtocolVersion)
}

// optional string Username = 2;
inline bool LogonRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogonRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogonRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogonRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& LogonRequest::username() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Username)
  return username_.GetNoArena();
}
inline void LogonRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Username)
}
#if LANG_CXX11
inline void LogonRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonRequest.Username)
}
#endif
inline void LogonRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.Username)
}
inline void LogonRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.Username)
}
inline ::std::string* LogonRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.Username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonRequest::release_username() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonRequest.Username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.Username)
}

// optional string Password = 3;
inline bool LogonRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogonRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogonRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogonRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& LogonRequest::password() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Password)
  return password_.GetNoArena();
}
inline void LogonRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Password)
}
#if LANG_CXX11
inline void LogonRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonRequest.Password)
}
#endif
inline void LogonRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.Password)
}
inline void LogonRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.Password)
}
inline ::std::string* LogonRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonRequest::release_password() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonRequest.Password)
  if (!has_password()) {
    return NULL;
  }
  clear_has_password();
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.Password)
}

// optional string GeneralTextData = 4;
inline bool LogonRequest::has_generaltextdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogonRequest::set_has_generaltextdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogonRequest::clear_has_generaltextdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogonRequest::clear_generaltextdata() {
  generaltextdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_generaltextdata();
}
inline const ::std::string& LogonRequest::generaltextdata() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.GeneralTextData)
  return generaltextdata_.GetNoArena();
}
inline void LogonRequest::set_generaltextdata(const ::std::string& value) {
  set_has_generaltextdata();
  generaltextdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.GeneralTextData)
}
#if LANG_CXX11
inline void LogonRequest::set_generaltextdata(::std::string&& value) {
  set_has_generaltextdata();
  generaltextdata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonRequest.GeneralTextData)
}
#endif
inline void LogonRequest::set_generaltextdata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_generaltextdata();
  generaltextdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.GeneralTextData)
}
inline void LogonRequest::set_generaltextdata(const char* value, size_t size) {
  set_has_generaltextdata();
  generaltextdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.GeneralTextData)
}
inline ::std::string* LogonRequest::mutable_generaltextdata() {
  set_has_generaltextdata();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.GeneralTextData)
  return generaltextdata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonRequest::release_generaltextdata() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonRequest.GeneralTextData)
  if (!has_generaltextdata()) {
    return NULL;
  }
  clear_has_generaltextdata();
  return generaltextdata_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonRequest::set_allocated_generaltextdata(::std::string* generaltextdata) {
  if (generaltextdata != NULL) {
    set_has_generaltextdata();
  } else {
    clear_has_generaltextdata();
  }
  generaltextdata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generaltextdata);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.GeneralTextData)
}

// optional int32 Integer_1 = 5;
inline bool LogonRequest::has_integer_1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogonRequest::set_has_integer_1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogonRequest::clear_has_integer_1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogonRequest::clear_integer_1() {
  integer_1_ = 0;
  clear_has_integer_1();
}
inline ::google::protobuf::int32 LogonRequest::integer_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Integer_1)
  return integer_1_;
}
inline void LogonRequest::set_integer_1(::google::protobuf::int32 value) {
  set_has_integer_1();
  integer_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Integer_1)
}

// optional int32 Integer_2 = 6;
inline bool LogonRequest::has_integer_2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LogonRequest::set_has_integer_2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LogonRequest::clear_has_integer_2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LogonRequest::clear_integer_2() {
  integer_2_ = 0;
  clear_has_integer_2();
}
inline ::google::protobuf::int32 LogonRequest::integer_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Integer_2)
  return integer_2_;
}
inline void LogonRequest::set_integer_2(::google::protobuf::int32 value) {
  set_has_integer_2();
  integer_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Integer_2)
}

// optional int32 HeartbeatIntervalInSeconds = 7;
inline bool LogonRequest::has_heartbeatintervalinseconds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LogonRequest::set_has_heartbeatintervalinseconds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LogonRequest::clear_has_heartbeatintervalinseconds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LogonRequest::clear_heartbeatintervalinseconds() {
  heartbeatintervalinseconds_ = 0;
  clear_has_heartbeatintervalinseconds();
}
inline ::google::protobuf::int32 LogonRequest::heartbeatintervalinseconds() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.HeartbeatIntervalInSeconds)
  return heartbeatintervalinseconds_;
}
inline void LogonRequest::set_heartbeatintervalinseconds(::google::protobuf::int32 value) {
  set_has_heartbeatintervalinseconds();
  heartbeatintervalinseconds_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.HeartbeatIntervalInSeconds)
}

// optional .DTC_PB.TradeModeEnum TradeMode = 8;
inline bool LogonRequest::has_trademode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LogonRequest::set_has_trademode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LogonRequest::clear_has_trademode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LogonRequest::clear_trademode() {
  trademode_ = 0;
  clear_has_trademode();
}
inline ::DTC_PB::TradeModeEnum LogonRequest::trademode() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.TradeMode)
  return static_cast< ::DTC_PB::TradeModeEnum >(trademode_);
}
inline void LogonRequest::set_trademode(::DTC_PB::TradeModeEnum value) {
  assert(::DTC_PB::TradeModeEnum_IsValid(value));
  set_has_trademode();
  trademode_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.TradeMode)
}

// optional string TradeAccount = 9;
inline bool LogonRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogonRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogonRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogonRequest::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& LogonRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void LogonRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.TradeAccount)
}
#if LANG_CXX11
inline void LogonRequest::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonRequest.TradeAccount)
}
#endif
inline void LogonRequest::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.TradeAccount)
}
inline void LogonRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.TradeAccount)
}
inline ::std::string* LogonRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonRequest::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonRequest.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.TradeAccount)
}

// optional string HardwareIdentifier = 10;
inline bool LogonRequest::has_hardwareidentifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogonRequest::set_has_hardwareidentifier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogonRequest::clear_has_hardwareidentifier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogonRequest::clear_hardwareidentifier() {
  hardwareidentifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardwareidentifier();
}
inline const ::std::string& LogonRequest::hardwareidentifier() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.HardwareIdentifier)
  return hardwareidentifier_.GetNoArena();
}
inline void LogonRequest::set_hardwareidentifier(const ::std::string& value) {
  set_has_hardwareidentifier();
  hardwareidentifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.HardwareIdentifier)
}
#if LANG_CXX11
inline void LogonRequest::set_hardwareidentifier(::std::string&& value) {
  set_has_hardwareidentifier();
  hardwareidentifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonRequest.HardwareIdentifier)
}
#endif
inline void LogonRequest::set_hardwareidentifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hardwareidentifier();
  hardwareidentifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.HardwareIdentifier)
}
inline void LogonRequest::set_hardwareidentifier(const char* value, size_t size) {
  set_has_hardwareidentifier();
  hardwareidentifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.HardwareIdentifier)
}
inline ::std::string* LogonRequest::mutable_hardwareidentifier() {
  set_has_hardwareidentifier();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.HardwareIdentifier)
  return hardwareidentifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonRequest::release_hardwareidentifier() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonRequest.HardwareIdentifier)
  if (!has_hardwareidentifier()) {
    return NULL;
  }
  clear_has_hardwareidentifier();
  return hardwareidentifier_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonRequest::set_allocated_hardwareidentifier(::std::string* hardwareidentifier) {
  if (hardwareidentifier != NULL) {
    set_has_hardwareidentifier();
  } else {
    clear_has_hardwareidentifier();
  }
  hardwareidentifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardwareidentifier);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.HardwareIdentifier)
}

// optional string ClientName = 11;
inline bool LogonRequest::has_clientname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogonRequest::set_has_clientname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogonRequest::clear_has_clientname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogonRequest::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientname();
}
inline const ::std::string& LogonRequest::clientname() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.ClientName)
  return clientname_.GetNoArena();
}
inline void LogonRequest::set_clientname(const ::std::string& value) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.ClientName)
}
#if LANG_CXX11
inline void LogonRequest::set_clientname(::std::string&& value) {
  set_has_clientname();
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonRequest.ClientName)
}
#endif
inline void LogonRequest::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.ClientName)
}
inline void LogonRequest::set_clientname(const char* value, size_t size) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.ClientName)
}
inline ::std::string* LogonRequest::mutable_clientname() {
  set_has_clientname();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.ClientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonRequest.ClientName)
  if (!has_clientname()) {
    return NULL;
  }
  clear_has_clientname();
  return clientname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonRequest::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    set_has_clientname();
  } else {
    clear_has_clientname();
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.ClientName)
}

// -------------------------------------------------------------------

// LogonResponse

// optional int32 ProtocolVersion = 1;
inline bool LogonResponse::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogonResponse::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogonResponse::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogonResponse::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 LogonResponse::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ProtocolVersion)
  return protocolversion_;
}
inline void LogonResponse::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ProtocolVersion)
}

// optional .DTC_PB.LogonStatusEnum Result = 2;
inline bool LogonResponse::has_result() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LogonResponse::set_has_result() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LogonResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LogonResponse::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::DTC_PB::LogonStatusEnum LogonResponse::result() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.Result)
  return static_cast< ::DTC_PB::LogonStatusEnum >(result_);
}
inline void LogonResponse::set_result(::DTC_PB::LogonStatusEnum value) {
  assert(::DTC_PB::LogonStatusEnum_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.Result)
}

// optional string ResultText = 3;
inline bool LogonResponse::has_resulttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogonResponse::set_has_resulttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogonResponse::clear_has_resulttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogonResponse::clear_resulttext() {
  resulttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_resulttext();
}
inline const ::std::string& LogonResponse::resulttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ResultText)
  return resulttext_.GetNoArena();
}
inline void LogonResponse::set_resulttext(const ::std::string& value) {
  set_has_resulttext();
  resulttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ResultText)
}
#if LANG_CXX11
inline void LogonResponse::set_resulttext(::std::string&& value) {
  set_has_resulttext();
  resulttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonResponse.ResultText)
}
#endif
inline void LogonResponse::set_resulttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_resulttext();
  resulttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.ResultText)
}
inline void LogonResponse::set_resulttext(const char* value, size_t size) {
  set_has_resulttext();
  resulttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.ResultText)
}
inline ::std::string* LogonResponse::mutable_resulttext() {
  set_has_resulttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.ResultText)
  return resulttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonResponse::release_resulttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonResponse.ResultText)
  if (!has_resulttext()) {
    return NULL;
  }
  clear_has_resulttext();
  return resulttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonResponse::set_allocated_resulttext(::std::string* resulttext) {
  if (resulttext != NULL) {
    set_has_resulttext();
  } else {
    clear_has_resulttext();
  }
  resulttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resulttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.ResultText)
}

// optional string ReconnectAddress = 4;
inline bool LogonResponse::has_reconnectaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogonResponse::set_has_reconnectaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogonResponse::clear_has_reconnectaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogonResponse::clear_reconnectaddress() {
  reconnectaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reconnectaddress();
}
inline const ::std::string& LogonResponse::reconnectaddress() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ReconnectAddress)
  return reconnectaddress_.GetNoArena();
}
inline void LogonResponse::set_reconnectaddress(const ::std::string& value) {
  set_has_reconnectaddress();
  reconnectaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ReconnectAddress)
}
#if LANG_CXX11
inline void LogonResponse::set_reconnectaddress(::std::string&& value) {
  set_has_reconnectaddress();
  reconnectaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonResponse.ReconnectAddress)
}
#endif
inline void LogonResponse::set_reconnectaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reconnectaddress();
  reconnectaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.ReconnectAddress)
}
inline void LogonResponse::set_reconnectaddress(const char* value, size_t size) {
  set_has_reconnectaddress();
  reconnectaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.ReconnectAddress)
}
inline ::std::string* LogonResponse::mutable_reconnectaddress() {
  set_has_reconnectaddress();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.ReconnectAddress)
  return reconnectaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonResponse::release_reconnectaddress() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonResponse.ReconnectAddress)
  if (!has_reconnectaddress()) {
    return NULL;
  }
  clear_has_reconnectaddress();
  return reconnectaddress_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonResponse::set_allocated_reconnectaddress(::std::string* reconnectaddress) {
  if (reconnectaddress != NULL) {
    set_has_reconnectaddress();
  } else {
    clear_has_reconnectaddress();
  }
  reconnectaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reconnectaddress);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.ReconnectAddress)
}

// optional int32 Integer_1 = 5;
inline bool LogonResponse::has_integer_1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogonResponse::set_has_integer_1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogonResponse::clear_has_integer_1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogonResponse::clear_integer_1() {
  integer_1_ = 0;
  clear_has_integer_1();
}
inline ::google::protobuf::int32 LogonResponse::integer_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.Integer_1)
  return integer_1_;
}
inline void LogonResponse::set_integer_1(::google::protobuf::int32 value) {
  set_has_integer_1();
  integer_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.Integer_1)
}

// optional string ServerName = 6;
inline bool LogonResponse::has_servername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogonResponse::set_has_servername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogonResponse::clear_has_servername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogonResponse::clear_servername() {
  servername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_servername();
}
inline const ::std::string& LogonResponse::servername() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ServerName)
  return servername_.GetNoArena();
}
inline void LogonResponse::set_servername(const ::std::string& value) {
  set_has_servername();
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ServerName)
}
#if LANG_CXX11
inline void LogonResponse::set_servername(::std::string&& value) {
  set_has_servername();
  servername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonResponse.ServerName)
}
#endif
inline void LogonResponse::set_servername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_servername();
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.ServerName)
}
inline void LogonResponse::set_servername(const char* value, size_t size) {
  set_has_servername();
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.ServerName)
}
inline ::std::string* LogonResponse::mutable_servername() {
  set_has_servername();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.ServerName)
  return servername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonResponse::release_servername() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonResponse.ServerName)
  if (!has_servername()) {
    return NULL;
  }
  clear_has_servername();
  return servername_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonResponse::set_allocated_servername(::std::string* servername) {
  if (servername != NULL) {
    set_has_servername();
  } else {
    clear_has_servername();
  }
  servername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servername);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.ServerName)
}

// optional uint32 MarketDepthUpdatesBestBidAndAsk = 7;
inline bool LogonResponse::has_marketdepthupdatesbestbidandask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogonResponse::set_has_marketdepthupdatesbestbidandask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogonResponse::clear_has_marketdepthupdatesbestbidandask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogonResponse::clear_marketdepthupdatesbestbidandask() {
  marketdepthupdatesbestbidandask_ = 0u;
  clear_has_marketdepthupdatesbestbidandask();
}
inline ::google::protobuf::uint32 LogonResponse::marketdepthupdatesbestbidandask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.MarketDepthUpdatesBestBidAndAsk)
  return marketdepthupdatesbestbidandask_;
}
inline void LogonResponse::set_marketdepthupdatesbestbidandask(::google::protobuf::uint32 value) {
  set_has_marketdepthupdatesbestbidandask();
  marketdepthupdatesbestbidandask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.MarketDepthUpdatesBestBidAndAsk)
}

// optional uint32 TradingIsSupported = 8;
inline bool LogonResponse::has_tradingissupported() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogonResponse::set_has_tradingissupported() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogonResponse::clear_has_tradingissupported() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogonResponse::clear_tradingissupported() {
  tradingissupported_ = 0u;
  clear_has_tradingissupported();
}
inline ::google::protobuf::uint32 LogonResponse::tradingissupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.TradingIsSupported)
  return tradingissupported_;
}
inline void LogonResponse::set_tradingissupported(::google::protobuf::uint32 value) {
  set_has_tradingissupported();
  tradingissupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.TradingIsSupported)
}

// optional uint32 OCOOrdersSupported = 9;
inline bool LogonResponse::has_ocoorderssupported() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LogonResponse::set_has_ocoorderssupported() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LogonResponse::clear_has_ocoorderssupported() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LogonResponse::clear_ocoorderssupported() {
  ocoorderssupported_ = 0u;
  clear_has_ocoorderssupported();
}
inline ::google::protobuf::uint32 LogonResponse::ocoorderssupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.OCOOrdersSupported)
  return ocoorderssupported_;
}
inline void LogonResponse::set_ocoorderssupported(::google::protobuf::uint32 value) {
  set_has_ocoorderssupported();
  ocoorderssupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.OCOOrdersSupported)
}

// optional uint32 OrderCancelReplaceSupported = 10;
inline bool LogonResponse::has_ordercancelreplacesupported() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LogonResponse::set_has_ordercancelreplacesupported() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LogonResponse::clear_has_ordercancelreplacesupported() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LogonResponse::clear_ordercancelreplacesupported() {
  ordercancelreplacesupported_ = 0u;
  clear_has_ordercancelreplacesupported();
}
inline ::google::protobuf::uint32 LogonResponse::ordercancelreplacesupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.OrderCancelReplaceSupported)
  return ordercancelreplacesupported_;
}
inline void LogonResponse::set_ordercancelreplacesupported(::google::protobuf::uint32 value) {
  set_has_ordercancelreplacesupported();
  ordercancelreplacesupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.OrderCancelReplaceSupported)
}

// optional string SymbolExchangeDelimiter = 11;
inline bool LogonResponse::has_symbolexchangedelimiter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogonResponse::set_has_symbolexchangedelimiter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogonResponse::clear_has_symbolexchangedelimiter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogonResponse::clear_symbolexchangedelimiter() {
  symbolexchangedelimiter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbolexchangedelimiter();
}
inline const ::std::string& LogonResponse::symbolexchangedelimiter() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
  return symbolexchangedelimiter_.GetNoArena();
}
inline void LogonResponse::set_symbolexchangedelimiter(const ::std::string& value) {
  set_has_symbolexchangedelimiter();
  symbolexchangedelimiter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}
#if LANG_CXX11
inline void LogonResponse::set_symbolexchangedelimiter(::std::string&& value) {
  set_has_symbolexchangedelimiter();
  symbolexchangedelimiter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}
#endif
inline void LogonResponse::set_symbolexchangedelimiter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbolexchangedelimiter();
  symbolexchangedelimiter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}
inline void LogonResponse::set_symbolexchangedelimiter(const char* value, size_t size) {
  set_has_symbolexchangedelimiter();
  symbolexchangedelimiter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}
inline ::std::string* LogonResponse::mutable_symbolexchangedelimiter() {
  set_has_symbolexchangedelimiter();
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
  return symbolexchangedelimiter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogonResponse::release_symbolexchangedelimiter() {
  // @@protoc_insertion_point(field_release:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
  if (!has_symbolexchangedelimiter()) {
    return NULL;
  }
  clear_has_symbolexchangedelimiter();
  return symbolexchangedelimiter_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogonResponse::set_allocated_symbolexchangedelimiter(::std::string* symbolexchangedelimiter) {
  if (symbolexchangedelimiter != NULL) {
    set_has_symbolexchangedelimiter();
  } else {
    clear_has_symbolexchangedelimiter();
  }
  symbolexchangedelimiter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbolexchangedelimiter);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}

// optional uint32 SecurityDefinitionsSupported = 12;
inline bool LogonResponse::has_securitydefinitionssupported() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LogonResponse::set_has_securitydefinitionssupported() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LogonResponse::clear_has_securitydefinitionssupported() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LogonResponse::clear_securitydefinitionssupported() {
  securitydefinitionssupported_ = 0u;
  clear_has_securitydefinitionssupported();
}
inline ::google::protobuf::uint32 LogonResponse::securitydefinitionssupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.SecurityDefinitionsSupported)
  return securitydefinitionssupported_;
}
inline void LogonResponse::set_securitydefinitionssupported(::google::protobuf::uint32 value) {
  set_has_securitydefinitionssupported();
  securitydefinitionssupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.SecurityDefinitionsSupported)
}

// optional uint32 HistoricalPriceDataSupported = 13;
inline bool LogonResponse::has_historicalpricedatasupported() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LogonResponse::set_has_historicalpricedatasupported() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LogonResponse::clear_has_historicalpricedatasupported() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LogonResponse::clear_historicalpricedatasupported() {
  historicalpricedatasupported_ = 0u;
  clear_has_historicalpricedatasupported();
}
inline ::google::protobuf::uint32 LogonResponse::historicalpricedatasupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.HistoricalPriceDataSupported)
  return historicalpricedatasupported_;
}
inline void LogonResponse::set_historicalpricedatasupported(::google::protobuf::uint32 value) {
  set_has_historicalpricedatasupported();
  historicalpricedatasupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.HistoricalPriceDataSupported)
}

// optional uint32 ResubscribeWhenMarketDataFeedAvailable = 14;
inline bool LogonResponse::has_resubscribewhenmarketdatafeedavailable() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LogonResponse::set_has_resubscribewhenmarketdatafeedavailable() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LogonResponse::clear_has_resubscribewhenmarketdatafeedavailable() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LogonResponse::clear_resubscribewhenmarketdatafeedavailable() {
  resubscribewhenmarketdatafeedavailable_ = 0u;
  clear_has_resubscribewhenmarketdatafeedavailable();
}
inline ::google::protobuf::uint32 LogonResponse::resubscribewhenmarketdatafeedavailable() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ResubscribeWhenMarketDataFeedAvailable)
  return resubscribewhenmarketdatafeedavailable_;
}
inline void LogonResponse::set_resubscribewhenmarketdatafeedavailable(::google::protobuf::uint32 value) {
  set_has_resubscribewhenmarketdatafeedavailable();
  resubscribewhenmarketdatafeedavailable_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ResubscribeWhenMarketDataFeedAvailable)
}

// optional uint32 MarketDepthIsSupported = 15;
inline bool LogonResponse::has_marketdepthissupported() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LogonResponse::set_has_marketdepthissupported() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LogonResponse::clear_has_marketdepthissupported() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LogonResponse::clear_marketdepthissupported() {
  marketdepthissupported_ = 0u;
  clear_has_marketdepthissupported();
}
inline ::google::protobuf::uint32 LogonResponse::marketdepthissupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.MarketDepthIsSupported)
  return marketdepthissupported_;
}
inline void LogonResponse::set_marketdepthissupported(::google::protobuf::uint32 value) {
  set_has_marketdepthissupported();
  marketdepthissupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.MarketDepthIsSupported)
}

// optional uint32 OneHistoricalPriceDataRequestPerConnection = 16;
inline bool LogonResponse::has_onehistoricalpricedatarequestperconnection() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LogonResponse::set_has_onehistoricalpricedatarequestperconnection() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LogonResponse::clear_has_onehistoricalpricedatarequestperconnection() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LogonResponse::clear_onehistoricalpricedatarequestperconnection() {
  onehistoricalpricedatarequestperconnection_ = 0u;
  clear_has_onehistoricalpricedatarequestperconnection();
}
inline ::google::protobuf::uint32 LogonResponse::onehistoricalpricedatarequestperconnection() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.OneHistoricalPriceDataRequestPerConnection)
  return onehistoricalpricedatarequestperconnection_;
}
inline void LogonResponse::set_onehistoricalpricedatarequestperconnection(::google::protobuf::uint32 value) {
  set_has_onehistoricalpricedatarequestperconnection();
  onehistoricalpricedatarequestperconnection_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.OneHistoricalPriceDataRequestPerConnection)
}

// optional uint32 BracketOrdersSupported = 17;
inline bool LogonResponse::has_bracketorderssupported() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LogonResponse::set_has_bracketorderssupported() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LogonResponse::clear_has_bracketorderssupported() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LogonResponse::clear_bracketorderssupported() {
  bracketorderssupported_ = 0u;
  clear_has_bracketorderssupported();
}
inline ::google::protobuf::uint32 LogonResponse::bracketorderssupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.BracketOrdersSupported)
  return bracketorderssupported_;
}
inline void LogonResponse::set_bracketorderssupported(::google::protobuf::uint32 value) {
  set_has_bracketorderssupported();
  bracketorderssupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.BracketOrdersSupported)
}

// optional uint32 UseIntegerPriceOrderMessages = 18;
inline bool LogonResponse::has_useintegerpriceordermessages() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LogonResponse::set_has_useintegerpriceordermessages() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LogonResponse::clear_has_useintegerpriceordermessages() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LogonResponse::clear_useintegerpriceordermessages() {
  useintegerpriceordermessages_ = 0u;
  clear_has_useintegerpriceordermessages();
}
inline ::google::protobuf::uint32 LogonResponse::useintegerpriceordermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.UseIntegerPriceOrderMessages)
  return useintegerpriceordermessages_;
}
inline void LogonResponse::set_useintegerpriceordermessages(::google::protobuf::uint32 value) {
  set_has_useintegerpriceordermessages();
  useintegerpriceordermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.UseIntegerPriceOrderMessages)
}

// optional uint32 UsesMultiplePositionsPerSymbolAndTradeAccount = 19;
inline bool LogonResponse::has_usesmultiplepositionspersymbolandtradeaccount() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LogonResponse::set_has_usesmultiplepositionspersymbolandtradeaccount() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LogonResponse::clear_has_usesmultiplepositionspersymbolandtradeaccount() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LogonResponse::clear_usesmultiplepositionspersymbolandtradeaccount() {
  usesmultiplepositionspersymbolandtradeaccount_ = 0u;
  clear_has_usesmultiplepositionspersymbolandtradeaccount();
}
inline ::google::protobuf::uint32 LogonResponse::usesmultiplepositionspersymbolandtradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.UsesMultiplePositionsPerSymbolAndTradeAccount)
  return usesmultiplepositionspersymbolandtradeaccount_;
}
inline void LogonResponse::set_usesmultiplepositionspersymbolandtradeaccount(::google::protobuf::uint32 value) {
  set_has_usesmultiplepositionspersymbolandtradeaccount();
  usesmultiplepositionspersymbolandtradeaccount_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.UsesMultiplePositionsPerSymbolAndTradeAccount)
}

// optional uint32 MarketDataSupported = 20;
inline bool LogonResponse::has_marketdatasupported() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LogonResponse::set_has_marketdatasupported() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LogonResponse::clear_has_marketdatasupported() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LogonResponse::clear_marketdatasupported() {
  marketdatasupported_ = 0u;
  clear_has_marketdatasupported();
}
inline ::google::protobuf::uint32 LogonResponse::marketdatasupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.MarketDataSupported)
  return marketdatasupported_;
}
inline void LogonResponse::set_marketdatasupported(::google::protobuf::uint32 value) {
  set_has_marketdatasupported();
  marketdatasupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.MarketDataSupported)
}

// -------------------------------------------------------------------

// Logoff

// optional string Reason = 1;
inline bool Logoff::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Logoff::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Logoff::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Logoff::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& Logoff::reason() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Logoff.Reason)
  return reason_.GetNoArena();
}
inline void Logoff::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.Logoff.Reason)
}
#if LANG_CXX11
inline void Logoff::set_reason(::std::string&& value) {
  set_has_reason();
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.Logoff.Reason)
}
#endif
inline void Logoff::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.Logoff.Reason)
}
inline void Logoff::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.Logoff.Reason)
}
inline ::std::string* Logoff::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:DTC_PB.Logoff.Reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Logoff::release_reason() {
  // @@protoc_insertion_point(field_release:DTC_PB.Logoff.Reason)
  if (!has_reason()) {
    return NULL;
  }
  clear_has_reason();
  return reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Logoff::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.Logoff.Reason)
}

// optional uint32 DoNotReconnect = 2;
inline bool Logoff::has_donotreconnect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Logoff::set_has_donotreconnect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Logoff::clear_has_donotreconnect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Logoff::clear_donotreconnect() {
  donotreconnect_ = 0u;
  clear_has_donotreconnect();
}
inline ::google::protobuf::uint32 Logoff::donotreconnect() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Logoff.DoNotReconnect)
  return donotreconnect_;
}
inline void Logoff::set_donotreconnect(::google::protobuf::uint32 value) {
  set_has_donotreconnect();
  donotreconnect_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.Logoff.DoNotReconnect)
}

// -------------------------------------------------------------------

// Heartbeat

// optional uint32 NumDroppedMessages = 1;
inline bool Heartbeat::has_numdroppedmessages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Heartbeat::set_has_numdroppedmessages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Heartbeat::clear_has_numdroppedmessages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Heartbeat::clear_numdroppedmessages() {
  numdroppedmessages_ = 0u;
  clear_has_numdroppedmessages();
}
inline ::google::protobuf::uint32 Heartbeat::numdroppedmessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Heartbeat.NumDroppedMessages)
  return numdroppedmessages_;
}
inline void Heartbeat::set_numdroppedmessages(::google::protobuf::uint32 value) {
  set_has_numdroppedmessages();
  numdroppedmessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.Heartbeat.NumDroppedMessages)
}

// optional sfixed64 CurrentDateTime = 2;
inline bool Heartbeat::has_currentdatetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heartbeat::set_has_currentdatetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heartbeat::clear_has_currentdatetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heartbeat::clear_currentdatetime() {
  currentdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_currentdatetime();
}
inline ::google::protobuf::int64 Heartbeat::currentdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Heartbeat.CurrentDateTime)
  return currentdatetime_;
}
inline void Heartbeat::set_currentdatetime(::google::protobuf::int64 value) {
  set_has_currentdatetime();
  currentdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.Heartbeat.CurrentDateTime)
}

// -------------------------------------------------------------------

// MarketDataFeedStatus

// optional .DTC_PB.MarketDataFeedStatusEnum Status = 1;
inline bool MarketDataFeedStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataFeedStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataFeedStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataFeedStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::DTC_PB::MarketDataFeedStatusEnum MarketDataFeedStatus::status() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataFeedStatus.Status)
  return static_cast< ::DTC_PB::MarketDataFeedStatusEnum >(status_);
}
inline void MarketDataFeedStatus::set_status(::DTC_PB::MarketDataFeedStatusEnum value) {
  assert(::DTC_PB::MarketDataFeedStatusEnum_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataFeedStatus.Status)
}

// -------------------------------------------------------------------

// MarketDataFeedSymbolStatus

// optional uint32 SymbolID = 1;
inline bool MarketDataFeedSymbolStatus::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataFeedSymbolStatus::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataFeedSymbolStatus::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataFeedSymbolStatus::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataFeedSymbolStatus::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataFeedSymbolStatus.SymbolID)
  return symbolid_;
}
inline void MarketDataFeedSymbolStatus::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataFeedSymbolStatus.SymbolID)
}

// optional .DTC_PB.MarketDataFeedStatusEnum Status = 2;
inline bool MarketDataFeedSymbolStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataFeedSymbolStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataFeedSymbolStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataFeedSymbolStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::DTC_PB::MarketDataFeedStatusEnum MarketDataFeedSymbolStatus::status() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataFeedSymbolStatus.Status)
  return static_cast< ::DTC_PB::MarketDataFeedStatusEnum >(status_);
}
inline void MarketDataFeedSymbolStatus::set_status(::DTC_PB::MarketDataFeedStatusEnum value) {
  assert(::DTC_PB::MarketDataFeedStatusEnum_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataFeedSymbolStatus.Status)
}

// -------------------------------------------------------------------

// TradingSymbolStatus

// optional uint32 SymbolID = 1;
inline bool TradingSymbolStatus::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradingSymbolStatus::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradingSymbolStatus::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradingSymbolStatus::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 TradingSymbolStatus::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradingSymbolStatus.SymbolID)
  return symbolid_;
}
inline void TradingSymbolStatus::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradingSymbolStatus.SymbolID)
}

// optional .DTC_PB.TradingStatusEnum Status = 2;
inline bool TradingSymbolStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradingSymbolStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradingSymbolStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradingSymbolStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::DTC_PB::TradingStatusEnum TradingSymbolStatus::status() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradingSymbolStatus.Status)
  return static_cast< ::DTC_PB::TradingStatusEnum >(status_);
}
inline void TradingSymbolStatus::set_status(::DTC_PB::TradingStatusEnum value) {
  assert(::DTC_PB::TradingStatusEnum_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradingSymbolStatus.Status)
}

// -------------------------------------------------------------------

// MarketDataRequest

// optional .DTC_PB.RequestActionEnum RequestAction = 1;
inline bool MarketDataRequest::has_requestaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataRequest::set_has_requestaction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataRequest::clear_has_requestaction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataRequest::clear_requestaction() {
  requestaction_ = 1;
  clear_has_requestaction();
}
inline ::DTC_PB::RequestActionEnum MarketDataRequest::requestaction() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.RequestAction)
  return static_cast< ::DTC_PB::RequestActionEnum >(requestaction_);
}
inline void MarketDataRequest::set_requestaction(::DTC_PB::RequestActionEnum value) {
  assert(::DTC_PB::RequestActionEnum_IsValid(value));
  set_has_requestaction();
  requestaction_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.RequestAction)
}

// optional uint32 SymbolID = 2;
inline bool MarketDataRequest::has_symbolid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataRequest::set_has_symbolid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataRequest::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataRequest::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataRequest::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.SymbolID)
  return symbolid_;
}
inline void MarketDataRequest::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.SymbolID)
}

// optional string Symbol = 3;
inline bool MarketDataRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataRequest::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& MarketDataRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.Symbol)
  return symbol_.GetNoArena();
}
inline void MarketDataRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.Symbol)
}
#if LANG_CXX11
inline void MarketDataRequest::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.MarketDataRequest.Symbol)
}
#endif
inline void MarketDataRequest::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDataRequest.Symbol)
}
inline void MarketDataRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDataRequest.Symbol)
}
inline ::std::string* MarketDataRequest::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDataRequest.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketDataRequest::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.MarketDataRequest.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketDataRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDataRequest.Symbol)
}

// optional string Exchange = 4;
inline bool MarketDataRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& MarketDataRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void MarketDataRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.Exchange)
}
#if LANG_CXX11
inline void MarketDataRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.MarketDataRequest.Exchange)
}
#endif
inline void MarketDataRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDataRequest.Exchange)
}
inline void MarketDataRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDataRequest.Exchange)
}
inline ::std::string* MarketDataRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDataRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketDataRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.MarketDataRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketDataRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDataRequest.Exchange)
}

// -------------------------------------------------------------------

// MarketDepthRequest

// optional .DTC_PB.RequestActionEnum RequestAction = 1;
inline bool MarketDepthRequest::has_requestaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthRequest::set_has_requestaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthRequest::clear_has_requestaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthRequest::clear_requestaction() {
  requestaction_ = 1;
  clear_has_requestaction();
}
inline ::DTC_PB::RequestActionEnum MarketDepthRequest::requestaction() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.RequestAction)
  return static_cast< ::DTC_PB::RequestActionEnum >(requestaction_);
}
inline void MarketDepthRequest::set_requestaction(::DTC_PB::RequestActionEnum value) {
  assert(::DTC_PB::RequestActionEnum_IsValid(value));
  set_has_requestaction();
  requestaction_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.RequestAction)
}

// optional uint32 SymbolID = 2;
inline bool MarketDepthRequest::has_symbolid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthRequest::set_has_symbolid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthRequest::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthRequest::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthRequest::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.SymbolID)
  return symbolid_;
}
inline void MarketDepthRequest::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.SymbolID)
}

// optional string Symbol = 3;
inline bool MarketDepthRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthRequest::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& MarketDepthRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.Symbol)
  return symbol_.GetNoArena();
}
inline void MarketDepthRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.Symbol)
}
#if LANG_CXX11
inline void MarketDepthRequest::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.MarketDepthRequest.Symbol)
}
#endif
inline void MarketDepthRequest::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDepthRequest.Symbol)
}
inline void MarketDepthRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDepthRequest.Symbol)
}
inline ::std::string* MarketDepthRequest::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthRequest.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketDepthRequest::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.MarketDepthRequest.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketDepthRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDepthRequest.Symbol)
}

// optional string Exchange = 4;
inline bool MarketDepthRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& MarketDepthRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void MarketDepthRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.Exchange)
}
#if LANG_CXX11
inline void MarketDepthRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.MarketDepthRequest.Exchange)
}
#endif
inline void MarketDepthRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDepthRequest.Exchange)
}
inline void MarketDepthRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDepthRequest.Exchange)
}
inline ::std::string* MarketDepthRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketDepthRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.MarketDepthRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketDepthRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDepthRequest.Exchange)
}

// optional int32 NumLevels = 5;
inline bool MarketDepthRequest::has_numlevels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthRequest::set_has_numlevels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthRequest::clear_has_numlevels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthRequest::clear_numlevels() {
  numlevels_ = 0;
  clear_has_numlevels();
}
inline ::google::protobuf::int32 MarketDepthRequest::numlevels() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.NumLevels)
  return numlevels_;
}
inline void MarketDepthRequest::set_numlevels(::google::protobuf::int32 value) {
  set_has_numlevels();
  numlevels_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.NumLevels)
}

// -------------------------------------------------------------------

// MarketDataReject

// optional uint32 SymbolID = 1;
inline bool MarketDataReject::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataReject::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataReject::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataReject::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataReject::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataReject.SymbolID)
  return symbolid_;
}
inline void MarketDataReject::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataReject.SymbolID)
}

// optional string RejectText = 2;
inline bool MarketDataReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& MarketDataReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void MarketDataReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataReject.RejectText)
}
#if LANG_CXX11
inline void MarketDataReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.MarketDataReject.RejectText)
}
#endif
inline void MarketDataReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDataReject.RejectText)
}
inline void MarketDataReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDataReject.RejectText)
}
inline ::std::string* MarketDataReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDataReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketDataReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.MarketDataReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketDataReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDataReject.RejectText)
}

// -------------------------------------------------------------------

// MarketDataSnapshot

// optional uint32 SymbolID = 1;
inline bool MarketDataSnapshot::has_symbolid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataSnapshot::set_has_symbolid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataSnapshot::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataSnapshot::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SymbolID)
  return symbolid_;
}
inline void MarketDataSnapshot::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SymbolID)
}

// optional double SessionSettlementPrice = 2;
inline bool MarketDataSnapshot::has_sessionsettlementprice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionsettlementprice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataSnapshot::clear_has_sessionsettlementprice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataSnapshot::clear_sessionsettlementprice() {
  sessionsettlementprice_ = 0;
  clear_has_sessionsettlementprice();
}
inline double MarketDataSnapshot::sessionsettlementprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionSettlementPrice)
  return sessionsettlementprice_;
}
inline void MarketDataSnapshot::set_sessionsettlementprice(double value) {
  set_has_sessionsettlementprice();
  sessionsettlementprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionSettlementPrice)
}

// optional double SessionOpenPrice = 3;
inline bool MarketDataSnapshot::has_sessionopenprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionopenprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataSnapshot::clear_has_sessionopenprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataSnapshot::clear_sessionopenprice() {
  sessionopenprice_ = 0;
  clear_has_sessionopenprice();
}
inline double MarketDataSnapshot::sessionopenprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionOpenPrice)
  return sessionopenprice_;
}
inline void MarketDataSnapshot::set_sessionopenprice(double value) {
  set_has_sessionopenprice();
  sessionopenprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionOpenPrice)
}

// optional double SessionHighPrice = 4;
inline bool MarketDataSnapshot::has_sessionhighprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionhighprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataSnapshot::clear_has_sessionhighprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataSnapshot::clear_sessionhighprice() {
  sessionhighprice_ = 0;
  clear_has_sessionhighprice();
}
inline double MarketDataSnapshot::sessionhighprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionHighPrice)
  return sessionhighprice_;
}
inline void MarketDataSnapshot::set_sessionhighprice(double value) {
  set_has_sessionhighprice();
  sessionhighprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionHighPrice)
}

// optional double SessionLowPrice = 5;
inline bool MarketDataSnapshot::has_sessionlowprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionlowprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataSnapshot::clear_has_sessionlowprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataSnapshot::clear_sessionlowprice() {
  sessionlowprice_ = 0;
  clear_has_sessionlowprice();
}
inline double MarketDataSnapshot::sessionlowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionLowPrice)
  return sessionlowprice_;
}
inline void MarketDataSnapshot::set_sessionlowprice(double value) {
  set_has_sessionlowprice();
  sessionlowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionLowPrice)
}

// optional double SessionVolume = 6;
inline bool MarketDataSnapshot::has_sessionvolume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionvolume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDataSnapshot::clear_has_sessionvolume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDataSnapshot::clear_sessionvolume() {
  sessionvolume_ = 0;
  clear_has_sessionvolume();
}
inline double MarketDataSnapshot::sessionvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionVolume)
  return sessionvolume_;
}
inline void MarketDataSnapshot::set_sessionvolume(double value) {
  set_has_sessionvolume();
  sessionvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionVolume)
}

// optional uint32 SessionNumTrades = 7;
inline bool MarketDataSnapshot::has_sessionnumtrades() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionnumtrades() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataSnapshot::clear_has_sessionnumtrades() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataSnapshot::clear_sessionnumtrades() {
  sessionnumtrades_ = 0u;
  clear_has_sessionnumtrades();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::sessionnumtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionNumTrades)
  return sessionnumtrades_;
}
inline void MarketDataSnapshot::set_sessionnumtrades(::google::protobuf::uint32 value) {
  set_has_sessionnumtrades();
  sessionnumtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionNumTrades)
}

// optional uint32 OpenInterest = 8;
inline bool MarketDataSnapshot::has_openinterest() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MarketDataSnapshot::set_has_openinterest() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MarketDataSnapshot::clear_has_openinterest() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MarketDataSnapshot::clear_openinterest() {
  openinterest_ = 0u;
  clear_has_openinterest();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::openinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.OpenInterest)
  return openinterest_;
}
inline void MarketDataSnapshot::set_openinterest(::google::protobuf::uint32 value) {
  set_has_openinterest();
  openinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.OpenInterest)
}

// optional double BidPrice = 9;
inline bool MarketDataSnapshot::has_bidprice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketDataSnapshot::set_has_bidprice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketDataSnapshot::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketDataSnapshot::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline double MarketDataSnapshot::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.BidPrice)
  return bidprice_;
}
inline void MarketDataSnapshot::set_bidprice(double value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.BidPrice)
}

// optional double AskPrice = 10;
inline bool MarketDataSnapshot::has_askprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MarketDataSnapshot::set_has_askprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MarketDataSnapshot::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MarketDataSnapshot::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline double MarketDataSnapshot::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.AskPrice)
  return askprice_;
}
inline void MarketDataSnapshot::set_askprice(double value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.AskPrice)
}

// optional double AskQuantity = 11;
inline bool MarketDataSnapshot::has_askquantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MarketDataSnapshot::set_has_askquantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MarketDataSnapshot::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MarketDataSnapshot::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline double MarketDataSnapshot::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.AskQuantity)
  return askquantity_;
}
inline void MarketDataSnapshot::set_askquantity(double value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.AskQuantity)
}

// optional double BidQuantity = 12;
inline bool MarketDataSnapshot::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MarketDataSnapshot::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MarketDataSnapshot::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MarketDataSnapshot::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline double MarketDataSnapshot::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.BidQuantity)
  return bidquantity_;
}
inline void MarketDataSnapshot::set_bidquantity(double value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.BidQuantity)
}

// optional double LastTradePrice = 13;
inline bool MarketDataSnapshot::has_lasttradeprice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MarketDataSnapshot::set_has_lasttradeprice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MarketDataSnapshot::clear_has_lasttradeprice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MarketDataSnapshot::clear_lasttradeprice() {
  lasttradeprice_ = 0;
  clear_has_lasttradeprice();
}
inline double MarketDataSnapshot::lasttradeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.LastTradePrice)
  return lasttradeprice_;
}
inline void MarketDataSnapshot::set_lasttradeprice(double value) {
  set_has_lasttradeprice();
  lasttradeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.LastTradePrice)
}

// optional double LastTradeVolume = 14;
inline bool MarketDataSnapshot::has_lasttradevolume() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MarketDataSnapshot::set_has_lasttradevolume() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MarketDataSnapshot::clear_has_lasttradevolume() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MarketDataSnapshot::clear_lasttradevolume() {
  lasttradevolume_ = 0;
  clear_has_lasttradevolume();
}
inline double MarketDataSnapshot::lasttradevolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.LastTradeVolume)
  return lasttradevolume_;
}
inline void MarketDataSnapshot::set_lasttradevolume(double value) {
  set_has_lasttradevolume();
  lasttradevolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.LastTradeVolume)
}

// optional double LastTradeDateTime = 15;
inline bool MarketDataSnapshot::has_lasttradedatetime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MarketDataSnapshot::set_has_lasttradedatetime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MarketDataSnapshot::clear_has_lasttradedatetime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MarketDataSnapshot::clear_lasttradedatetime() {
  lasttradedatetime_ = 0;
  clear_has_lasttradedatetime();
}
inline double MarketDataSnapshot::lasttradedatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.LastTradeDateTime)
  return lasttradedatetime_;
}
inline void MarketDataSnapshot::set_lasttradedatetime(double value) {
  set_has_lasttradedatetime();
  lasttradedatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.LastTradeDateTime)
}

// optional double BidAskDateTime = 16;
inline bool MarketDataSnapshot::has_bidaskdatetime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MarketDataSnapshot::set_has_bidaskdatetime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MarketDataSnapshot::clear_has_bidaskdatetime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MarketDataSnapshot::clear_bidaskdatetime() {
  bidaskdatetime_ = 0;
  clear_has_bidaskdatetime();
}
inline double MarketDataSnapshot::bidaskdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.BidAskDateTime)
  return bidaskdatetime_;
}
inline void MarketDataSnapshot::set_bidaskdatetime(double value) {
  set_has_bidaskdatetime();
  bidaskdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.BidAskDateTime)
}

// optional uint32 SessionSettlementDateTime = 17;
inline bool MarketDataSnapshot::has_sessionsettlementdatetime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionsettlementdatetime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MarketDataSnapshot::clear_has_sessionsettlementdatetime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MarketDataSnapshot::clear_sessionsettlementdatetime() {
  sessionsettlementdatetime_ = 0u;
  clear_has_sessionsettlementdatetime();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::sessionsettlementdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionSettlementDateTime)
  return sessionsettlementdatetime_;
}
inline void MarketDataSnapshot::set_sessionsettlementdatetime(::google::protobuf::uint32 value) {
  set_has_sessionsettlementdatetime();
  sessionsettlementdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionSettlementDateTime)
}

// optional uint32 TradingSessionDate = 18;
inline bool MarketDataSnapshot::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MarketDataSnapshot::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MarketDataSnapshot::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MarketDataSnapshot::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataSnapshot::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.TradingSessionDate)
}

// optional .DTC_PB.TradingStatusEnum TradingStatus = 19;
inline bool MarketDataSnapshot::has_tradingstatus() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MarketDataSnapshot::set_has_tradingstatus() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MarketDataSnapshot::clear_has_tradingstatus() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MarketDataSnapshot::clear_tradingstatus() {
  tradingstatus_ = 0;
  clear_has_tradingstatus();
}
inline ::DTC_PB::TradingStatusEnum MarketDataSnapshot::tradingstatus() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.TradingStatus)
  return static_cast< ::DTC_PB::TradingStatusEnum >(tradingstatus_);
}
inline void MarketDataSnapshot::set_tradingstatus(::DTC_PB::TradingStatusEnum value) {
  assert(::DTC_PB::TradingStatusEnum_IsValid(value));
  set_has_tradingstatus();
  tradingstatus_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.TradingStatus)
}

// -------------------------------------------------------------------

// MarketDataSnapshot_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataSnapshot_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataSnapshot_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataSnapshot_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataSnapshot_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SymbolID)
}

// optional int32 SessionSettlementPrice = 2;
inline bool MarketDataSnapshot_Int::has_sessionsettlementprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionsettlementprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionsettlementprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataSnapshot_Int::clear_sessionsettlementprice() {
  sessionsettlementprice_ = 0;
  clear_has_sessionsettlementprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionsettlementprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionSettlementPrice)
  return sessionsettlementprice_;
}
inline void MarketDataSnapshot_Int::set_sessionsettlementprice(::google::protobuf::int32 value) {
  set_has_sessionsettlementprice();
  sessionsettlementprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionSettlementPrice)
}

// optional int32 SessionOpenPrice = 3;
inline bool MarketDataSnapshot_Int::has_sessionopenprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionopenprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionopenprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataSnapshot_Int::clear_sessionopenprice() {
  sessionopenprice_ = 0;
  clear_has_sessionopenprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionopenprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionOpenPrice)
  return sessionopenprice_;
}
inline void MarketDataSnapshot_Int::set_sessionopenprice(::google::protobuf::int32 value) {
  set_has_sessionopenprice();
  sessionopenprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionOpenPrice)
}

// optional int32 SessionHighPrice = 4;
inline bool MarketDataSnapshot_Int::has_sessionhighprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionhighprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionhighprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataSnapshot_Int::clear_sessionhighprice() {
  sessionhighprice_ = 0;
  clear_has_sessionhighprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionhighprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionHighPrice)
  return sessionhighprice_;
}
inline void MarketDataSnapshot_Int::set_sessionhighprice(::google::protobuf::int32 value) {
  set_has_sessionhighprice();
  sessionhighprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionHighPrice)
}

// optional int32 SessionLowPrice = 5;
inline bool MarketDataSnapshot_Int::has_sessionlowprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionlowprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionlowprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataSnapshot_Int::clear_sessionlowprice() {
  sessionlowprice_ = 0;
  clear_has_sessionlowprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionlowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionLowPrice)
  return sessionlowprice_;
}
inline void MarketDataSnapshot_Int::set_sessionlowprice(::google::protobuf::int32 value) {
  set_has_sessionlowprice();
  sessionlowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionLowPrice)
}

// optional int32 SessionVolume = 6;
inline bool MarketDataSnapshot_Int::has_sessionvolume() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionvolume() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionvolume() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataSnapshot_Int::clear_sessionvolume() {
  sessionvolume_ = 0;
  clear_has_sessionvolume();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionVolume)
  return sessionvolume_;
}
inline void MarketDataSnapshot_Int::set_sessionvolume(::google::protobuf::int32 value) {
  set_has_sessionvolume();
  sessionvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionVolume)
}

// optional uint32 SessionNumTrades = 7;
inline bool MarketDataSnapshot_Int::has_sessionnumtrades() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionnumtrades() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionnumtrades() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDataSnapshot_Int::clear_sessionnumtrades() {
  sessionnumtrades_ = 0u;
  clear_has_sessionnumtrades();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::sessionnumtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionNumTrades)
  return sessionnumtrades_;
}
inline void MarketDataSnapshot_Int::set_sessionnumtrades(::google::protobuf::uint32 value) {
  set_has_sessionnumtrades();
  sessionnumtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionNumTrades)
}

// optional uint32 OpenInterest = 8;
inline bool MarketDataSnapshot_Int::has_openinterest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_openinterest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketDataSnapshot_Int::clear_has_openinterest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketDataSnapshot_Int::clear_openinterest() {
  openinterest_ = 0u;
  clear_has_openinterest();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::openinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.OpenInterest)
  return openinterest_;
}
inline void MarketDataSnapshot_Int::set_openinterest(::google::protobuf::uint32 value) {
  set_has_openinterest();
  openinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.OpenInterest)
}

// optional int32 BidPrice = 9;
inline bool MarketDataSnapshot_Int::has_bidprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_bidprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MarketDataSnapshot_Int::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MarketDataSnapshot_Int::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.BidPrice)
  return bidprice_;
}
inline void MarketDataSnapshot_Int::set_bidprice(::google::protobuf::int32 value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.BidPrice)
}

// optional int32 AskPrice = 10;
inline bool MarketDataSnapshot_Int::has_askprice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_askprice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MarketDataSnapshot_Int::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MarketDataSnapshot_Int::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.AskPrice)
  return askprice_;
}
inline void MarketDataSnapshot_Int::set_askprice(::google::protobuf::int32 value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.AskPrice)
}

// optional int32 AskQuantity = 11;
inline bool MarketDataSnapshot_Int::has_askquantity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_askquantity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MarketDataSnapshot_Int::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MarketDataSnapshot_Int::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.AskQuantity)
  return askquantity_;
}
inline void MarketDataSnapshot_Int::set_askquantity(::google::protobuf::int32 value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.AskQuantity)
}

// optional int32 BidQuantity = 12;
inline bool MarketDataSnapshot_Int::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MarketDataSnapshot_Int::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MarketDataSnapshot_Int::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.BidQuantity)
  return bidquantity_;
}
inline void MarketDataSnapshot_Int::set_bidquantity(::google::protobuf::int32 value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.BidQuantity)
}

// optional int32 LastTradePrice = 13;
inline bool MarketDataSnapshot_Int::has_lasttradeprice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_lasttradeprice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MarketDataSnapshot_Int::clear_has_lasttradeprice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MarketDataSnapshot_Int::clear_lasttradeprice() {
  lasttradeprice_ = 0;
  clear_has_lasttradeprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::lasttradeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.LastTradePrice)
  return lasttradeprice_;
}
inline void MarketDataSnapshot_Int::set_lasttradeprice(::google::protobuf::int32 value) {
  set_has_lasttradeprice();
  lasttradeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.LastTradePrice)
}

// optional int32 LastTradeVolume = 14;
inline bool MarketDataSnapshot_Int::has_lasttradevolume() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_lasttradevolume() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MarketDataSnapshot_Int::clear_has_lasttradevolume() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MarketDataSnapshot_Int::clear_lasttradevolume() {
  lasttradevolume_ = 0;
  clear_has_lasttradevolume();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::lasttradevolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.LastTradeVolume)
  return lasttradevolume_;
}
inline void MarketDataSnapshot_Int::set_lasttradevolume(::google::protobuf::int32 value) {
  set_has_lasttradevolume();
  lasttradevolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.LastTradeVolume)
}

// optional double LastTradeDateTime = 15;
inline bool MarketDataSnapshot_Int::has_lasttradedatetime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_lasttradedatetime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MarketDataSnapshot_Int::clear_has_lasttradedatetime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MarketDataSnapshot_Int::clear_lasttradedatetime() {
  lasttradedatetime_ = 0;
  clear_has_lasttradedatetime();
}
inline double MarketDataSnapshot_Int::lasttradedatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.LastTradeDateTime)
  return lasttradedatetime_;
}
inline void MarketDataSnapshot_Int::set_lasttradedatetime(double value) {
  set_has_lasttradedatetime();
  lasttradedatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.LastTradeDateTime)
}

// optional double BidAskDateTime = 16;
inline bool MarketDataSnapshot_Int::has_bidaskdatetime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_bidaskdatetime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MarketDataSnapshot_Int::clear_has_bidaskdatetime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MarketDataSnapshot_Int::clear_bidaskdatetime() {
  bidaskdatetime_ = 0;
  clear_has_bidaskdatetime();
}
inline double MarketDataSnapshot_Int::bidaskdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.BidAskDateTime)
  return bidaskdatetime_;
}
inline void MarketDataSnapshot_Int::set_bidaskdatetime(double value) {
  set_has_bidaskdatetime();
  bidaskdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.BidAskDateTime)
}

// optional uint32 SessionSettlementDateTime = 17;
inline bool MarketDataSnapshot_Int::has_sessionsettlementdatetime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionsettlementdatetime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionsettlementdatetime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MarketDataSnapshot_Int::clear_sessionsettlementdatetime() {
  sessionsettlementdatetime_ = 0u;
  clear_has_sessionsettlementdatetime();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::sessionsettlementdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionSettlementDateTime)
  return sessionsettlementdatetime_;
}
inline void MarketDataSnapshot_Int::set_sessionsettlementdatetime(::google::protobuf::uint32 value) {
  set_has_sessionsettlementdatetime();
  sessionsettlementdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionSettlementDateTime)
}

// optional uint32 TradingSessionDate = 18;
inline bool MarketDataSnapshot_Int::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MarketDataSnapshot_Int::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MarketDataSnapshot_Int::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataSnapshot_Int::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.TradingSessionDate)
}

// optional .DTC_PB.TradingStatusEnum TradingStatus = 19;
inline bool MarketDataSnapshot_Int::has_tradingstatus() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_tradingstatus() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MarketDataSnapshot_Int::clear_has_tradingstatus() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MarketDataSnapshot_Int::clear_tradingstatus() {
  tradingstatus_ = 0;
  clear_has_tradingstatus();
}
inline ::DTC_PB::TradingStatusEnum MarketDataSnapshot_Int::tradingstatus() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.TradingStatus)
  return static_cast< ::DTC_PB::TradingStatusEnum >(tradingstatus_);
}
inline void MarketDataSnapshot_Int::set_tradingstatus(::DTC_PB::TradingStatusEnum value) {
  assert(::DTC_PB::TradingStatusEnum_IsValid(value));
  set_has_tradingstatus();
  tradingstatus_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.TradingStatus)
}

// -------------------------------------------------------------------

// DepthEntry

// optional double Price = 1;
inline bool DepthEntry::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DepthEntry::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DepthEntry::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DepthEntry::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double DepthEntry::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.DepthEntry.Price)
  return price_;
}
inline void DepthEntry::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.DepthEntry.Price)
}

// optional float Quantity = 12;
inline bool DepthEntry::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DepthEntry::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DepthEntry::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DepthEntry::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float DepthEntry::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.DepthEntry.Quantity)
  return quantity_;
}
inline void DepthEntry::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.DepthEntry.Quantity)
}

// -------------------------------------------------------------------

// MarketDepthFullUpdate20

// optional uint32 SymbolID = 1;
inline bool MarketDepthFullUpdate20::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthFullUpdate20::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthFullUpdate20::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthFullUpdate20::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthFullUpdate20::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate20.SymbolID)
  return symbolid_;
}
inline void MarketDepthFullUpdate20::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthFullUpdate20.SymbolID)
}

// repeated .DTC_PB.DepthEntry BidDepth = 2;
inline int MarketDepthFullUpdate20::biddepth_size() const {
  return biddepth_.size();
}
inline void MarketDepthFullUpdate20::clear_biddepth() {
  biddepth_.Clear();
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::mutable_biddepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate20::mutable_biddepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return &biddepth_;
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate20::biddepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::add_biddepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate20::biddepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_;
}

// repeated .DTC_PB.DepthEntry AskDepth = 3;
inline int MarketDepthFullUpdate20::askdepth_size() const {
  return askdepth_.size();
}
inline void MarketDepthFullUpdate20::clear_askdepth() {
  askdepth_.Clear();
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::mutable_askdepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate20::mutable_askdepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return &askdepth_;
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate20::askdepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::add_askdepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate20::askdepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_;
}

// -------------------------------------------------------------------

// MarketDepthFullUpdate10

// optional uint32 SymbolID = 1;
inline bool MarketDepthFullUpdate10::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthFullUpdate10::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthFullUpdate10::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthFullUpdate10::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthFullUpdate10::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate10.SymbolID)
  return symbolid_;
}
inline void MarketDepthFullUpdate10::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthFullUpdate10.SymbolID)
}

// repeated .DTC_PB.DepthEntry BidDepth = 2;
inline int MarketDepthFullUpdate10::biddepth_size() const {
  return biddepth_.size();
}
inline void MarketDepthFullUpdate10::clear_biddepth() {
  biddepth_.Clear();
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::mutable_biddepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate10::mutable_biddepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return &biddepth_;
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate10::biddepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::add_biddepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate10::biddepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_;
}

// repeated .DTC_PB.DepthEntry AskDepth = 3;
inline int MarketDepthFullUpdate10::askdepth_size() const {
  return askdepth_.size();
}
inline void MarketDepthFullUpdate10::clear_askdepth() {
  askdepth_.Clear();
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::mutable_askdepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate10::mutable_askdepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return &askdepth_;
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate10::askdepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::add_askdepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate10::askdepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_;
}

// -------------------------------------------------------------------

// MarketDepthSnapshotLevel

// optional uint32 SymbolID = 1;
inline bool MarketDepthSnapshotLevel::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthSnapshotLevel::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthSnapshotLevel::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.SymbolID)
  return symbolid_;
}
inline void MarketDepthSnapshotLevel::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthSnapshotLevel::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthSnapshotLevel::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthSnapshotLevel::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthSnapshotLevel::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthSnapshotLevel::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Side)
}

// optional double Price = 3;
inline bool MarketDepthSnapshotLevel::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthSnapshotLevel::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthSnapshotLevel::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDepthSnapshotLevel::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Price)
  return price_;
}
inline void MarketDepthSnapshotLevel::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Price)
}

// optional double Quantity = 4;
inline bool MarketDepthSnapshotLevel::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthSnapshotLevel::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthSnapshotLevel::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double MarketDepthSnapshotLevel::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Quantity)
  return quantity_;
}
inline void MarketDepthSnapshotLevel::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Quantity)
}

// optional uint32 Level = 5;
inline bool MarketDepthSnapshotLevel::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthSnapshotLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthSnapshotLevel::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::level() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Level)
  return level_;
}
inline void MarketDepthSnapshotLevel::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Level)
}

// optional uint32 IsFirstMessageInBatch = 6;
inline bool MarketDepthSnapshotLevel::has_isfirstmessageinbatch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_isfirstmessageinbatch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthSnapshotLevel::clear_has_isfirstmessageinbatch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthSnapshotLevel::clear_isfirstmessageinbatch() {
  isfirstmessageinbatch_ = 0u;
  clear_has_isfirstmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::isfirstmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.IsFirstMessageInBatch)
  return isfirstmessageinbatch_;
}
inline void MarketDepthSnapshotLevel::set_isfirstmessageinbatch(::google::protobuf::uint32 value) {
  set_has_isfirstmessageinbatch();
  isfirstmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.IsFirstMessageInBatch)
}

// optional uint32 IsLastMessageInBatch = 7;
inline bool MarketDepthSnapshotLevel::has_islastmessageinbatch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_islastmessageinbatch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketDepthSnapshotLevel::clear_has_islastmessageinbatch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketDepthSnapshotLevel::clear_islastmessageinbatch() {
  islastmessageinbatch_ = 0u;
  clear_has_islastmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::islastmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.IsLastMessageInBatch)
  return islastmessageinbatch_;
}
inline void MarketDepthSnapshotLevel::set_islastmessageinbatch(::google::protobuf::uint32 value) {
  set_has_islastmessageinbatch();
  islastmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.IsLastMessageInBatch)
}

// optional double DateTime = 8;
inline bool MarketDepthSnapshotLevel::has_datetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_datetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthSnapshotLevel::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthSnapshotLevel::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDepthSnapshotLevel::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.DateTime)
  return datetime_;
}
inline void MarketDepthSnapshotLevel::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.DateTime)
}

// optional uint32 NumOrders = 9;
inline bool MarketDepthSnapshotLevel::has_numorders() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_numorders() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MarketDepthSnapshotLevel::clear_has_numorders() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MarketDepthSnapshotLevel::clear_numorders() {
  numorders_ = 0u;
  clear_has_numorders();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::numorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.NumOrders)
  return numorders_;
}
inline void MarketDepthSnapshotLevel::set_numorders(::google::protobuf::uint32 value) {
  set_has_numorders();
  numorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.NumOrders)
}

// -------------------------------------------------------------------

// MarketDepthSnapshotLevel_Int

// optional uint32 SymbolID = 1;
inline bool MarketDepthSnapshotLevel_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthSnapshotLevel_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.SymbolID)
  return symbolid_;
}
inline void MarketDepthSnapshotLevel_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthSnapshotLevel_Int::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthSnapshotLevel_Int::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthSnapshotLevel_Int::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthSnapshotLevel_Int::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Side)
}

// optional int32 Price = 3;
inline bool MarketDepthSnapshotLevel_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthSnapshotLevel_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDepthSnapshotLevel_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Price)
  return price_;
}
inline void MarketDepthSnapshotLevel_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Price)
}

// optional int32 Quantity = 4;
inline bool MarketDepthSnapshotLevel_Int::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthSnapshotLevel_Int::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 MarketDepthSnapshotLevel_Int::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Quantity)
  return quantity_;
}
inline void MarketDepthSnapshotLevel_Int::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Quantity)
}

// optional uint32 Level = 5;
inline bool MarketDepthSnapshotLevel_Int::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthSnapshotLevel_Int::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::level() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Level)
  return level_;
}
inline void MarketDepthSnapshotLevel_Int::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Level)
}

// optional uint32 IsFirstMessageInBatch = 6;
inline bool MarketDepthSnapshotLevel_Int::has_isfirstmessageinbatch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_isfirstmessageinbatch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_isfirstmessageinbatch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthSnapshotLevel_Int::clear_isfirstmessageinbatch() {
  isfirstmessageinbatch_ = 0u;
  clear_has_isfirstmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::isfirstmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.IsFirstMessageInBatch)
  return isfirstmessageinbatch_;
}
inline void MarketDepthSnapshotLevel_Int::set_isfirstmessageinbatch(::google::protobuf::uint32 value) {
  set_has_isfirstmessageinbatch();
  isfirstmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.IsFirstMessageInBatch)
}

// optional uint32 IsLastMessageInBatch = 7;
inline bool MarketDepthSnapshotLevel_Int::has_islastmessageinbatch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_islastmessageinbatch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_islastmessageinbatch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketDepthSnapshotLevel_Int::clear_islastmessageinbatch() {
  islastmessageinbatch_ = 0u;
  clear_has_islastmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::islastmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.IsLastMessageInBatch)
  return islastmessageinbatch_;
}
inline void MarketDepthSnapshotLevel_Int::set_islastmessageinbatch(::google::protobuf::uint32 value) {
  set_has_islastmessageinbatch();
  islastmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.IsLastMessageInBatch)
}

// optional double DateTime = 8;
inline bool MarketDepthSnapshotLevel_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthSnapshotLevel_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDepthSnapshotLevel_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.DateTime)
  return datetime_;
}
inline void MarketDepthSnapshotLevel_Int::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.DateTime)
}

// optional uint32 NumOrders = 9;
inline bool MarketDepthSnapshotLevel_Int::has_numorders() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_numorders() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_numorders() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MarketDepthSnapshotLevel_Int::clear_numorders() {
  numorders_ = 0u;
  clear_has_numorders();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::numorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.NumOrders)
  return numorders_;
}
inline void MarketDepthSnapshotLevel_Int::set_numorders(::google::protobuf::uint32 value) {
  set_has_numorders();
  numorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.NumOrders)
}

// -------------------------------------------------------------------

// MarketDepthUpdateLevel

// optional uint32 SymbolID = 1;
inline bool MarketDepthUpdateLevel::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthUpdateLevel::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthUpdateLevel::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevel::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.SymbolID)
  return symbolid_;
}
inline void MarketDepthUpdateLevel::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthUpdateLevel::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthUpdateLevel::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthUpdateLevel::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthUpdateLevel::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthUpdateLevel::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.Side)
}

// optional double Price = 3;
inline bool MarketDepthUpdateLevel::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthUpdateLevel::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthUpdateLevel::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDepthUpdateLevel::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.Price)
  return price_;
}
inline void MarketDepthUpdateLevel::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.Price)
}

// optional double Quantity = 4;
inline bool MarketDepthUpdateLevel::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthUpdateLevel::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthUpdateLevel::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double MarketDepthUpdateLevel::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.Quantity)
  return quantity_;
}
inline void MarketDepthUpdateLevel::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.Quantity)
}

// optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
inline bool MarketDepthUpdateLevel::has_updatetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_updatetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthUpdateLevel::clear_has_updatetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthUpdateLevel::clear_updatetype() {
  updatetype_ = 0;
  clear_has_updatetype();
}
inline ::DTC_PB::MarketDepthUpdateTypeEnum MarketDepthUpdateLevel::updatetype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.UpdateType)
  return static_cast< ::DTC_PB::MarketDepthUpdateTypeEnum >(updatetype_);
}
inline void MarketDepthUpdateLevel::set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value) {
  assert(::DTC_PB::MarketDepthUpdateTypeEnum_IsValid(value));
  set_has_updatetype();
  updatetype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.UpdateType)
}

// optional double DateTime = 6;
inline bool MarketDepthUpdateLevel::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthUpdateLevel::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthUpdateLevel::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDepthUpdateLevel::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.DateTime)
  return datetime_;
}
inline void MarketDepthUpdateLevel::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.DateTime)
}

// optional uint32 NumOrders = 7;
inline bool MarketDepthUpdateLevel::has_numorders() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_numorders() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthUpdateLevel::clear_has_numorders() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthUpdateLevel::clear_numorders() {
  numorders_ = 0u;
  clear_has_numorders();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevel::numorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.NumOrders)
  return numorders_;
}
inline void MarketDepthUpdateLevel::set_numorders(::google::protobuf::uint32 value) {
  set_has_numorders();
  numorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.NumOrders)
}

// -------------------------------------------------------------------

// MarketDepthUpdateLevel_Int

// optional uint32 SymbolID = 1;
inline bool MarketDepthUpdateLevel_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthUpdateLevel_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevel_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.SymbolID)
  return symbolid_;
}
inline void MarketDepthUpdateLevel_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthUpdateLevel_Int::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthUpdateLevel_Int::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthUpdateLevel_Int::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthUpdateLevel_Int::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.Side)
}

// optional int32 Price = 3;
inline bool MarketDepthUpdateLevel_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthUpdateLevel_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDepthUpdateLevel_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.Price)
  return price_;
}
inline void MarketDepthUpdateLevel_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.Price)
}

// optional int32 Quantity = 4;
inline bool MarketDepthUpdateLevel_Int::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthUpdateLevel_Int::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 MarketDepthUpdateLevel_Int::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.Quantity)
  return quantity_;
}
inline void MarketDepthUpdateLevel_Int::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.Quantity)
}

// optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
inline bool MarketDepthUpdateLevel_Int::has_updatetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_updatetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_updatetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthUpdateLevel_Int::clear_updatetype() {
  updatetype_ = 0;
  clear_has_updatetype();
}
inline ::DTC_PB::MarketDepthUpdateTypeEnum MarketDepthUpdateLevel_Int::updatetype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.UpdateType)
  return static_cast< ::DTC_PB::MarketDepthUpdateTypeEnum >(updatetype_);
}
inline void MarketDepthUpdateLevel_Int::set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value) {
  assert(::DTC_PB::MarketDepthUpdateTypeEnum_IsValid(value));
  set_has_updatetype();
  updatetype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.UpdateType)
}

// optional double DateTime = 6;
inline bool MarketDepthUpdateLevel_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthUpdateLevel_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDepthUpdateLevel_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.DateTime)
  return datetime_;
}
inline void MarketDepthUpdateLevel_Int::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.DateTime)
}

// optional uint32 NumOrders = 7;
inline bool MarketDepthUpdateLevel_Int::has_numorders() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_numorders() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_numorders() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthUpdateLevel_Int::clear_numorders() {
  numorders_ = 0u;
  clear_has_numorders();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevel_Int::numorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.NumOrders)
  return numorders_;
}
inline void MarketDepthUpdateLevel_Int::set_numorders(::google::protobuf::uint32 value) {
  set_has_numorders();
  numorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.NumOrders)
}

// -------------------------------------------------------------------

// MarketDepthUpdateLevelCompact

// optional uint32 SymbolID = 1;
inline bool MarketDepthUpdateLevelCompact::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthUpdateLevelCompact::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevelCompact::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.SymbolID)
  return symbolid_;
}
inline void MarketDepthUpdateLevelCompact::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthUpdateLevelCompact::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthUpdateLevelCompact::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthUpdateLevelCompact::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthUpdateLevelCompact::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.Side)
}

// optional float Price = 3;
inline bool MarketDepthUpdateLevelCompact::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthUpdateLevelCompact::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float MarketDepthUpdateLevelCompact::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.Price)
  return price_;
}
inline void MarketDepthUpdateLevelCompact::set_price(float value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.Price)
}

// optional float Quantity = 4;
inline bool MarketDepthUpdateLevelCompact::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthUpdateLevelCompact::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float MarketDepthUpdateLevelCompact::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.Quantity)
  return quantity_;
}
inline void MarketDepthUpdateLevelCompact::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.Quantity)
}

// optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
inline bool MarketDepthUpdateLevelCompact::has_updatetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_updatetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_updatetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthUpdateLevelCompact::clear_updatetype() {
  updatetype_ = 0;
  clear_has_updatetype();
}
inline ::DTC_PB::MarketDepthUpdateTypeEnum MarketDepthUpdateLevelCompact::updatetype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.UpdateType)
  return static_cast< ::DTC_PB::MarketDepthUpdateTypeEnum >(updatetype_);
}
inline void MarketDepthUpdateLevelCompact::set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value) {
  assert(::DTC_PB::MarketDepthUpdateTypeEnum_IsValid(value));
  set_has_updatetype();
  updatetype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.UpdateType)
}

// optional uint32 DateTime = 6;
inline bool MarketDepthUpdateLevelCompact::has_datetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_datetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthUpdateLevelCompact::clear_datetime() {
  datetime_ = 0u;
  clear_has_datetime();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevelCompact::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.DateTime)
  return datetime_;
}
inline void MarketDepthUpdateLevelCompact::set_datetime(::google::protobuf::uint32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.DateTime)
}

// optional uint32 NumOrders = 7;
inline bool MarketDepthUpdateLevelCompact::has_numorders() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_numorders() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_numorders() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthUpdateLevelCompact::clear_numorders() {
  numorders_ = 0u;
  clear_has_numorders();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevelCompact::numorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.NumOrders)
  return numorders_;
}
inline void MarketDepthUpdateLevelCompact::set_numorders(::google::protobuf::uint32 value) {
  set_has_numorders();
  numorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.NumOrders)
}

// -------------------------------------------------------------------

// MarketDepthUpdateLevelCompact2

// optional uint32 SymbolID = 1;
inline bool MarketDepthUpdateLevelCompact2::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthUpdateLevelCompact2::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthUpdateLevelCompact2::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthUpdateLevelCompact2::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevelCompact2::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact2.SymbolID)
  return symbolid_;
}
inline void MarketDepthUpdateLevelCompact2::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact2.SymbolID)
}

// optional int32 Side = 2;
inline bool MarketDepthUpdateLevelCompact2::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthUpdateLevelCompact2::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthUpdateLevelCompact2::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthUpdateLevelCompact2::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::google::protobuf::int32 MarketDepthUpdateLevelCompact2::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact2.Side)
  return side_;
}
inline void MarketDepthUpdateLevelCompact2::set_side(::google::protobuf::int32 value) {
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact2.Side)
}

// optional int32 UpdateType = 3;
inline bool MarketDepthUpdateLevelCompact2::has_updatetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthUpdateLevelCompact2::set_has_updatetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthUpdateLevelCompact2::clear_has_updatetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthUpdateLevelCompact2::clear_updatetype() {
  updatetype_ = 0;
  clear_has_updatetype();
}
inline ::google::protobuf::int32 MarketDepthUpdateLevelCompact2::updatetype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact2.UpdateType)
  return updatetype_;
}
inline void MarketDepthUpdateLevelCompact2::set_updatetype(::google::protobuf::int32 value) {
  set_has_updatetype();
  updatetype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact2.UpdateType)
}

// optional uint32 NumOrders = 4;
inline bool MarketDepthUpdateLevelCompact2::has_numorders() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthUpdateLevelCompact2::set_has_numorders() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthUpdateLevelCompact2::clear_has_numorders() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthUpdateLevelCompact2::clear_numorders() {
  numorders_ = 0u;
  clear_has_numorders();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevelCompact2::numorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact2.NumOrders)
  return numorders_;
}
inline void MarketDepthUpdateLevelCompact2::set_numorders(::google::protobuf::uint32 value) {
  set_has_numorders();
  numorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact2.NumOrders)
}

// optional float Price = 5;
inline bool MarketDepthUpdateLevelCompact2::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthUpdateLevelCompact2::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthUpdateLevelCompact2::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthUpdateLevelCompact2::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float MarketDepthUpdateLevelCompact2::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact2.Price)
  return price_;
}
inline void MarketDepthUpdateLevelCompact2::set_price(float value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact2.Price)
}

// optional float Quantity = 6;
inline bool MarketDepthUpdateLevelCompact2::has_quantity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthUpdateLevelCompact2::set_has_quantity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthUpdateLevelCompact2::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthUpdateLevelCompact2::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float MarketDepthUpdateLevelCompact2::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact2.Quantity)
  return quantity_;
}
inline void MarketDepthUpdateLevelCompact2::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact2.Quantity)
}

// optional uint32 DateTime = 7;
inline bool MarketDepthUpdateLevelCompact2::has_datetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthUpdateLevelCompact2::set_has_datetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthUpdateLevelCompact2::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthUpdateLevelCompact2::clear_datetime() {
  datetime_ = 0u;
  clear_has_datetime();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevelCompact2::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact2.DateTime)
  return datetime_;
}
inline void MarketDepthUpdateLevelCompact2::set_datetime(::google::protobuf::uint32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact2.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionSettlement

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionSettlement::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionSettlement::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionSettlement::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionSettlement::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionSettlement::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionSettlement::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionSettlement::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionSettlement::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionSettlement::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionSettlement::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionSettlement::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement.Price)
  return price_;
}
inline void MarketDataUpdateSessionSettlement::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement.Price)
}

// optional uint32 DateTime = 3;
inline bool MarketDataUpdateSessionSettlement::has_datetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionSettlement::set_has_datetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionSettlement::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionSettlement::clear_datetime() {
  datetime_ = 0u;
  clear_has_datetime();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionSettlement::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement.DateTime)
  return datetime_;
}
inline void MarketDataUpdateSessionSettlement::set_datetime(::google::protobuf::uint32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionSettlement_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionSettlement_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionSettlement_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionSettlement_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionSettlement_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionSettlement_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionSettlement_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionSettlement_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionSettlement_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement_Int.Price)
}

// optional int32 DateTime = 3;
inline bool MarketDataUpdateSessionSettlement_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionSettlement_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionSettlement_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement_Int.DateTime)
  return datetime_;
}
inline void MarketDataUpdateSessionSettlement_Int::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement_Int.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionOpen

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionOpen::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionOpen::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionOpen::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionOpen::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionOpen::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionOpen::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionOpen::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionOpen::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionOpen::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionOpen::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionOpen::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen.Price)
  return price_;
}
inline void MarketDataUpdateSessionOpen::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen.Price)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionOpen::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionOpen::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionOpen::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionOpen::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionOpen::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionOpen::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionOpen_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionOpen_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionOpen_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionOpen_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionOpen_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionOpen_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionOpen_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionOpen_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionOpen_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen_Int.Price)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionOpen_Int::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionOpen_Int::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionOpen_Int::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen_Int.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionOpen_Int::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen_Int.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionNumTrades

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionNumTrades::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionNumTrades::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionNumTrades::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionNumTrades::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionNumTrades::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionNumTrades.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionNumTrades::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionNumTrades.SymbolID)
}

// optional int32 NumTrades = 2;
inline bool MarketDataUpdateSessionNumTrades::has_numtrades() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionNumTrades::set_has_numtrades() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionNumTrades::clear_has_numtrades() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionNumTrades::clear_numtrades() {
  numtrades_ = 0;
  clear_has_numtrades();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionNumTrades::numtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionNumTrades.NumTrades)
  return numtrades_;
}
inline void MarketDataUpdateSessionNumTrades::set_numtrades(::google::protobuf::int32 value) {
  set_has_numtrades();
  numtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionNumTrades.NumTrades)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionNumTrades::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionNumTrades::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionNumTrades::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionNumTrades::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionNumTrades::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionNumTrades.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionNumTrades::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionNumTrades.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateTradingSessionDate

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateTradingSessionDate::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTradingSessionDate::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTradingSessionDate::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTradingSessionDate::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTradingSessionDate::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradingSessionDate.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTradingSessionDate::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradingSessionDate.SymbolID)
}

// optional uint32 Date = 2;
inline bool MarketDataUpdateTradingSessionDate::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTradingSessionDate::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTradingSessionDate::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTradingSessionDate::clear_date() {
  date_ = 0u;
  clear_has_date();
}
inline ::google::protobuf::uint32 MarketDataUpdateTradingSessionDate::date() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradingSessionDate.Date)
  return date_;
}
inline void MarketDataUpdateTradingSessionDate::set_date(::google::protobuf::uint32 value) {
  set_has_date();
  date_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradingSessionDate.Date)
}

// -------------------------------------------------------------------

// MarketDepthReject

// optional uint32 SymbolID = 1;
inline bool MarketDepthReject::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthReject::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthReject::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthReject::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthReject::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthReject.SymbolID)
  return symbolid_;
}
inline void MarketDepthReject::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthReject.SymbolID)
}

// optional string RejectText = 2;
inline bool MarketDepthReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& MarketDepthReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void MarketDepthReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthReject.RejectText)
}
#if LANG_CXX11
inline void MarketDepthReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.MarketDepthReject.RejectText)
}
#endif
inline void MarketDepthReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDepthReject.RejectText)
}
inline void MarketDepthReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDepthReject.RejectText)
}
inline ::std::string* MarketDepthReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketDepthReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.MarketDepthReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketDepthReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDepthReject.RejectText)
}

// -------------------------------------------------------------------

// MarketDataUpdateTrade

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateTrade::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTrade::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTrade::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTrade::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTrade::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTrade::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
inline bool MarketDataUpdateTrade::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTrade::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTrade::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTrade::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDataUpdateTrade::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void MarketDataUpdateTrade::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.AtBidOrAsk)
}

// optional double Price = 3;
inline bool MarketDataUpdateTrade::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateTrade::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateTrade::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateTrade::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateTrade::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.Price)
  return price_;
}
inline void MarketDataUpdateTrade::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.Price)
}

// optional double Volume = 4;
inline bool MarketDataUpdateTrade::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateTrade::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateTrade::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateTrade::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double MarketDataUpdateTrade::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.Volume)
  return volume_;
}
inline void MarketDataUpdateTrade::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.Volume)
}

// optional double DateTime = 5;
inline bool MarketDataUpdateTrade::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateTrade::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateTrade::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateTrade::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDataUpdateTrade::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.DateTime)
  return datetime_;
}
inline void MarketDataUpdateTrade::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateTrade_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateTrade_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTrade_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTrade_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTrade_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTrade_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
inline bool MarketDataUpdateTrade_Int::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTrade_Int::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTrade_Int::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDataUpdateTrade_Int::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void MarketDataUpdateTrade_Int::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.AtBidOrAsk)
}

// optional int32 Price = 3;
inline bool MarketDataUpdateTrade_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateTrade_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateTrade_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateTrade_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.Price)
  return price_;
}
inline void MarketDataUpdateTrade_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.Price)
}

// optional int32 Volume = 4;
inline bool MarketDataUpdateTrade_Int::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateTrade_Int::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateTrade_Int::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 MarketDataUpdateTrade_Int::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.Volume)
  return volume_;
}
inline void MarketDataUpdateTrade_Int::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.Volume)
}

// optional double DateTime = 5;
inline bool MarketDataUpdateTrade_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateTrade_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateTrade_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDataUpdateTrade_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.DateTime)
  return datetime_;
}
inline void MarketDataUpdateTrade_Int::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateTradeWithUnbundledIndicator

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateTradeWithUnbundledIndicator::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTradeWithUnbundledIndicator::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum8 AtBidOrAsk = 2;
inline bool MarketDataUpdateTradeWithUnbundledIndicator::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum8 MarketDataUpdateTradeWithUnbundledIndicator::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum8 >(atbidorask_);
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_atbidorask(::DTC_PB::AtBidOrAskEnum8 value) {
  assert(::DTC_PB::AtBidOrAskEnum8_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.AtBidOrAsk)
}

// optional .DTC_PB.UnbundledTradeIndicatorEnum UnbundledTradeIndicator = 3;
inline bool MarketDataUpdateTradeWithUnbundledIndicator::has_unbundledtradeindicator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_has_unbundledtradeindicator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_has_unbundledtradeindicator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_unbundledtradeindicator() {
  unbundledtradeindicator_ = 0;
  clear_has_unbundledtradeindicator();
}
inline ::DTC_PB::UnbundledTradeIndicatorEnum MarketDataUpdateTradeWithUnbundledIndicator::unbundledtradeindicator() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.UnbundledTradeIndicator)
  return static_cast< ::DTC_PB::UnbundledTradeIndicatorEnum >(unbundledtradeindicator_);
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_unbundledtradeindicator(::DTC_PB::UnbundledTradeIndicatorEnum value) {
  assert(::DTC_PB::UnbundledTradeIndicatorEnum_IsValid(value));
  set_has_unbundledtradeindicator();
  unbundledtradeindicator_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.UnbundledTradeIndicator)
}

// optional double Price = 4;
inline bool MarketDataUpdateTradeWithUnbundledIndicator::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateTradeWithUnbundledIndicator::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.Price)
  return price_;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.Price)
}

// optional uint32 Volume = 5;
inline bool MarketDataUpdateTradeWithUnbundledIndicator::has_volume() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_has_volume() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_has_volume() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_volume() {
  volume_ = 0u;
  clear_has_volume();
}
inline ::google::protobuf::uint32 MarketDataUpdateTradeWithUnbundledIndicator::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.Volume)
  return volume_;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_volume(::google::protobuf::uint32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.Volume)
}

// optional double DateTime = 6;
inline bool MarketDataUpdateTradeWithUnbundledIndicator::has_datetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_has_datetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDataUpdateTradeWithUnbundledIndicator::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.DateTime)
  return datetime_;
}
inline void MarketDataUpdateTradeWithUnbundledIndicator::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeWithUnbundledIndicator.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateBidAsk

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateBidAsk::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateBidAsk::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateBidAsk::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateBidAsk::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateBidAsk::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.SymbolID)
}

// optional double BidPrice = 2;
inline bool MarketDataUpdateBidAsk::has_bidprice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_bidprice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateBidAsk::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateBidAsk::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline double MarketDataUpdateBidAsk::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.BidPrice)
  return bidprice_;
}
inline void MarketDataUpdateBidAsk::set_bidprice(double value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.BidPrice)
}

// optional float BidQuantity = 3;
inline bool MarketDataUpdateBidAsk::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateBidAsk::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateBidAsk::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline float MarketDataUpdateBidAsk::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.BidQuantity)
  return bidquantity_;
}
inline void MarketDataUpdateBidAsk::set_bidquantity(float value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.BidQuantity)
}

// optional double AskPrice = 4;
inline bool MarketDataUpdateBidAsk::has_askprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_askprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateBidAsk::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateBidAsk::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline double MarketDataUpdateBidAsk::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.AskPrice)
  return askprice_;
}
inline void MarketDataUpdateBidAsk::set_askprice(double value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.AskPrice)
}

// optional float AskQuantity = 5;
inline bool MarketDataUpdateBidAsk::has_askquantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_askquantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateBidAsk::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateBidAsk::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline float MarketDataUpdateBidAsk::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.AskQuantity)
  return askquantity_;
}
inline void MarketDataUpdateBidAsk::set_askquantity(float value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.AskQuantity)
}

// optional sfixed32 DateTime = 6;
inline bool MarketDataUpdateBidAsk::has_datetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_datetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataUpdateBidAsk::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataUpdateBidAsk::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.DateTime)
  return datetime_;
}
inline void MarketDataUpdateBidAsk::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateBidAsk_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateBidAsk_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateBidAsk_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateBidAsk_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateBidAsk_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.SymbolID)
}

// optional int32 BidPrice = 2;
inline bool MarketDataUpdateBidAsk_Int::has_bidprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_bidprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateBidAsk_Int::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.BidPrice)
  return bidprice_;
}
inline void MarketDataUpdateBidAsk_Int::set_bidprice(::google::protobuf::int32 value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.BidPrice)
}

// optional int32 BidQuantity = 3;
inline bool MarketDataUpdateBidAsk_Int::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateBidAsk_Int::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.BidQuantity)
  return bidquantity_;
}
inline void MarketDataUpdateBidAsk_Int::set_bidquantity(::google::protobuf::int32 value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.BidQuantity)
}

// optional int32 AskPrice = 4;
inline bool MarketDataUpdateBidAsk_Int::has_askprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_askprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateBidAsk_Int::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.AskPrice)
  return askprice_;
}
inline void MarketDataUpdateBidAsk_Int::set_askprice(::google::protobuf::int32 value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.AskPrice)
}

// optional int32 AskQuantity = 5;
inline bool MarketDataUpdateBidAsk_Int::has_askquantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_askquantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateBidAsk_Int::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.AskQuantity)
  return askquantity_;
}
inline void MarketDataUpdateBidAsk_Int::set_askquantity(::google::protobuf::int32 value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.AskQuantity)
}

// optional sfixed32 DateTime = 6;
inline bool MarketDataUpdateBidAsk_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataUpdateBidAsk_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.DateTime)
  return datetime_;
}
inline void MarketDataUpdateBidAsk_Int::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateBidAskCompact

// optional float BidPrice = 1;
inline bool MarketDataUpdateBidAskCompact::has_bidprice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_bidprice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateBidAskCompact::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline float MarketDataUpdateBidAskCompact::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.BidPrice)
  return bidprice_;
}
inline void MarketDataUpdateBidAskCompact::set_bidprice(float value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.BidPrice)
}

// optional float BidQuantity = 2;
inline bool MarketDataUpdateBidAskCompact::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateBidAskCompact::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline float MarketDataUpdateBidAskCompact::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.BidQuantity)
  return bidquantity_;
}
inline void MarketDataUpdateBidAskCompact::set_bidquantity(float value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.BidQuantity)
}

// optional float AskPrice = 3;
inline bool MarketDataUpdateBidAskCompact::has_askprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_askprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateBidAskCompact::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline float MarketDataUpdateBidAskCompact::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.AskPrice)
  return askprice_;
}
inline void MarketDataUpdateBidAskCompact::set_askprice(float value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.AskPrice)
}

// optional float AskQuantity = 4;
inline bool MarketDataUpdateBidAskCompact::has_askquantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_askquantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateBidAskCompact::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline float MarketDataUpdateBidAskCompact::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.AskQuantity)
  return askquantity_;
}
inline void MarketDataUpdateBidAskCompact::set_askquantity(float value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.AskQuantity)
}

// optional sfixed32 DateTime = 5;
inline bool MarketDataUpdateBidAskCompact::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateBidAskCompact::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAskCompact::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.DateTime)
  return datetime_;
}
inline void MarketDataUpdateBidAskCompact::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.DateTime)
}

// optional uint32 SymbolID = 6;
inline bool MarketDataUpdateBidAskCompact::has_symbolid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_symbolid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataUpdateBidAskCompact::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateBidAskCompact::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateBidAskCompact::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.SymbolID)
}

// -------------------------------------------------------------------

// MarketDataUpdateTradeCompact

// optional float Price = 1;
inline bool MarketDataUpdateTradeCompact::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTradeCompact::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTradeCompact::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float MarketDataUpdateTradeCompact::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.Price)
  return price_;
}
inline void MarketDataUpdateTradeCompact::set_price(float value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.Price)
}

// optional float Volume = 2;
inline bool MarketDataUpdateTradeCompact::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTradeCompact::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTradeCompact::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline float MarketDataUpdateTradeCompact::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.Volume)
  return volume_;
}
inline void MarketDataUpdateTradeCompact::set_volume(float value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.Volume)
}

// optional sfixed32 DateTime = 3;
inline bool MarketDataUpdateTradeCompact::has_datetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_datetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateTradeCompact::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateTradeCompact::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateTradeCompact::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.DateTime)
  return datetime_;
}
inline void MarketDataUpdateTradeCompact::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.DateTime)
}

// optional uint32 SymbolID = 4;
inline bool MarketDataUpdateTradeCompact::has_symbolid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_symbolid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateTradeCompact::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateTradeCompact::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTradeCompact::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTradeCompact::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
inline bool MarketDataUpdateTradeCompact::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateTradeCompact::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateTradeCompact::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDataUpdateTradeCompact::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void MarketDataUpdateTradeCompact::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.AtBidOrAsk)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionVolume

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionVolume::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionVolume::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionVolume::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionVolume::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionVolume::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionVolume.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionVolume::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionVolume.SymbolID)
}

// optional double Volume = 2;
inline bool MarketDataUpdateSessionVolume::has_volume() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionVolume::set_has_volume() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionVolume::clear_has_volume() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionVolume::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double MarketDataUpdateSessionVolume::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionVolume.Volume)
  return volume_;
}
inline void MarketDataUpdateSessionVolume::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionVolume.Volume)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionVolume::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionVolume::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionVolume::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionVolume::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionVolume::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionVolume.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionVolume::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionVolume.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateOpenInterest

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateOpenInterest::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateOpenInterest::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateOpenInterest::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateOpenInterest::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateOpenInterest::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateOpenInterest.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateOpenInterest::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateOpenInterest.SymbolID)
}

// optional uint32 OpenInterest = 2;
inline bool MarketDataUpdateOpenInterest::has_openinterest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateOpenInterest::set_has_openinterest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateOpenInterest::clear_has_openinterest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateOpenInterest::clear_openinterest() {
  openinterest_ = 0u;
  clear_has_openinterest();
}
inline ::google::protobuf::uint32 MarketDataUpdateOpenInterest::openinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateOpenInterest.OpenInterest)
  return openinterest_;
}
inline void MarketDataUpdateOpenInterest::set_openinterest(::google::protobuf::uint32 value) {
  set_has_openinterest();
  openinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateOpenInterest.OpenInterest)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateOpenInterest::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateOpenInterest::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateOpenInterest::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateOpenInterest::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateOpenInterest::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateOpenInterest.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateOpenInterest::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateOpenInterest.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionHigh

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionHigh::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionHigh::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionHigh::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionHigh::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionHigh::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionHigh::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionHigh::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionHigh::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionHigh::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionHigh::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionHigh::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh.Price)
  return price_;
}
inline void MarketDataUpdateSessionHigh::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh.Price)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionHigh::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionHigh::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionHigh::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionHigh::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionHigh::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionHigh::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionHigh_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionHigh_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionHigh_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionHigh_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionHigh_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionHigh_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionHigh_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionHigh_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionHigh_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh_Int.Price)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionHigh_Int::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionHigh_Int::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionHigh_Int::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh_Int.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionHigh_Int::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh_Int.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionLow

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionLow::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionLow::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionLow::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionLow::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionLow::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionLow::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionLow::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionLow::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionLow::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionLow::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionLow::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow.Price)
  return price_;
}
inline void MarketDataUpdateSessionLow::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow.Price)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionLow::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionLow::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionLow::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionLow::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionLow::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionLow::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionLow_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionLow_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionLow_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionLow_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionLow_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionLow_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionLow_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionLow_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionLow_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionLow_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionLow_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionLow_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionLow_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow_Int.Price)
}

// optional uint32 TradingSessionDate = 3;
inline bool MarketDataUpdateSessionLow_Int::has_tradingsessiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateSessionLow_Int::set_has_tradingsessiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateSessionLow_Int::clear_has_tradingsessiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateSessionLow_Int::clear_tradingsessiondate() {
  tradingsessiondate_ = 0u;
  clear_has_tradingsessiondate();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionLow_Int::tradingsessiondate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow_Int.TradingSessionDate)
  return tradingsessiondate_;
}
inline void MarketDataUpdateSessionLow_Int::set_tradingsessiondate(::google::protobuf::uint32 value) {
  set_has_tradingsessiondate();
  tradingsessiondate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow_Int.TradingSessionDate)
}

// -------------------------------------------------------------------

// MarketDataUpdateLastTradeSnapshot

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateLastTradeSnapshot::has_symbolid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_symbolid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateLastTradeSnapshot::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.SymbolID)
}

// optional double LastTradePrice = 2;
inline bool MarketDataUpdateLastTradeSnapshot::has_lasttradeprice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_lasttradeprice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_lasttradeprice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_lasttradeprice() {
  lasttradeprice_ = 0;
  clear_has_lasttradeprice();
}
inline double MarketDataUpdateLastTradeSnapshot::lasttradeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradePrice)
  return lasttradeprice_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_lasttradeprice(double value) {
  set_has_lasttradeprice();
  lasttradeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradePrice)
}

// optional double LastTradeVolume = 3;
inline bool MarketDataUpdateLastTradeSnapshot::has_lasttradevolume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_lasttradevolume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_lasttradevolume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_lasttradevolume() {
  lasttradevolume_ = 0;
  clear_has_lasttradevolume();
}
inline double MarketDataUpdateLastTradeSnapshot::lasttradevolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeVolume)
  return lasttradevolume_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_lasttradevolume(double value) {
  set_has_lasttradevolume();
  lasttradevolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeVolume)
}

// optional double LastTradeDateTime = 4;
inline bool MarketDataUpdateLastTradeSnapshot::has_lasttradedatetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_lasttradedatetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_lasttradedatetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_lasttradedatetime() {
  lasttradedatetime_ = 0;
  clear_has_lasttradedatetime();
}
inline double MarketDataUpdateLastTradeSnapshot::lasttradedatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeDateTime)
  return lasttradedatetime_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_lasttradedatetime(double value) {
  set_has_lasttradedatetime();
  lasttradedatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeDateTime)
}

// -------------------------------------------------------------------

// SubmitNewSingleOrder

// optional string Symbol = 1;
inline bool SubmitNewSingleOrder::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewSingleOrder::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewSingleOrder::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewSingleOrder::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SubmitNewSingleOrder::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Symbol)
  return symbol_.GetNoArena();
}
inline void SubmitNewSingleOrder::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Symbol)
}
#if LANG_CXX11
inline void SubmitNewSingleOrder::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrder.Symbol)
}
#endif
inline void SubmitNewSingleOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.Symbol)
}
inline void SubmitNewSingleOrder::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.Symbol)
}
inline ::std::string* SubmitNewSingleOrder::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrder.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewSingleOrder::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewSingleOrder::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewSingleOrder::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewSingleOrder::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SubmitNewSingleOrder::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Exchange)
  return exchange_.GetNoArena();
}
inline void SubmitNewSingleOrder::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Exchange)
}
#if LANG_CXX11
inline void SubmitNewSingleOrder::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrder.Exchange)
}
#endif
inline void SubmitNewSingleOrder::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.Exchange)
}
inline void SubmitNewSingleOrder::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.Exchange)
}
inline ::std::string* SubmitNewSingleOrder::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrder::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrder.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrder::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.Exchange)
}

// optional string TradeAccount = 3;
inline bool SubmitNewSingleOrder::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewSingleOrder::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewSingleOrder::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewSingleOrder::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewSingleOrder::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void SubmitNewSingleOrder::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}
#if LANG_CXX11
inline void SubmitNewSingleOrder::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}
#endif
inline void SubmitNewSingleOrder::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}
inline void SubmitNewSingleOrder::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}
inline ::std::string* SubmitNewSingleOrder::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrder::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrder.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrder::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}

// optional string ClientOrderID = 4;
inline bool SubmitNewSingleOrder::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewSingleOrder::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewSingleOrder::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewSingleOrder::clear_clientorderid() {
  clientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid();
}
inline const ::std::string& SubmitNewSingleOrder::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
  return clientorderid_.GetNoArena();
}
inline void SubmitNewSingleOrder::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}
#if LANG_CXX11
inline void SubmitNewSingleOrder::set_clientorderid(::std::string&& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}
#endif
inline void SubmitNewSingleOrder::set_clientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}
inline void SubmitNewSingleOrder::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}
inline ::std::string* SubmitNewSingleOrder::mutable_clientorderid() {
  set_has_clientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
  return clientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrder::release_clientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
  if (!has_clientorderid()) {
    return NULL;
  }
  clear_has_clientorderid();
  return clientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrder::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid != NULL) {
    set_has_clientorderid();
  } else {
    clear_has_clientorderid();
  }
  clientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}

// optional .DTC_PB.OrderTypeEnum OrderType = 5;
inline bool SubmitNewSingleOrder::has_ordertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewSingleOrder::set_has_ordertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewSingleOrder::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewSingleOrder::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewSingleOrder::ordertype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.OrderType)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_);
}
inline void SubmitNewSingleOrder::set_ordertype(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.OrderType)
}

// optional .DTC_PB.BuySellEnum BuySell = 6;
inline bool SubmitNewSingleOrder::has_buysell() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewSingleOrder::set_has_buysell() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewSingleOrder::clear_has_buysell() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewSingleOrder::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum SubmitNewSingleOrder::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void SubmitNewSingleOrder::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.BuySell)
}

// optional double Price1 = 7;
inline bool SubmitNewSingleOrder::has_price1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewSingleOrder::set_has_price1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewSingleOrder::clear_has_price1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewSingleOrder::clear_price1() {
  price1_ = 0;
  clear_has_price1();
}
inline double SubmitNewSingleOrder::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Price1)
  return price1_;
}
inline void SubmitNewSingleOrder::set_price1(double value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Price1)
}

// optional double Price2 = 8;
inline bool SubmitNewSingleOrder::has_price2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewSingleOrder::set_has_price2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewSingleOrder::clear_has_price2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewSingleOrder::clear_price2() {
  price2_ = 0;
  clear_has_price2();
}
inline double SubmitNewSingleOrder::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Price2)
  return price2_;
}
inline void SubmitNewSingleOrder::set_price2(double value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Price2)
}

// optional double Quantity = 9;
inline bool SubmitNewSingleOrder::has_quantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewSingleOrder::set_has_quantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewSingleOrder::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewSingleOrder::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double SubmitNewSingleOrder::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Quantity)
  return quantity_;
}
inline void SubmitNewSingleOrder::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Quantity)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 10;
inline bool SubmitNewSingleOrder::has_timeinforce() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewSingleOrder::set_has_timeinforce() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewSingleOrder::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewSingleOrder::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewSingleOrder::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewSingleOrder::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 11;
inline bool SubmitNewSingleOrder::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewSingleOrder::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewSingleOrder::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewSingleOrder::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewSingleOrder::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewSingleOrder::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.GoodTillDateTime)
}

// optional uint32 IsAutomatedOrder = 12;
inline bool SubmitNewSingleOrder::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewSingleOrder::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewSingleOrder::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewSingleOrder::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrder::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewSingleOrder::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.IsAutomatedOrder)
}

// optional uint32 IsParentOrder = 13;
inline bool SubmitNewSingleOrder::has_isparentorder() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewSingleOrder::set_has_isparentorder() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewSingleOrder::clear_has_isparentorder() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewSingleOrder::clear_isparentorder() {
  isparentorder_ = 0u;
  clear_has_isparentorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrder::isparentorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.IsParentOrder)
  return isparentorder_;
}
inline void SubmitNewSingleOrder::set_isparentorder(::google::protobuf::uint32 value) {
  set_has_isparentorder();
  isparentorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.IsParentOrder)
}

// optional string FreeFormText = 14;
inline bool SubmitNewSingleOrder::has_freeformtext() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewSingleOrder::set_has_freeformtext() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewSingleOrder::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewSingleOrder::clear_freeformtext() {
  freeformtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewSingleOrder::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.FreeFormText)
  return freeformtext_.GetNoArena();
}
inline void SubmitNewSingleOrder::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}
#if LANG_CXX11
inline void SubmitNewSingleOrder::set_freeformtext(::std::string&& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}
#endif
inline void SubmitNewSingleOrder::set_freeformtext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}
inline void SubmitNewSingleOrder::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}
inline ::std::string* SubmitNewSingleOrder::mutable_freeformtext() {
  set_has_freeformtext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.FreeFormText)
  return freeformtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrder::release_freeformtext() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrder.FreeFormText)
  if (!has_freeformtext()) {
    return NULL;
  }
  clear_has_freeformtext();
  return freeformtext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrder::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext != NULL) {
    set_has_freeformtext();
  } else {
    clear_has_freeformtext();
  }
  freeformtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), freeformtext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 15;
inline bool SubmitNewSingleOrder::has_openorclose() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewSingleOrder::set_has_openorclose() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewSingleOrder::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewSingleOrder::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewSingleOrder::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewSingleOrder::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.OpenOrClose)
}

// -------------------------------------------------------------------

// SubmitNewSingleOrderInt

// optional string Symbol = 1;
inline bool SubmitNewSingleOrderInt::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewSingleOrderInt::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewSingleOrderInt::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SubmitNewSingleOrderInt::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Symbol)
  return symbol_.GetNoArena();
}
inline void SubmitNewSingleOrderInt::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}
#if LANG_CXX11
inline void SubmitNewSingleOrderInt::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}
#endif
inline void SubmitNewSingleOrderInt::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}
inline void SubmitNewSingleOrderInt::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrderInt::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrderInt.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrderInt::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewSingleOrderInt::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewSingleOrderInt::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewSingleOrderInt::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SubmitNewSingleOrderInt::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Exchange)
  return exchange_.GetNoArena();
}
inline void SubmitNewSingleOrderInt::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}
#if LANG_CXX11
inline void SubmitNewSingleOrderInt::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}
#endif
inline void SubmitNewSingleOrderInt::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}
inline void SubmitNewSingleOrderInt::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrderInt::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrderInt.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrderInt::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}

// optional string TradeAccount = 3;
inline bool SubmitNewSingleOrderInt::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewSingleOrderInt::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewSingleOrderInt::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewSingleOrderInt::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void SubmitNewSingleOrderInt::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}
#if LANG_CXX11
inline void SubmitNewSingleOrderInt::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}
#endif
inline void SubmitNewSingleOrderInt::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}
inline void SubmitNewSingleOrderInt::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrderInt::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrderInt::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}

// optional string ClientOrderID = 4;
inline bool SubmitNewSingleOrderInt::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewSingleOrderInt::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewSingleOrderInt::clear_clientorderid() {
  clientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid();
}
inline const ::std::string& SubmitNewSingleOrderInt::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
  return clientorderid_.GetNoArena();
}
inline void SubmitNewSingleOrderInt::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}
#if LANG_CXX11
inline void SubmitNewSingleOrderInt::set_clientorderid(::std::string&& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}
#endif
inline void SubmitNewSingleOrderInt::set_clientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}
inline void SubmitNewSingleOrderInt::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_clientorderid() {
  set_has_clientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
  return clientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrderInt::release_clientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
  if (!has_clientorderid()) {
    return NULL;
  }
  clear_has_clientorderid();
  return clientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrderInt::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid != NULL) {
    set_has_clientorderid();
  } else {
    clear_has_clientorderid();
  }
  clientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}

// optional .DTC_PB.OrderTypeEnum OrderType = 5;
inline bool SubmitNewSingleOrderInt::has_ordertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_ordertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewSingleOrderInt::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewSingleOrderInt::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewSingleOrderInt::ordertype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.OrderType)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_);
}
inline void SubmitNewSingleOrderInt::set_ordertype(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.OrderType)
}

// optional .DTC_PB.BuySellEnum BuySell = 6;
inline bool SubmitNewSingleOrderInt::has_buysell() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_buysell() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewSingleOrderInt::clear_has_buysell() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewSingleOrderInt::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum SubmitNewSingleOrderInt::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void SubmitNewSingleOrderInt::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.BuySell)
}

// optional int64 Price1 = 7;
inline bool SubmitNewSingleOrderInt::has_price1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_price1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewSingleOrderInt::clear_has_price1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewSingleOrderInt::clear_price1() {
  price1_ = GOOGLE_LONGLONG(0);
  clear_has_price1();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Price1)
  return price1_;
}
inline void SubmitNewSingleOrderInt::set_price1(::google::protobuf::int64 value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Price1)
}

// optional int64 Price2 = 8;
inline bool SubmitNewSingleOrderInt::has_price2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_price2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewSingleOrderInt::clear_has_price2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewSingleOrderInt::clear_price2() {
  price2_ = GOOGLE_LONGLONG(0);
  clear_has_price2();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Price2)
  return price2_;
}
inline void SubmitNewSingleOrderInt::set_price2(::google::protobuf::int64 value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Price2)
}

// optional float Divisor = 9;
inline bool SubmitNewSingleOrderInt::has_divisor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_divisor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewSingleOrderInt::clear_has_divisor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewSingleOrderInt::clear_divisor() {
  divisor_ = 0;
  clear_has_divisor();
}
inline float SubmitNewSingleOrderInt::divisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Divisor)
  return divisor_;
}
inline void SubmitNewSingleOrderInt::set_divisor(float value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Divisor)
}

// optional int64 Quantity = 10;
inline bool SubmitNewSingleOrderInt::has_quantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_quantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewSingleOrderInt::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewSingleOrderInt::clear_quantity() {
  quantity_ = GOOGLE_LONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Quantity)
  return quantity_;
}
inline void SubmitNewSingleOrderInt::set_quantity(::google::protobuf::int64 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Quantity)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 11;
inline bool SubmitNewSingleOrderInt::has_timeinforce() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_timeinforce() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewSingleOrderInt::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewSingleOrderInt::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewSingleOrderInt::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewSingleOrderInt::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 12;
inline bool SubmitNewSingleOrderInt::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewSingleOrderInt::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewSingleOrderInt::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewSingleOrderInt::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.GoodTillDateTime)
}

// optional uint32 IsAutomatedOrder = 13;
inline bool SubmitNewSingleOrderInt::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewSingleOrderInt::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewSingleOrderInt::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrderInt::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewSingleOrderInt::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.IsAutomatedOrder)
}

// optional uint32 IsParentOrder = 14;
inline bool SubmitNewSingleOrderInt::has_isparentorder() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_isparentorder() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewSingleOrderInt::clear_has_isparentorder() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewSingleOrderInt::clear_isparentorder() {
  isparentorder_ = 0u;
  clear_has_isparentorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrderInt::isparentorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.IsParentOrder)
  return isparentorder_;
}
inline void SubmitNewSingleOrderInt::set_isparentorder(::google::protobuf::uint32 value) {
  set_has_isparentorder();
  isparentorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.IsParentOrder)
}

// optional string FreeFormText = 15;
inline bool SubmitNewSingleOrderInt::has_freeformtext() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_freeformtext() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewSingleOrderInt::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewSingleOrderInt::clear_freeformtext() {
  freeformtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewSingleOrderInt::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
  return freeformtext_.GetNoArena();
}
inline void SubmitNewSingleOrderInt::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}
#if LANG_CXX11
inline void SubmitNewSingleOrderInt::set_freeformtext(::std::string&& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}
#endif
inline void SubmitNewSingleOrderInt::set_freeformtext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}
inline void SubmitNewSingleOrderInt::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_freeformtext() {
  set_has_freeformtext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
  return freeformtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewSingleOrderInt::release_freeformtext() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
  if (!has_freeformtext()) {
    return NULL;
  }
  clear_has_freeformtext();
  return freeformtext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewSingleOrderInt::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext != NULL) {
    set_has_freeformtext();
  } else {
    clear_has_freeformtext();
  }
  freeformtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), freeformtext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 16;
inline bool SubmitNewSingleOrderInt::has_openorclose() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_openorclose() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SubmitNewSingleOrderInt::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SubmitNewSingleOrderInt::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewSingleOrderInt::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewSingleOrderInt::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.OpenOrClose)
}

// -------------------------------------------------------------------

// CancelReplaceOrder

// optional string ServerOrderID = 1;
inline bool CancelReplaceOrder::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelReplaceOrder::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelReplaceOrder::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelReplaceOrder::clear_serverorderid() {
  serverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverorderid();
}
inline const ::std::string& CancelReplaceOrder::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.ServerOrderID)
  return serverorderid_.GetNoArena();
}
inline void CancelReplaceOrder::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.ServerOrderID)
}
#if LANG_CXX11
inline void CancelReplaceOrder::set_serverorderid(::std::string&& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CancelReplaceOrder.ServerOrderID)
}
#endif
inline void CancelReplaceOrder::set_serverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrder.ServerOrderID)
}
inline void CancelReplaceOrder::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrder.ServerOrderID)
}
inline ::std::string* CancelReplaceOrder::mutable_serverorderid() {
  set_has_serverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrder.ServerOrderID)
  return serverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelReplaceOrder::release_serverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.CancelReplaceOrder.ServerOrderID)
  if (!has_serverorderid()) {
    return NULL;
  }
  clear_has_serverorderid();
  return serverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelReplaceOrder::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid != NULL) {
    set_has_serverorderid();
  } else {
    clear_has_serverorderid();
  }
  serverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrder.ServerOrderID)
}

// optional string ClientOrderID = 2;
inline bool CancelReplaceOrder::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelReplaceOrder::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelReplaceOrder::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelReplaceOrder::clear_clientorderid() {
  clientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid();
}
inline const ::std::string& CancelReplaceOrder::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.ClientOrderID)
  return clientorderid_.GetNoArena();
}
inline void CancelReplaceOrder::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.ClientOrderID)
}
#if LANG_CXX11
inline void CancelReplaceOrder::set_clientorderid(::std::string&& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CancelReplaceOrder.ClientOrderID)
}
#endif
inline void CancelReplaceOrder::set_clientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrder.ClientOrderID)
}
inline void CancelReplaceOrder::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrder.ClientOrderID)
}
inline ::std::string* CancelReplaceOrder::mutable_clientorderid() {
  set_has_clientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrder.ClientOrderID)
  return clientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelReplaceOrder::release_clientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.CancelReplaceOrder.ClientOrderID)
  if (!has_clientorderid()) {
    return NULL;
  }
  clear_has_clientorderid();
  return clientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelReplaceOrder::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid != NULL) {
    set_has_clientorderid();
  } else {
    clear_has_clientorderid();
  }
  clientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrder.ClientOrderID)
}

// optional double Price1 = 3;
inline bool CancelReplaceOrder::has_price1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelReplaceOrder::set_has_price1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelReplaceOrder::clear_has_price1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelReplaceOrder::clear_price1() {
  price1_ = 0;
  clear_has_price1();
}
inline double CancelReplaceOrder::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price1)
  return price1_;
}
inline void CancelReplaceOrder::set_price1(double value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price1)
}

// optional double Price2 = 4;
inline bool CancelReplaceOrder::has_price2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CancelReplaceOrder::set_has_price2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CancelReplaceOrder::clear_has_price2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CancelReplaceOrder::clear_price2() {
  price2_ = 0;
  clear_has_price2();
}
inline double CancelReplaceOrder::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price2)
  return price2_;
}
inline void CancelReplaceOrder::set_price2(double value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price2)
}

// optional double Quantity = 5;
inline bool CancelReplaceOrder::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CancelReplaceOrder::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CancelReplaceOrder::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CancelReplaceOrder::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double CancelReplaceOrder::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Quantity)
  return quantity_;
}
inline void CancelReplaceOrder::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Quantity)
}

// optional uint32 Price1IsSet = 6;
inline bool CancelReplaceOrder::has_price1isset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CancelReplaceOrder::set_has_price1isset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CancelReplaceOrder::clear_has_price1isset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CancelReplaceOrder::clear_price1isset() {
  price1isset_ = 0u;
  clear_has_price1isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrder::price1isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price1IsSet)
  return price1isset_;
}
inline void CancelReplaceOrder::set_price1isset(::google::protobuf::uint32 value) {
  set_has_price1isset();
  price1isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price1IsSet)
}

// optional uint32 Price2IsSet = 7;
inline bool CancelReplaceOrder::has_price2isset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CancelReplaceOrder::set_has_price2isset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CancelReplaceOrder::clear_has_price2isset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CancelReplaceOrder::clear_price2isset() {
  price2isset_ = 0u;
  clear_has_price2isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrder::price2isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price2IsSet)
  return price2isset_;
}
inline void CancelReplaceOrder::set_price2isset(::google::protobuf::uint32 value) {
  set_has_price2isset();
  price2isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price2IsSet)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 9;
inline bool CancelReplaceOrder::has_timeinforce() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CancelReplaceOrder::set_has_timeinforce() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CancelReplaceOrder::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CancelReplaceOrder::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum CancelReplaceOrder::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void CancelReplaceOrder::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.TimeInForce)
}

// optional uint64 GoodTillDateTime = 10;
inline bool CancelReplaceOrder::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CancelReplaceOrder::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CancelReplaceOrder::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CancelReplaceOrder::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_ULONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::uint64 CancelReplaceOrder::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void CancelReplaceOrder::set_goodtilldatetime(::google::protobuf::uint64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.GoodTillDateTime)
}

// optional uint32 UpdatePrice1OffsetToParent = 11;
inline bool CancelReplaceOrder::has_updateprice1offsettoparent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CancelReplaceOrder::set_has_updateprice1offsettoparent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CancelReplaceOrder::clear_has_updateprice1offsettoparent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CancelReplaceOrder::clear_updateprice1offsettoparent() {
  updateprice1offsettoparent_ = 0u;
  clear_has_updateprice1offsettoparent();
}
inline ::google::protobuf::uint32 CancelReplaceOrder::updateprice1offsettoparent() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.UpdatePrice1OffsetToParent)
  return updateprice1offsettoparent_;
}
inline void CancelReplaceOrder::set_updateprice1offsettoparent(::google::protobuf::uint32 value) {
  set_has_updateprice1offsettoparent();
  updateprice1offsettoparent_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.UpdatePrice1OffsetToParent)
}

// -------------------------------------------------------------------

// CancelReplaceOrderInt

// optional string ServerOrderID = 1;
inline bool CancelReplaceOrderInt::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelReplaceOrderInt::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelReplaceOrderInt::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelReplaceOrderInt::clear_serverorderid() {
  serverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverorderid();
}
inline const ::std::string& CancelReplaceOrderInt::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
  return serverorderid_.GetNoArena();
}
inline void CancelReplaceOrderInt::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}
#if LANG_CXX11
inline void CancelReplaceOrderInt::set_serverorderid(::std::string&& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}
#endif
inline void CancelReplaceOrderInt::set_serverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}
inline void CancelReplaceOrderInt::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}
inline ::std::string* CancelReplaceOrderInt::mutable_serverorderid() {
  set_has_serverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
  return serverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelReplaceOrderInt::release_serverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
  if (!has_serverorderid()) {
    return NULL;
  }
  clear_has_serverorderid();
  return serverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelReplaceOrderInt::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid != NULL) {
    set_has_serverorderid();
  } else {
    clear_has_serverorderid();
  }
  serverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}

// optional string ClientOrderID = 2;
inline bool CancelReplaceOrderInt::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelReplaceOrderInt::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelReplaceOrderInt::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelReplaceOrderInt::clear_clientorderid() {
  clientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid();
}
inline const ::std::string& CancelReplaceOrderInt::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
  return clientorderid_.GetNoArena();
}
inline void CancelReplaceOrderInt::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}
#if LANG_CXX11
inline void CancelReplaceOrderInt::set_clientorderid(::std::string&& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}
#endif
inline void CancelReplaceOrderInt::set_clientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}
inline void CancelReplaceOrderInt::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}
inline ::std::string* CancelReplaceOrderInt::mutable_clientorderid() {
  set_has_clientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
  return clientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelReplaceOrderInt::release_clientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
  if (!has_clientorderid()) {
    return NULL;
  }
  clear_has_clientorderid();
  return clientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelReplaceOrderInt::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid != NULL) {
    set_has_clientorderid();
  } else {
    clear_has_clientorderid();
  }
  clientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}

// optional int64 Price1 = 3;
inline bool CancelReplaceOrderInt::has_price1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelReplaceOrderInt::clear_has_price1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelReplaceOrderInt::clear_price1() {
  price1_ = GOOGLE_LONGLONG(0);
  clear_has_price1();
}
inline ::google::protobuf::int64 CancelReplaceOrderInt::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price1)
  return price1_;
}
inline void CancelReplaceOrderInt::set_price1(::google::protobuf::int64 value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price1)
}

// optional int64 Price2 = 4;
inline bool CancelReplaceOrderInt::has_price2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CancelReplaceOrderInt::clear_has_price2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CancelReplaceOrderInt::clear_price2() {
  price2_ = GOOGLE_LONGLONG(0);
  clear_has_price2();
}
inline ::google::protobuf::int64 CancelReplaceOrderInt::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price2)
  return price2_;
}
inline void CancelReplaceOrderInt::set_price2(::google::protobuf::int64 value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price2)
}

// optional float Divisor = 5;
inline bool CancelReplaceOrderInt::has_divisor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CancelReplaceOrderInt::set_has_divisor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CancelReplaceOrderInt::clear_has_divisor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CancelReplaceOrderInt::clear_divisor() {
  divisor_ = 0;
  clear_has_divisor();
}
inline float CancelReplaceOrderInt::divisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Divisor)
  return divisor_;
}
inline void CancelReplaceOrderInt::set_divisor(float value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Divisor)
}

// optional int64 Quantity = 6;
inline bool CancelReplaceOrderInt::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CancelReplaceOrderInt::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CancelReplaceOrderInt::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CancelReplaceOrderInt::clear_quantity() {
  quantity_ = GOOGLE_LONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::int64 CancelReplaceOrderInt::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Quantity)
  return quantity_;
}
inline void CancelReplaceOrderInt::set_quantity(::google::protobuf::int64 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Quantity)
}

// optional uint32 Price1IsSet = 7;
inline bool CancelReplaceOrderInt::has_price1isset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price1isset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CancelReplaceOrderInt::clear_has_price1isset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CancelReplaceOrderInt::clear_price1isset() {
  price1isset_ = 0u;
  clear_has_price1isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrderInt::price1isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price1IsSet)
  return price1isset_;
}
inline void CancelReplaceOrderInt::set_price1isset(::google::protobuf::uint32 value) {
  set_has_price1isset();
  price1isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price1IsSet)
}

// optional uint32 Price2IsSet = 8;
inline bool CancelReplaceOrderInt::has_price2isset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price2isset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CancelReplaceOrderInt::clear_has_price2isset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CancelReplaceOrderInt::clear_price2isset() {
  price2isset_ = 0u;
  clear_has_price2isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrderInt::price2isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price2IsSet)
  return price2isset_;
}
inline void CancelReplaceOrderInt::set_price2isset(::google::protobuf::uint32 value) {
  set_has_price2isset();
  price2isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price2IsSet)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 10;
inline bool CancelReplaceOrderInt::has_timeinforce() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CancelReplaceOrderInt::set_has_timeinforce() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CancelReplaceOrderInt::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CancelReplaceOrderInt::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum CancelReplaceOrderInt::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void CancelReplaceOrderInt::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.TimeInForce)
}

// optional uint64 GoodTillDateTime = 11;
inline bool CancelReplaceOrderInt::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CancelReplaceOrderInt::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CancelReplaceOrderInt::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CancelReplaceOrderInt::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_ULONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::uint64 CancelReplaceOrderInt::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void CancelReplaceOrderInt::set_goodtilldatetime(::google::protobuf::uint64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.GoodTillDateTime)
}

// optional uint32 UpdatePrice1OffsetToParent = 12;
inline bool CancelReplaceOrderInt::has_updateprice1offsettoparent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CancelReplaceOrderInt::set_has_updateprice1offsettoparent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CancelReplaceOrderInt::clear_has_updateprice1offsettoparent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CancelReplaceOrderInt::clear_updateprice1offsettoparent() {
  updateprice1offsettoparent_ = 0u;
  clear_has_updateprice1offsettoparent();
}
inline ::google::protobuf::uint32 CancelReplaceOrderInt::updateprice1offsettoparent() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.UpdatePrice1OffsetToParent)
  return updateprice1offsettoparent_;
}
inline void CancelReplaceOrderInt::set_updateprice1offsettoparent(::google::protobuf::uint32 value) {
  set_has_updateprice1offsettoparent();
  updateprice1offsettoparent_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.UpdatePrice1OffsetToParent)
}

// -------------------------------------------------------------------

// CancelOrder

// optional string ServerOrderID = 1;
inline bool CancelOrder::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelOrder::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelOrder::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelOrder::clear_serverorderid() {
  serverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverorderid();
}
inline const ::std::string& CancelOrder::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelOrder.ServerOrderID)
  return serverorderid_.GetNoArena();
}
inline void CancelOrder::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelOrder.ServerOrderID)
}
#if LANG_CXX11
inline void CancelOrder::set_serverorderid(::std::string&& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CancelOrder.ServerOrderID)
}
#endif
inline void CancelOrder::set_serverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelOrder.ServerOrderID)
}
inline void CancelOrder::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelOrder.ServerOrderID)
}
inline ::std::string* CancelOrder::mutable_serverorderid() {
  set_has_serverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelOrder.ServerOrderID)
  return serverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelOrder::release_serverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.CancelOrder.ServerOrderID)
  if (!has_serverorderid()) {
    return NULL;
  }
  clear_has_serverorderid();
  return serverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelOrder::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid != NULL) {
    set_has_serverorderid();
  } else {
    clear_has_serverorderid();
  }
  serverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelOrder.ServerOrderID)
}

// optional string ClientOrderID = 2;
inline bool CancelOrder::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelOrder::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelOrder::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelOrder::clear_clientorderid() {
  clientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid();
}
inline const ::std::string& CancelOrder::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelOrder.ClientOrderID)
  return clientorderid_.GetNoArena();
}
inline void CancelOrder::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelOrder.ClientOrderID)
}
#if LANG_CXX11
inline void CancelOrder::set_clientorderid(::std::string&& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CancelOrder.ClientOrderID)
}
#endif
inline void CancelOrder::set_clientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelOrder.ClientOrderID)
}
inline void CancelOrder::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelOrder.ClientOrderID)
}
inline ::std::string* CancelOrder::mutable_clientorderid() {
  set_has_clientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelOrder.ClientOrderID)
  return clientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelOrder::release_clientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.CancelOrder.ClientOrderID)
  if (!has_clientorderid()) {
    return NULL;
  }
  clear_has_clientorderid();
  return clientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelOrder::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid != NULL) {
    set_has_clientorderid();
  } else {
    clear_has_clientorderid();
  }
  clientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelOrder.ClientOrderID)
}

// -------------------------------------------------------------------

// SubmitNewOCOOrder

// optional string Symbol = 1;
inline bool SubmitNewOCOOrder::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewOCOOrder::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewOCOOrder::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewOCOOrder::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SubmitNewOCOOrder::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Symbol)
  return symbol_.GetNoArena();
}
inline void SubmitNewOCOOrder::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Symbol)
}
#if LANG_CXX11
inline void SubmitNewOCOOrder::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrder.Symbol)
}
#endif
inline void SubmitNewOCOOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.Symbol)
}
inline void SubmitNewOCOOrder::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.Symbol)
}
inline ::std::string* SubmitNewOCOOrder::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrder.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewOCOOrder::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewOCOOrder::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewOCOOrder::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewOCOOrder::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SubmitNewOCOOrder::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Exchange)
  return exchange_.GetNoArena();
}
inline void SubmitNewOCOOrder::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Exchange)
}
#if LANG_CXX11
inline void SubmitNewOCOOrder::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrder.Exchange)
}
#endif
inline void SubmitNewOCOOrder::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.Exchange)
}
inline void SubmitNewOCOOrder::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.Exchange)
}
inline ::std::string* SubmitNewOCOOrder::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrder::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrder.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrder::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.Exchange)
}

// optional string ClientOrderID_1 = 3;
inline bool SubmitNewOCOOrder::has_clientorderid_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewOCOOrder::set_has_clientorderid_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewOCOOrder::clear_has_clientorderid_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewOCOOrder::clear_clientorderid_1() {
  clientorderid_1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid_1();
}
inline const ::std::string& SubmitNewOCOOrder::clientorderid_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
  return clientorderid_1_.GetNoArena();
}
inline void SubmitNewOCOOrder::set_clientorderid_1(const ::std::string& value) {
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}
#if LANG_CXX11
inline void SubmitNewOCOOrder::set_clientorderid_1(::std::string&& value) {
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}
#endif
inline void SubmitNewOCOOrder::set_clientorderid_1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}
inline void SubmitNewOCOOrder::set_clientorderid_1(const char* value, size_t size) {
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}
inline ::std::string* SubmitNewOCOOrder::mutable_clientorderid_1() {
  set_has_clientorderid_1();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
  return clientorderid_1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrder::release_clientorderid_1() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
  if (!has_clientorderid_1()) {
    return NULL;
  }
  clear_has_clientorderid_1();
  return clientorderid_1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrder::set_allocated_clientorderid_1(::std::string* clientorderid_1) {
  if (clientorderid_1 != NULL) {
    set_has_clientorderid_1();
  } else {
    clear_has_clientorderid_1();
  }
  clientorderid_1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid_1);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}

// optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
inline bool SubmitNewOCOOrder::has_ordertype_1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewOCOOrder::set_has_ordertype_1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewOCOOrder::clear_has_ordertype_1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewOCOOrder::clear_ordertype_1() {
  ordertype_1_ = 0;
  clear_has_ordertype_1();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrder::ordertype_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OrderType_1)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_1_);
}
inline void SubmitNewOCOOrder::set_ordertype_1(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_1();
  ordertype_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OrderType_1)
}

// optional .DTC_PB.BuySellEnum BuySell_1 = 5;
inline bool SubmitNewOCOOrder::has_buysell_1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewOCOOrder::set_has_buysell_1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewOCOOrder::clear_has_buysell_1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewOCOOrder::clear_buysell_1() {
  buysell_1_ = 0;
  clear_has_buysell_1();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrder::buysell_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.BuySell_1)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_1_);
}
inline void SubmitNewOCOOrder::set_buysell_1(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_1();
  buysell_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.BuySell_1)
}

// optional double Price1_1 = 6;
inline bool SubmitNewOCOOrder::has_price1_1() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price1_1() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewOCOOrder::clear_has_price1_1() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewOCOOrder::clear_price1_1() {
  price1_1_ = 0;
  clear_has_price1_1();
}
inline double SubmitNewOCOOrder::price1_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price1_1)
  return price1_1_;
}
inline void SubmitNewOCOOrder::set_price1_1(double value) {
  set_has_price1_1();
  price1_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price1_1)
}

// optional double Price2_1 = 7;
inline bool SubmitNewOCOOrder::has_price2_1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price2_1() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewOCOOrder::clear_has_price2_1() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewOCOOrder::clear_price2_1() {
  price2_1_ = 0;
  clear_has_price2_1();
}
inline double SubmitNewOCOOrder::price2_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price2_1)
  return price2_1_;
}
inline void SubmitNewOCOOrder::set_price2_1(double value) {
  set_has_price2_1();
  price2_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price2_1)
}

// optional double Quantity_1 = 8;
inline bool SubmitNewOCOOrder::has_quantity_1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewOCOOrder::set_has_quantity_1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewOCOOrder::clear_has_quantity_1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewOCOOrder::clear_quantity_1() {
  quantity_1_ = 0;
  clear_has_quantity_1();
}
inline double SubmitNewOCOOrder::quantity_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Quantity_1)
  return quantity_1_;
}
inline void SubmitNewOCOOrder::set_quantity_1(double value) {
  set_has_quantity_1();
  quantity_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Quantity_1)
}

// optional string ClientOrderID_2 = 9;
inline bool SubmitNewOCOOrder::has_clientorderid_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewOCOOrder::set_has_clientorderid_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewOCOOrder::clear_has_clientorderid_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewOCOOrder::clear_clientorderid_2() {
  clientorderid_2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid_2();
}
inline const ::std::string& SubmitNewOCOOrder::clientorderid_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
  return clientorderid_2_.GetNoArena();
}
inline void SubmitNewOCOOrder::set_clientorderid_2(const ::std::string& value) {
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}
#if LANG_CXX11
inline void SubmitNewOCOOrder::set_clientorderid_2(::std::string&& value) {
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}
#endif
inline void SubmitNewOCOOrder::set_clientorderid_2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}
inline void SubmitNewOCOOrder::set_clientorderid_2(const char* value, size_t size) {
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}
inline ::std::string* SubmitNewOCOOrder::mutable_clientorderid_2() {
  set_has_clientorderid_2();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
  return clientorderid_2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrder::release_clientorderid_2() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
  if (!has_clientorderid_2()) {
    return NULL;
  }
  clear_has_clientorderid_2();
  return clientorderid_2_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrder::set_allocated_clientorderid_2(::std::string* clientorderid_2) {
  if (clientorderid_2 != NULL) {
    set_has_clientorderid_2();
  } else {
    clear_has_clientorderid_2();
  }
  clientorderid_2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid_2);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}

// optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
inline bool SubmitNewOCOOrder::has_ordertype_2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_ordertype_2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewOCOOrder::clear_has_ordertype_2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewOCOOrder::clear_ordertype_2() {
  ordertype_2_ = 0;
  clear_has_ordertype_2();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrder::ordertype_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OrderType_2)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_2_);
}
inline void SubmitNewOCOOrder::set_ordertype_2(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_2();
  ordertype_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OrderType_2)
}

// optional .DTC_PB.BuySellEnum BuySell_2 = 11;
inline bool SubmitNewOCOOrder::has_buysell_2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_buysell_2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewOCOOrder::clear_has_buysell_2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewOCOOrder::clear_buysell_2() {
  buysell_2_ = 0;
  clear_has_buysell_2();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrder::buysell_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.BuySell_2)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_2_);
}
inline void SubmitNewOCOOrder::set_buysell_2(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_2();
  buysell_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.BuySell_2)
}

// optional double Price1_2 = 12;
inline bool SubmitNewOCOOrder::has_price1_2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price1_2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewOCOOrder::clear_has_price1_2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewOCOOrder::clear_price1_2() {
  price1_2_ = 0;
  clear_has_price1_2();
}
inline double SubmitNewOCOOrder::price1_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price1_2)
  return price1_2_;
}
inline void SubmitNewOCOOrder::set_price1_2(double value) {
  set_has_price1_2();
  price1_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price1_2)
}

// optional double Price2_2 = 13;
inline bool SubmitNewOCOOrder::has_price2_2() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price2_2() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SubmitNewOCOOrder::clear_has_price2_2() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SubmitNewOCOOrder::clear_price2_2() {
  price2_2_ = 0;
  clear_has_price2_2();
}
inline double SubmitNewOCOOrder::price2_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price2_2)
  return price2_2_;
}
inline void SubmitNewOCOOrder::set_price2_2(double value) {
  set_has_price2_2();
  price2_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price2_2)
}

// optional double Quantity_2 = 14;
inline bool SubmitNewOCOOrder::has_quantity_2() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_quantity_2() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SubmitNewOCOOrder::clear_has_quantity_2() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SubmitNewOCOOrder::clear_quantity_2() {
  quantity_2_ = 0;
  clear_has_quantity_2();
}
inline double SubmitNewOCOOrder::quantity_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Quantity_2)
  return quantity_2_;
}
inline void SubmitNewOCOOrder::set_quantity_2(double value) {
  set_has_quantity_2();
  quantity_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Quantity_2)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
inline bool SubmitNewOCOOrder::has_timeinforce() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_timeinforce() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SubmitNewOCOOrder::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SubmitNewOCOOrder::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewOCOOrder::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewOCOOrder::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 16;
inline bool SubmitNewOCOOrder::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SubmitNewOCOOrder::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SubmitNewOCOOrder::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewOCOOrder::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewOCOOrder::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.GoodTillDateTime)
}

// optional string TradeAccount = 17;
inline bool SubmitNewOCOOrder::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewOCOOrder::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewOCOOrder::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewOCOOrder::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewOCOOrder::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void SubmitNewOCOOrder::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}
#if LANG_CXX11
inline void SubmitNewOCOOrder::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}
#endif
inline void SubmitNewOCOOrder::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}
inline void SubmitNewOCOOrder::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}
inline ::std::string* SubmitNewOCOOrder::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrder::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrder.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrder::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}

// optional uint32 IsAutomatedOrder = 18;
inline bool SubmitNewOCOOrder::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SubmitNewOCOOrder::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SubmitNewOCOOrder::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewOCOOrder::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewOCOOrder::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.IsAutomatedOrder)
}

// optional string ParentTriggerClientOrderID = 19;
inline bool SubmitNewOCOOrder::has_parenttriggerclientorderid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewOCOOrder::set_has_parenttriggerclientorderid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewOCOOrder::clear_has_parenttriggerclientorderid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewOCOOrder::clear_parenttriggerclientorderid() {
  parenttriggerclientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parenttriggerclientorderid();
}
inline const ::std::string& SubmitNewOCOOrder::parenttriggerclientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
  return parenttriggerclientorderid_.GetNoArena();
}
inline void SubmitNewOCOOrder::set_parenttriggerclientorderid(const ::std::string& value) {
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}
#if LANG_CXX11
inline void SubmitNewOCOOrder::set_parenttriggerclientorderid(::std::string&& value) {
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}
#endif
inline void SubmitNewOCOOrder::set_parenttriggerclientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}
inline void SubmitNewOCOOrder::set_parenttriggerclientorderid(const char* value, size_t size) {
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}
inline ::std::string* SubmitNewOCOOrder::mutable_parenttriggerclientorderid() {
  set_has_parenttriggerclientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
  return parenttriggerclientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrder::release_parenttriggerclientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
  if (!has_parenttriggerclientorderid()) {
    return NULL;
  }
  clear_has_parenttriggerclientorderid();
  return parenttriggerclientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrder::set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid) {
  if (parenttriggerclientorderid != NULL) {
    set_has_parenttriggerclientorderid();
  } else {
    clear_has_parenttriggerclientorderid();
  }
  parenttriggerclientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parenttriggerclientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}

// optional string FreeFormText = 20;
inline bool SubmitNewOCOOrder::has_freeformtext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewOCOOrder::set_has_freeformtext() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewOCOOrder::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewOCOOrder::clear_freeformtext() {
  freeformtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewOCOOrder::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.FreeFormText)
  return freeformtext_.GetNoArena();
}
inline void SubmitNewOCOOrder::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}
#if LANG_CXX11
inline void SubmitNewOCOOrder::set_freeformtext(::std::string&& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}
#endif
inline void SubmitNewOCOOrder::set_freeformtext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}
inline void SubmitNewOCOOrder::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}
inline ::std::string* SubmitNewOCOOrder::mutable_freeformtext() {
  set_has_freeformtext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.FreeFormText)
  return freeformtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrder::release_freeformtext() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrder.FreeFormText)
  if (!has_freeformtext()) {
    return NULL;
  }
  clear_has_freeformtext();
  return freeformtext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrder::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext != NULL) {
    set_has_freeformtext();
  } else {
    clear_has_freeformtext();
  }
  freeformtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), freeformtext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 21;
inline bool SubmitNewOCOOrder::has_openorclose() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_openorclose() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SubmitNewOCOOrder::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SubmitNewOCOOrder::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewOCOOrder::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewOCOOrder::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OpenOrClose)
}

// optional .DTC_PB.PartialFillHandlingEnum PartialFillHandling = 22;
inline bool SubmitNewOCOOrder::has_partialfillhandling() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_partialfillhandling() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SubmitNewOCOOrder::clear_has_partialfillhandling() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SubmitNewOCOOrder::clear_partialfillhandling() {
  partialfillhandling_ = 0;
  clear_has_partialfillhandling();
}
inline ::DTC_PB::PartialFillHandlingEnum SubmitNewOCOOrder::partialfillhandling() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.PartialFillHandling)
  return static_cast< ::DTC_PB::PartialFillHandlingEnum >(partialfillhandling_);
}
inline void SubmitNewOCOOrder::set_partialfillhandling(::DTC_PB::PartialFillHandlingEnum value) {
  assert(::DTC_PB::PartialFillHandlingEnum_IsValid(value));
  set_has_partialfillhandling();
  partialfillhandling_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.PartialFillHandling)
}

// optional uint32 UseOffsets = 23;
inline bool SubmitNewOCOOrder::has_useoffsets() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_useoffsets() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SubmitNewOCOOrder::clear_has_useoffsets() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SubmitNewOCOOrder::clear_useoffsets() {
  useoffsets_ = 0u;
  clear_has_useoffsets();
}
inline ::google::protobuf::uint32 SubmitNewOCOOrder::useoffsets() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.UseOffsets)
  return useoffsets_;
}
inline void SubmitNewOCOOrder::set_useoffsets(::google::protobuf::uint32 value) {
  set_has_useoffsets();
  useoffsets_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.UseOffsets)
}

// optional double OffsetFromParent1 = 24;
inline bool SubmitNewOCOOrder::has_offsetfromparent1() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_offsetfromparent1() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SubmitNewOCOOrder::clear_has_offsetfromparent1() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SubmitNewOCOOrder::clear_offsetfromparent1() {
  offsetfromparent1_ = 0;
  clear_has_offsetfromparent1();
}
inline double SubmitNewOCOOrder::offsetfromparent1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OffsetFromParent1)
  return offsetfromparent1_;
}
inline void SubmitNewOCOOrder::set_offsetfromparent1(double value) {
  set_has_offsetfromparent1();
  offsetfromparent1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OffsetFromParent1)
}

// optional double OffsetFromParent2 = 25;
inline bool SubmitNewOCOOrder::has_offsetfromparent2() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_offsetfromparent2() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SubmitNewOCOOrder::clear_has_offsetfromparent2() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SubmitNewOCOOrder::clear_offsetfromparent2() {
  offsetfromparent2_ = 0;
  clear_has_offsetfromparent2();
}
inline double SubmitNewOCOOrder::offsetfromparent2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OffsetFromParent2)
  return offsetfromparent2_;
}
inline void SubmitNewOCOOrder::set_offsetfromparent2(double value) {
  set_has_offsetfromparent2();
  offsetfromparent2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OffsetFromParent2)
}

// -------------------------------------------------------------------

// SubmitNewOCOOrderInt

// optional string Symbol = 1;
inline bool SubmitNewOCOOrderInt::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewOCOOrderInt::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewOCOOrderInt::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SubmitNewOCOOrderInt::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Symbol)
  return symbol_.GetNoArena();
}
inline void SubmitNewOCOOrderInt::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}
#if LANG_CXX11
inline void SubmitNewOCOOrderInt::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}
#endif
inline void SubmitNewOCOOrderInt::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}
inline void SubmitNewOCOOrderInt::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrderInt::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrderInt.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrderInt::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewOCOOrderInt::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewOCOOrderInt::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewOCOOrderInt::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SubmitNewOCOOrderInt::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Exchange)
  return exchange_.GetNoArena();
}
inline void SubmitNewOCOOrderInt::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}
#if LANG_CXX11
inline void SubmitNewOCOOrderInt::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}
#endif
inline void SubmitNewOCOOrderInt::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}
inline void SubmitNewOCOOrderInt::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrderInt::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrderInt.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrderInt::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}

// optional string ClientOrderID_1 = 3;
inline bool SubmitNewOCOOrderInt::has_clientorderid_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_clientorderid_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewOCOOrderInt::clear_has_clientorderid_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewOCOOrderInt::clear_clientorderid_1() {
  clientorderid_1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid_1();
}
inline const ::std::string& SubmitNewOCOOrderInt::clientorderid_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
  return clientorderid_1_.GetNoArena();
}
inline void SubmitNewOCOOrderInt::set_clientorderid_1(const ::std::string& value) {
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}
#if LANG_CXX11
inline void SubmitNewOCOOrderInt::set_clientorderid_1(::std::string&& value) {
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}
#endif
inline void SubmitNewOCOOrderInt::set_clientorderid_1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}
inline void SubmitNewOCOOrderInt::set_clientorderid_1(const char* value, size_t size) {
  set_has_clientorderid_1();
  clientorderid_1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_clientorderid_1() {
  set_has_clientorderid_1();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
  return clientorderid_1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrderInt::release_clientorderid_1() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
  if (!has_clientorderid_1()) {
    return NULL;
  }
  clear_has_clientorderid_1();
  return clientorderid_1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrderInt::set_allocated_clientorderid_1(::std::string* clientorderid_1) {
  if (clientorderid_1 != NULL) {
    set_has_clientorderid_1();
  } else {
    clear_has_clientorderid_1();
  }
  clientorderid_1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid_1);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}

// optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
inline bool SubmitNewOCOOrderInt::has_ordertype_1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_ordertype_1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewOCOOrderInt::clear_has_ordertype_1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewOCOOrderInt::clear_ordertype_1() {
  ordertype_1_ = 0;
  clear_has_ordertype_1();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrderInt::ordertype_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.OrderType_1)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_1_);
}
inline void SubmitNewOCOOrderInt::set_ordertype_1(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_1();
  ordertype_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.OrderType_1)
}

// optional .DTC_PB.BuySellEnum BuySell_1 = 5;
inline bool SubmitNewOCOOrderInt::has_buysell_1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_buysell_1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewOCOOrderInt::clear_has_buysell_1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewOCOOrderInt::clear_buysell_1() {
  buysell_1_ = 0;
  clear_has_buysell_1();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrderInt::buysell_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.BuySell_1)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_1_);
}
inline void SubmitNewOCOOrderInt::set_buysell_1(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_1();
  buysell_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.BuySell_1)
}

// optional int64 Price1_1 = 6;
inline bool SubmitNewOCOOrderInt::has_price1_1() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price1_1() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewOCOOrderInt::clear_has_price1_1() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewOCOOrderInt::clear_price1_1() {
  price1_1_ = GOOGLE_LONGLONG(0);
  clear_has_price1_1();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price1_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price1_1)
  return price1_1_;
}
inline void SubmitNewOCOOrderInt::set_price1_1(::google::protobuf::int64 value) {
  set_has_price1_1();
  price1_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price1_1)
}

// optional int64 Price2_1 = 7;
inline bool SubmitNewOCOOrderInt::has_price2_1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price2_1() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewOCOOrderInt::clear_has_price2_1() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewOCOOrderInt::clear_price2_1() {
  price2_1_ = GOOGLE_LONGLONG(0);
  clear_has_price2_1();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price2_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price2_1)
  return price2_1_;
}
inline void SubmitNewOCOOrderInt::set_price2_1(::google::protobuf::int64 value) {
  set_has_price2_1();
  price2_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price2_1)
}

// optional int64 Quantity_1 = 8;
inline bool SubmitNewOCOOrderInt::has_quantity_1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_quantity_1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewOCOOrderInt::clear_has_quantity_1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewOCOOrderInt::clear_quantity_1() {
  quantity_1_ = GOOGLE_LONGLONG(0);
  clear_has_quantity_1();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::quantity_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Quantity_1)
  return quantity_1_;
}
inline void SubmitNewOCOOrderInt::set_quantity_1(::google::protobuf::int64 value) {
  set_has_quantity_1();
  quantity_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Quantity_1)
}

// optional string ClientOrderID_2 = 9;
inline bool SubmitNewOCOOrderInt::has_clientorderid_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_clientorderid_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewOCOOrderInt::clear_has_clientorderid_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewOCOOrderInt::clear_clientorderid_2() {
  clientorderid_2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid_2();
}
inline const ::std::string& SubmitNewOCOOrderInt::clientorderid_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
  return clientorderid_2_.GetNoArena();
}
inline void SubmitNewOCOOrderInt::set_clientorderid_2(const ::std::string& value) {
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}
#if LANG_CXX11
inline void SubmitNewOCOOrderInt::set_clientorderid_2(::std::string&& value) {
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}
#endif
inline void SubmitNewOCOOrderInt::set_clientorderid_2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}
inline void SubmitNewOCOOrderInt::set_clientorderid_2(const char* value, size_t size) {
  set_has_clientorderid_2();
  clientorderid_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_clientorderid_2() {
  set_has_clientorderid_2();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
  return clientorderid_2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrderInt::release_clientorderid_2() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
  if (!has_clientorderid_2()) {
    return NULL;
  }
  clear_has_clientorderid_2();
  return clientorderid_2_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrderInt::set_allocated_clientorderid_2(::std::string* clientorderid_2) {
  if (clientorderid_2 != NULL) {
    set_has_clientorderid_2();
  } else {
    clear_has_clientorderid_2();
  }
  clientorderid_2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid_2);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}

// optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
inline bool SubmitNewOCOOrderInt::has_ordertype_2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_ordertype_2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewOCOOrderInt::clear_has_ordertype_2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewOCOOrderInt::clear_ordertype_2() {
  ordertype_2_ = 0;
  clear_has_ordertype_2();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrderInt::ordertype_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.OrderType_2)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_2_);
}
inline void SubmitNewOCOOrderInt::set_ordertype_2(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_2();
  ordertype_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.OrderType_2)
}

// optional .DTC_PB.BuySellEnum BuySell_2 = 11;
inline bool SubmitNewOCOOrderInt::has_buysell_2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_buysell_2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewOCOOrderInt::clear_has_buysell_2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewOCOOrderInt::clear_buysell_2() {
  buysell_2_ = 0;
  clear_has_buysell_2();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrderInt::buysell_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.BuySell_2)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_2_);
}
inline void SubmitNewOCOOrderInt::set_buysell_2(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_2();
  buysell_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.BuySell_2)
}

// optional int64 Price1_2 = 12;
inline bool SubmitNewOCOOrderInt::has_price1_2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price1_2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewOCOOrderInt::clear_has_price1_2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewOCOOrderInt::clear_price1_2() {
  price1_2_ = GOOGLE_LONGLONG(0);
  clear_has_price1_2();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price1_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price1_2)
  return price1_2_;
}
inline void SubmitNewOCOOrderInt::set_price1_2(::google::protobuf::int64 value) {
  set_has_price1_2();
  price1_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price1_2)
}

// optional int64 Price2_2 = 13;
inline bool SubmitNewOCOOrderInt::has_price2_2() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price2_2() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SubmitNewOCOOrderInt::clear_has_price2_2() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SubmitNewOCOOrderInt::clear_price2_2() {
  price2_2_ = GOOGLE_LONGLONG(0);
  clear_has_price2_2();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price2_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price2_2)
  return price2_2_;
}
inline void SubmitNewOCOOrderInt::set_price2_2(::google::protobuf::int64 value) {
  set_has_price2_2();
  price2_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price2_2)
}

// optional int64 Quantity_2 = 14;
inline bool SubmitNewOCOOrderInt::has_quantity_2() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_quantity_2() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SubmitNewOCOOrderInt::clear_has_quantity_2() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SubmitNewOCOOrderInt::clear_quantity_2() {
  quantity_2_ = GOOGLE_LONGLONG(0);
  clear_has_quantity_2();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::quantity_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Quantity_2)
  return quantity_2_;
}
inline void SubmitNewOCOOrderInt::set_quantity_2(::google::protobuf::int64 value) {
  set_has_quantity_2();
  quantity_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Quantity_2)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
inline bool SubmitNewOCOOrderInt::has_timeinforce() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_timeinforce() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SubmitNewOCOOrderInt::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SubmitNewOCOOrderInt::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewOCOOrderInt::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewOCOOrderInt::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 16;
inline bool SubmitNewOCOOrderInt::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SubmitNewOCOOrderInt::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SubmitNewOCOOrderInt::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewOCOOrderInt::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.GoodTillDateTime)
}

// optional string TradeAccount = 17;
inline bool SubmitNewOCOOrderInt::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewOCOOrderInt::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewOCOOrderInt::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewOCOOrderInt::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void SubmitNewOCOOrderInt::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}
#if LANG_CXX11
inline void SubmitNewOCOOrderInt::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}
#endif
inline void SubmitNewOCOOrderInt::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}
inline void SubmitNewOCOOrderInt::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrderInt::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrderInt::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}

// optional uint32 IsAutomatedOrder = 18;
inline bool SubmitNewOCOOrderInt::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SubmitNewOCOOrderInt::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SubmitNewOCOOrderInt::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewOCOOrderInt::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewOCOOrderInt::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.IsAutomatedOrder)
}

// optional string ParentTriggerClientOrderID = 19;
inline bool SubmitNewOCOOrderInt::has_parenttriggerclientorderid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_parenttriggerclientorderid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewOCOOrderInt::clear_has_parenttriggerclientorderid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewOCOOrderInt::clear_parenttriggerclientorderid() {
  parenttriggerclientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parenttriggerclientorderid();
}
inline const ::std::string& SubmitNewOCOOrderInt::parenttriggerclientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
  return parenttriggerclientorderid_.GetNoArena();
}
inline void SubmitNewOCOOrderInt::set_parenttriggerclientorderid(const ::std::string& value) {
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}
#if LANG_CXX11
inline void SubmitNewOCOOrderInt::set_parenttriggerclientorderid(::std::string&& value) {
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}
#endif
inline void SubmitNewOCOOrderInt::set_parenttriggerclientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}
inline void SubmitNewOCOOrderInt::set_parenttriggerclientorderid(const char* value, size_t size) {
  set_has_parenttriggerclientorderid();
  parenttriggerclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_parenttriggerclientorderid() {
  set_has_parenttriggerclientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
  return parenttriggerclientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrderInt::release_parenttriggerclientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
  if (!has_parenttriggerclientorderid()) {
    return NULL;
  }
  clear_has_parenttriggerclientorderid();
  return parenttriggerclientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrderInt::set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid) {
  if (parenttriggerclientorderid != NULL) {
    set_has_parenttriggerclientorderid();
  } else {
    clear_has_parenttriggerclientorderid();
  }
  parenttriggerclientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parenttriggerclientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}

// optional string FreeFormText = 20;
inline bool SubmitNewOCOOrderInt::has_freeformtext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_freeformtext() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewOCOOrderInt::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewOCOOrderInt::clear_freeformtext() {
  freeformtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewOCOOrderInt::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
  return freeformtext_.GetNoArena();
}
inline void SubmitNewOCOOrderInt::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}
#if LANG_CXX11
inline void SubmitNewOCOOrderInt::set_freeformtext(::std::string&& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}
#endif
inline void SubmitNewOCOOrderInt::set_freeformtext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}
inline void SubmitNewOCOOrderInt::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_freeformtext() {
  set_has_freeformtext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
  return freeformtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubmitNewOCOOrderInt::release_freeformtext() {
  // @@protoc_insertion_point(field_release:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
  if (!has_freeformtext()) {
    return NULL;
  }
  clear_has_freeformtext();
  return freeformtext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubmitNewOCOOrderInt::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext != NULL) {
    set_has_freeformtext();
  } else {
    clear_has_freeformtext();
  }
  freeformtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), freeformtext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}

// optional float Divisor = 21;
inline bool SubmitNewOCOOrderInt::has_divisor() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_divisor() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SubmitNewOCOOrderInt::clear_has_divisor() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SubmitNewOCOOrderInt::clear_divisor() {
  divisor_ = 0;
  clear_has_divisor();
}
inline float SubmitNewOCOOrderInt::divisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Divisor)
  return divisor_;
}
inline void SubmitNewOCOOrderInt::set_divisor(float value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Divisor)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 22;
inline bool SubmitNewOCOOrderInt::has_openorclose() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_openorclose() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SubmitNewOCOOrderInt::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SubmitNewOCOOrderInt::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewOCOOrderInt::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewOCOOrderInt::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.OpenOrClose)
}

// optional .DTC_PB.PartialFillHandlingEnum PartialFillHandling = 23;
inline bool SubmitNewOCOOrderInt::has_partialfillhandling() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_partialfillhandling() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SubmitNewOCOOrderInt::clear_has_partialfillhandling() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SubmitNewOCOOrderInt::clear_partialfillhandling() {
  partialfillhandling_ = 0;
  clear_has_partialfillhandling();
}
inline ::DTC_PB::PartialFillHandlingEnum SubmitNewOCOOrderInt::partialfillhandling() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.PartialFillHandling)
  return static_cast< ::DTC_PB::PartialFillHandlingEnum >(partialfillhandling_);
}
inline void SubmitNewOCOOrderInt::set_partialfillhandling(::DTC_PB::PartialFillHandlingEnum value) {
  assert(::DTC_PB::PartialFillHandlingEnum_IsValid(value));
  set_has_partialfillhandling();
  partialfillhandling_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.PartialFillHandling)
}

// -------------------------------------------------------------------

// OpenOrdersRequest

// optional int32 RequestID = 1;
inline bool OpenOrdersRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenOrdersRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenOrdersRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenOrdersRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 OpenOrdersRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersRequest.RequestID)
  return requestid_;
}
inline void OpenOrdersRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersRequest.RequestID)
}

// optional int32 RequestAllOrders = 2;
inline bool OpenOrdersRequest::has_requestallorders() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenOrdersRequest::set_has_requestallorders() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenOrdersRequest::clear_has_requestallorders() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenOrdersRequest::clear_requestallorders() {
  requestallorders_ = 0;
  clear_has_requestallorders();
}
inline ::google::protobuf::int32 OpenOrdersRequest::requestallorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersRequest.RequestAllOrders)
  return requestallorders_;
}
inline void OpenOrdersRequest::set_requestallorders(::google::protobuf::int32 value) {
  set_has_requestallorders();
  requestallorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersRequest.RequestAllOrders)
}

// optional string ServerOrderID = 3;
inline bool OpenOrdersRequest::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenOrdersRequest::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenOrdersRequest::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenOrdersRequest::clear_serverorderid() {
  serverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverorderid();
}
inline const ::std::string& OpenOrdersRequest::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersRequest.ServerOrderID)
  return serverorderid_.GetNoArena();
}
inline void OpenOrdersRequest::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersRequest.ServerOrderID)
}
#if LANG_CXX11
inline void OpenOrdersRequest::set_serverorderid(::std::string&& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OpenOrdersRequest.ServerOrderID)
}
#endif
inline void OpenOrdersRequest::set_serverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OpenOrdersRequest.ServerOrderID)
}
inline void OpenOrdersRequest::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OpenOrdersRequest.ServerOrderID)
}
inline ::std::string* OpenOrdersRequest::mutable_serverorderid() {
  set_has_serverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OpenOrdersRequest.ServerOrderID)
  return serverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenOrdersRequest::release_serverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OpenOrdersRequest.ServerOrderID)
  if (!has_serverorderid()) {
    return NULL;
  }
  clear_has_serverorderid();
  return serverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenOrdersRequest::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid != NULL) {
    set_has_serverorderid();
  } else {
    clear_has_serverorderid();
  }
  serverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OpenOrdersRequest.ServerOrderID)
}

// optional string TradeAccount = 4;
inline bool OpenOrdersRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenOrdersRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenOrdersRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenOrdersRequest::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& OpenOrdersRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersRequest.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void OpenOrdersRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersRequest.TradeAccount)
}
#if LANG_CXX11
inline void OpenOrdersRequest::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OpenOrdersRequest.TradeAccount)
}
#endif
inline void OpenOrdersRequest::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OpenOrdersRequest.TradeAccount)
}
inline void OpenOrdersRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OpenOrdersRequest.TradeAccount)
}
inline ::std::string* OpenOrdersRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OpenOrdersRequest.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenOrdersRequest::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.OpenOrdersRequest.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenOrdersRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OpenOrdersRequest.TradeAccount)
}

// -------------------------------------------------------------------

// HistoricalOrderFillsRequest

// optional int32 RequestID = 1;
inline bool HistoricalOrderFillsRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalOrderFillsRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalOrderFillsRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalOrderFillsRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.RequestID)
  return requestid_;
}
inline void HistoricalOrderFillsRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.RequestID)
}

// optional string ServerOrderID = 2;
inline bool HistoricalOrderFillsRequest::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalOrderFillsRequest::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalOrderFillsRequest::clear_serverorderid() {
  serverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverorderid();
}
inline const ::std::string& HistoricalOrderFillsRequest::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
  return serverorderid_.GetNoArena();
}
inline void HistoricalOrderFillsRequest::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}
#if LANG_CXX11
inline void HistoricalOrderFillsRequest::set_serverorderid(::std::string&& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}
#endif
inline void HistoricalOrderFillsRequest::set_serverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}
inline void HistoricalOrderFillsRequest::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}
inline ::std::string* HistoricalOrderFillsRequest::mutable_serverorderid() {
  set_has_serverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
  return serverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillsRequest::release_serverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
  if (!has_serverorderid()) {
    return NULL;
  }
  clear_has_serverorderid();
  return serverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillsRequest::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid != NULL) {
    set_has_serverorderid();
  } else {
    clear_has_serverorderid();
  }
  serverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}

// optional int32 NumberOfDays = 3;
inline bool HistoricalOrderFillsRequest::has_numberofdays() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_numberofdays() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalOrderFillsRequest::clear_has_numberofdays() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalOrderFillsRequest::clear_numberofdays() {
  numberofdays_ = 0;
  clear_has_numberofdays();
}
inline ::google::protobuf::int32 HistoricalOrderFillsRequest::numberofdays() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.NumberOfDays)
  return numberofdays_;
}
inline void HistoricalOrderFillsRequest::set_numberofdays(::google::protobuf::int32 value) {
  set_has_numberofdays();
  numberofdays_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.NumberOfDays)
}

// optional string TradeAccount = 4;
inline bool HistoricalOrderFillsRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalOrderFillsRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalOrderFillsRequest::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& HistoricalOrderFillsRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void HistoricalOrderFillsRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}
#if LANG_CXX11
inline void HistoricalOrderFillsRequest::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}
#endif
inline void HistoricalOrderFillsRequest::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}
inline void HistoricalOrderFillsRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}
inline ::std::string* HistoricalOrderFillsRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillsRequest::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillsRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}

// -------------------------------------------------------------------

// HistoricalOrderFillsReject

// optional int32 RequestID = 1;
inline bool HistoricalOrderFillsReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalOrderFillsReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalOrderFillsReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalOrderFillsReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalOrderFillsReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsReject.RequestID)
  return requestid_;
}
inline void HistoricalOrderFillsReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsReject.RequestID)
}

// optional string RejectText = 2;
inline bool HistoricalOrderFillsReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalOrderFillsReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalOrderFillsReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalOrderFillsReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& HistoricalOrderFillsReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void HistoricalOrderFillsReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsReject.RejectText)
}
#if LANG_CXX11
inline void HistoricalOrderFillsReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillsReject.RejectText)
}
#endif
inline void HistoricalOrderFillsReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillsReject.RejectText)
}
inline void HistoricalOrderFillsReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillsReject.RejectText)
}
inline ::std::string* HistoricalOrderFillsReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillsReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillsReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillsReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillsReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillsReject.RejectText)
}

// -------------------------------------------------------------------

// CurrentPositionsRequest

// optional int32 RequestID = 1;
inline bool CurrentPositionsRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrentPositionsRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrentPositionsRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrentPositionsRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 CurrentPositionsRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsRequest.RequestID)
  return requestid_;
}
inline void CurrentPositionsRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsRequest.RequestID)
}

// optional string TradeAccount = 2;
inline bool CurrentPositionsRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentPositionsRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentPositionsRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentPositionsRequest::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& CurrentPositionsRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsRequest.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void CurrentPositionsRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsRequest.TradeAccount)
}
#if LANG_CXX11
inline void CurrentPositionsRequest::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CurrentPositionsRequest.TradeAccount)
}
#endif
inline void CurrentPositionsRequest::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CurrentPositionsRequest.TradeAccount)
}
inline void CurrentPositionsRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CurrentPositionsRequest.TradeAccount)
}
inline ::std::string* CurrentPositionsRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CurrentPositionsRequest.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrentPositionsRequest::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.CurrentPositionsRequest.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrentPositionsRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CurrentPositionsRequest.TradeAccount)
}

// -------------------------------------------------------------------

// CurrentPositionsReject

// optional int32 RequestID = 1;
inline bool CurrentPositionsReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrentPositionsReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrentPositionsReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrentPositionsReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 CurrentPositionsReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsReject.RequestID)
  return requestid_;
}
inline void CurrentPositionsReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsReject.RequestID)
}

// optional string RejectText = 2;
inline bool CurrentPositionsReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentPositionsReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentPositionsReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentPositionsReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& CurrentPositionsReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void CurrentPositionsReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsReject.RejectText)
}
#if LANG_CXX11
inline void CurrentPositionsReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.CurrentPositionsReject.RejectText)
}
#endif
inline void CurrentPositionsReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.CurrentPositionsReject.RejectText)
}
inline void CurrentPositionsReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CurrentPositionsReject.RejectText)
}
inline ::std::string* CurrentPositionsReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.CurrentPositionsReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrentPositionsReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.CurrentPositionsReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrentPositionsReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CurrentPositionsReject.RejectText)
}

// -------------------------------------------------------------------

// OrderUpdate

// optional int32 RequestID = 1;
inline bool OrderUpdate::has_requestid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrderUpdate::set_has_requestid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrderUpdate::clear_has_requestid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrderUpdate::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 OrderUpdate::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.RequestID)
  return requestid_;
}
inline void OrderUpdate::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.RequestID)
}

// optional int32 TotalNumMessages = 2;
inline bool OrderUpdate::has_totalnummessages() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrderUpdate::set_has_totalnummessages() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrderUpdate::clear_has_totalnummessages() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrderUpdate::clear_totalnummessages() {
  totalnummessages_ = 0;
  clear_has_totalnummessages();
}
inline ::google::protobuf::int32 OrderUpdate::totalnummessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.TotalNumMessages)
  return totalnummessages_;
}
inline void OrderUpdate::set_totalnummessages(::google::protobuf::int32 value) {
  set_has_totalnummessages();
  totalnummessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.TotalNumMessages)
}

// optional int32 MessageNumber = 3;
inline bool OrderUpdate::has_messagenumber() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OrderUpdate::set_has_messagenumber() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OrderUpdate::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OrderUpdate::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 OrderUpdate::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.MessageNumber)
  return messagenumber_;
}
inline void OrderUpdate::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.MessageNumber)
}

// optional string Symbol = 4;
inline bool OrderUpdate::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderUpdate::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderUpdate::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderUpdate::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& OrderUpdate::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Symbol)
  return symbol_.GetNoArena();
}
inline void OrderUpdate::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Symbol)
}
#if LANG_CXX11
inline void OrderUpdate::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.Symbol)
}
#endif
inline void OrderUpdate::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.Symbol)
}
inline void OrderUpdate::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.Symbol)
}
inline ::std::string* OrderUpdate::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.Symbol)
}

// optional string Exchange = 5;
inline bool OrderUpdate::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderUpdate::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderUpdate::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderUpdate::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& OrderUpdate::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Exchange)
  return exchange_.GetNoArena();
}
inline void OrderUpdate::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Exchange)
}
#if LANG_CXX11
inline void OrderUpdate::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.Exchange)
}
#endif
inline void OrderUpdate::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.Exchange)
}
inline void OrderUpdate::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.Exchange)
}
inline ::std::string* OrderUpdate::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.Exchange)
}

// optional string PreviousServerOrderID = 6;
inline bool OrderUpdate::has_previousserverorderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderUpdate::set_has_previousserverorderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderUpdate::clear_has_previousserverorderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderUpdate::clear_previousserverorderid() {
  previousserverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previousserverorderid();
}
inline const ::std::string& OrderUpdate::previousserverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.PreviousServerOrderID)
  return previousserverorderid_.GetNoArena();
}
inline void OrderUpdate::set_previousserverorderid(const ::std::string& value) {
  set_has_previousserverorderid();
  previousserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.PreviousServerOrderID)
}
#if LANG_CXX11
inline void OrderUpdate::set_previousserverorderid(::std::string&& value) {
  set_has_previousserverorderid();
  previousserverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.PreviousServerOrderID)
}
#endif
inline void OrderUpdate::set_previousserverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previousserverorderid();
  previousserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.PreviousServerOrderID)
}
inline void OrderUpdate::set_previousserverorderid(const char* value, size_t size) {
  set_has_previousserverorderid();
  previousserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.PreviousServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_previousserverorderid() {
  set_has_previousserverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.PreviousServerOrderID)
  return previousserverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_previousserverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.PreviousServerOrderID)
  if (!has_previousserverorderid()) {
    return NULL;
  }
  clear_has_previousserverorderid();
  return previousserverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_previousserverorderid(::std::string* previousserverorderid) {
  if (previousserverorderid != NULL) {
    set_has_previousserverorderid();
  } else {
    clear_has_previousserverorderid();
  }
  previousserverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previousserverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.PreviousServerOrderID)
}

// optional string ServerOrderID = 7;
inline bool OrderUpdate::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderUpdate::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderUpdate::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderUpdate::clear_serverorderid() {
  serverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverorderid();
}
inline const ::std::string& OrderUpdate::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ServerOrderID)
  return serverorderid_.GetNoArena();
}
inline void OrderUpdate::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ServerOrderID)
}
#if LANG_CXX11
inline void OrderUpdate::set_serverorderid(::std::string&& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.ServerOrderID)
}
#endif
inline void OrderUpdate::set_serverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ServerOrderID)
}
inline void OrderUpdate::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_serverorderid() {
  set_has_serverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ServerOrderID)
  return serverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_serverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.ServerOrderID)
  if (!has_serverorderid()) {
    return NULL;
  }
  clear_has_serverorderid();
  return serverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid != NULL) {
    set_has_serverorderid();
  } else {
    clear_has_serverorderid();
  }
  serverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ServerOrderID)
}

// optional string ClientOrderID = 8;
inline bool OrderUpdate::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderUpdate::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderUpdate::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderUpdate::clear_clientorderid() {
  clientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientorderid();
}
inline const ::std::string& OrderUpdate::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ClientOrderID)
  return clientorderid_.GetNoArena();
}
inline void OrderUpdate::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ClientOrderID)
}
#if LANG_CXX11
inline void OrderUpdate::set_clientorderid(::std::string&& value) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.ClientOrderID)
}
#endif
inline void OrderUpdate::set_clientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ClientOrderID)
}
inline void OrderUpdate::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  clientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ClientOrderID)
}
inline ::std::string* OrderUpdate::mutable_clientorderid() {
  set_has_clientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ClientOrderID)
  return clientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_clientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.ClientOrderID)
  if (!has_clientorderid()) {
    return NULL;
  }
  clear_has_clientorderid();
  return clientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid != NULL) {
    set_has_clientorderid();
  } else {
    clear_has_clientorderid();
  }
  clientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ClientOrderID)
}

// optional string ExchangeOrderID = 9;
inline bool OrderUpdate::has_exchangeorderid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderUpdate::set_has_exchangeorderid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderUpdate::clear_has_exchangeorderid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderUpdate::clear_exchangeorderid() {
  exchangeorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchangeorderid();
}
inline const ::std::string& OrderUpdate::exchangeorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ExchangeOrderID)
  return exchangeorderid_.GetNoArena();
}
inline void OrderUpdate::set_exchangeorderid(const ::std::string& value) {
  set_has_exchangeorderid();
  exchangeorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ExchangeOrderID)
}
#if LANG_CXX11
inline void OrderUpdate::set_exchangeorderid(::std::string&& value) {
  set_has_exchangeorderid();
  exchangeorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.ExchangeOrderID)
}
#endif
inline void OrderUpdate::set_exchangeorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchangeorderid();
  exchangeorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ExchangeOrderID)
}
inline void OrderUpdate::set_exchangeorderid(const char* value, size_t size) {
  set_has_exchangeorderid();
  exchangeorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ExchangeOrderID)
}
inline ::std::string* OrderUpdate::mutable_exchangeorderid() {
  set_has_exchangeorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ExchangeOrderID)
  return exchangeorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_exchangeorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.ExchangeOrderID)
  if (!has_exchangeorderid()) {
    return NULL;
  }
  clear_has_exchangeorderid();
  return exchangeorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_exchangeorderid(::std::string* exchangeorderid) {
  if (exchangeorderid != NULL) {
    set_has_exchangeorderid();
  } else {
    clear_has_exchangeorderid();
  }
  exchangeorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchangeorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ExchangeOrderID)
}

// optional .DTC_PB.OrderStatusEnum OrderStatus = 10;
inline bool OrderUpdate::has_orderstatus() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OrderUpdate::set_has_orderstatus() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OrderUpdate::clear_has_orderstatus() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OrderUpdate::clear_orderstatus() {
  orderstatus_ = 0;
  clear_has_orderstatus();
}
inline ::DTC_PB::OrderStatusEnum OrderUpdate::orderstatus() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderStatus)
  return static_cast< ::DTC_PB::OrderStatusEnum >(orderstatus_);
}
inline void OrderUpdate::set_orderstatus(::DTC_PB::OrderStatusEnum value) {
  assert(::DTC_PB::OrderStatusEnum_IsValid(value));
  set_has_orderstatus();
  orderstatus_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderStatus)
}

// optional .DTC_PB.OrderUpdateReasonEnum OrderUpdateReason = 11;
inline bool OrderUpdate::has_orderupdatereason() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OrderUpdate::set_has_orderupdatereason() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OrderUpdate::clear_has_orderupdatereason() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OrderUpdate::clear_orderupdatereason() {
  orderupdatereason_ = 0;
  clear_has_orderupdatereason();
}
inline ::DTC_PB::OrderUpdateReasonEnum OrderUpdate::orderupdatereason() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderUpdateReason)
  return static_cast< ::DTC_PB::OrderUpdateReasonEnum >(orderupdatereason_);
}
inline void OrderUpdate::set_orderupdatereason(::DTC_PB::OrderUpdateReasonEnum value) {
  assert(::DTC_PB::OrderUpdateReasonEnum_IsValid(value));
  set_has_orderupdatereason();
  orderupdatereason_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderUpdateReason)
}

// optional .DTC_PB.OrderTypeEnum OrderType = 12;
inline bool OrderUpdate::has_ordertype() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void OrderUpdate::set_has_ordertype() {
  _has_bits_[0] |= 0x00040000u;
}
inline void OrderUpdate::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void OrderUpdate::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::DTC_PB::OrderTypeEnum OrderUpdate::ordertype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderType)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_);
}
inline void OrderUpdate::set_ordertype(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderType)
}

// optional .DTC_PB.BuySellEnum BuySell = 13;
inline bool OrderUpdate::has_buysell() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void OrderUpdate::set_has_buysell() {
  _has_bits_[0] |= 0x00100000u;
}
inline void OrderUpdate::clear_has_buysell() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void OrderUpdate::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum OrderUpdate::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void OrderUpdate::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.BuySell)
}

// optional double Price1 = 14;
inline bool OrderUpdate::has_price1() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OrderUpdate::set_has_price1() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OrderUpdate::clear_has_price1() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OrderUpdate::clear_price1() {
  price1_ = 0;
  clear_has_price1();
}
inline double OrderUpdate::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Price1)
  return price1_;
}
inline void OrderUpdate::set_price1(double value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Price1)
}

// optional double Price2 = 15;
inline bool OrderUpdate::has_price2() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void OrderUpdate::set_has_price2() {
  _has_bits_[0] |= 0x00400000u;
}
inline void OrderUpdate::clear_has_price2() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void OrderUpdate::clear_price2() {
  price2_ = 0;
  clear_has_price2();
}
inline double OrderUpdate::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Price2)
  return price2_;
}
inline void OrderUpdate::set_price2(double value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Price2)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 16;
inline bool OrderUpdate::has_timeinforce() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void OrderUpdate::set_has_timeinforce() {
  _has_bits_[0] |= 0x00200000u;
}
inline void OrderUpdate::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void OrderUpdate::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum OrderUpdate::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void OrderUpdate::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 17;
inline bool OrderUpdate::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void OrderUpdate::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void OrderUpdate::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void OrderUpdate::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 OrderUpdate::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void OrderUpdate::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.GoodTillDateTime)
}

// optional double OrderQuantity = 18;
inline bool OrderUpdate::has_orderquantity() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void OrderUpdate::set_has_orderquantity() {
  _has_bits_[0] |= 0x01000000u;
}
inline void OrderUpdate::clear_has_orderquantity() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void OrderUpdate::clear_orderquantity() {
  orderquantity_ = 0;
  clear_has_orderquantity();
}
inline double OrderUpdate::orderquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderQuantity)
  return orderquantity_;
}
inline void OrderUpdate::set_orderquantity(double value) {
  set_has_orderquantity();
  orderquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderQuantity)
}

// optional double FilledQuantity = 19;
inline bool OrderUpdate::has_filledquantity() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void OrderUpdate::set_has_filledquantity() {
  _has_bits_[0] |= 0x02000000u;
}
inline void OrderUpdate::clear_has_filledquantity() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void OrderUpdate::clear_filledquantity() {
  filledquantity_ = 0;
  clear_has_filledquantity();
}
inline double OrderUpdate::filledquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.FilledQuantity)
  return filledquantity_;
}
inline void OrderUpdate::set_filledquantity(double value) {
  set_has_filledquantity();
  filledquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.FilledQuantity)
}

// optional double RemainingQuantity = 20;
inline bool OrderUpdate::has_remainingquantity() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void OrderUpdate::set_has_remainingquantity() {
  _has_bits_[0] |= 0x04000000u;
}
inline void OrderUpdate::clear_has_remainingquantity() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void OrderUpdate::clear_remainingquantity() {
  remainingquantity_ = 0;
  clear_has_remainingquantity();
}
inline double OrderUpdate::remainingquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.RemainingQuantity)
  return remainingquantity_;
}
inline void OrderUpdate::set_remainingquantity(double value) {
  set_has_remainingquantity();
  remainingquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.RemainingQuantity)
}

// optional double AverageFillPrice = 21;
inline bool OrderUpdate::has_averagefillprice() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void OrderUpdate::set_has_averagefillprice() {
  _has_bits_[0] |= 0x08000000u;
}
inline void OrderUpdate::clear_has_averagefillprice() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void OrderUpdate::clear_averagefillprice() {
  averagefillprice_ = 0;
  clear_has_averagefillprice();
}
inline double OrderUpdate::averagefillprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.AverageFillPrice)
  return averagefillprice_;
}
inline void OrderUpdate::set_averagefillprice(double value) {
  set_has_averagefillprice();
  averagefillprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.AverageFillPrice)
}

// optional double LastFillPrice = 22;
inline bool OrderUpdate::has_lastfillprice() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void OrderUpdate::set_has_lastfillprice() {
  _has_bits_[0] |= 0x10000000u;
}
inline void OrderUpdate::clear_has_lastfillprice() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void OrderUpdate::clear_lastfillprice() {
  lastfillprice_ = 0;
  clear_has_lastfillprice();
}
inline double OrderUpdate::lastfillprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillPrice)
  return lastfillprice_;
}
inline void OrderUpdate::set_lastfillprice(double value) {
  set_has_lastfillprice();
  lastfillprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillPrice)
}

// optional sfixed64 LastFillDateTime = 23;
inline bool OrderUpdate::has_lastfilldatetime() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void OrderUpdate::set_has_lastfilldatetime() {
  _has_bits_[0] |= 0x20000000u;
}
inline void OrderUpdate::clear_has_lastfilldatetime() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void OrderUpdate::clear_lastfilldatetime() {
  lastfilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_lastfilldatetime();
}
inline ::google::protobuf::int64 OrderUpdate::lastfilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillDateTime)
  return lastfilldatetime_;
}
inline void OrderUpdate::set_lastfilldatetime(::google::protobuf::int64 value) {
  set_has_lastfilldatetime();
  lastfilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillDateTime)
}

// optional double LastFillQuantity = 24;
inline bool OrderUpdate::has_lastfillquantity() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void OrderUpdate::set_has_lastfillquantity() {
  _has_bits_[0] |= 0x40000000u;
}
inline void OrderUpdate::clear_has_lastfillquantity() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void OrderUpdate::clear_lastfillquantity() {
  lastfillquantity_ = 0;
  clear_has_lastfillquantity();
}
inline double OrderUpdate::lastfillquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillQuantity)
  return lastfillquantity_;
}
inline void OrderUpdate::set_lastfillquantity(double value) {
  set_has_lastfillquantity();
  lastfillquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillQuantity)
}

// optional string LastFillExecutionID = 25;
inline bool OrderUpdate::has_lastfillexecutionid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderUpdate::set_has_lastfillexecutionid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderUpdate::clear_has_lastfillexecutionid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderUpdate::clear_lastfillexecutionid() {
  lastfillexecutionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lastfillexecutionid();
}
inline const ::std::string& OrderUpdate::lastfillexecutionid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillExecutionID)
  return lastfillexecutionid_.GetNoArena();
}
inline void OrderUpdate::set_lastfillexecutionid(const ::std::string& value) {
  set_has_lastfillexecutionid();
  lastfillexecutionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillExecutionID)
}
#if LANG_CXX11
inline void OrderUpdate::set_lastfillexecutionid(::std::string&& value) {
  set_has_lastfillexecutionid();
  lastfillexecutionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.LastFillExecutionID)
}
#endif
inline void OrderUpdate::set_lastfillexecutionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lastfillexecutionid();
  lastfillexecutionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.LastFillExecutionID)
}
inline void OrderUpdate::set_lastfillexecutionid(const char* value, size_t size) {
  set_has_lastfillexecutionid();
  lastfillexecutionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.LastFillExecutionID)
}
inline ::std::string* OrderUpdate::mutable_lastfillexecutionid() {
  set_has_lastfillexecutionid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.LastFillExecutionID)
  return lastfillexecutionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_lastfillexecutionid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.LastFillExecutionID)
  if (!has_lastfillexecutionid()) {
    return NULL;
  }
  clear_has_lastfillexecutionid();
  return lastfillexecutionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_lastfillexecutionid(::std::string* lastfillexecutionid) {
  if (lastfillexecutionid != NULL) {
    set_has_lastfillexecutionid();
  } else {
    clear_has_lastfillexecutionid();
  }
  lastfillexecutionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lastfillexecutionid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.LastFillExecutionID)
}

// optional string TradeAccount = 26;
inline bool OrderUpdate::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderUpdate::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderUpdate::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderUpdate::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& OrderUpdate::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void OrderUpdate::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.TradeAccount)
}
#if LANG_CXX11
inline void OrderUpdate::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.TradeAccount)
}
#endif
inline void OrderUpdate::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.TradeAccount)
}
inline void OrderUpdate::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.TradeAccount)
}
inline ::std::string* OrderUpdate::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.TradeAccount)
}

// optional string InfoText = 27;
inline bool OrderUpdate::has_infotext() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderUpdate::set_has_infotext() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderUpdate::clear_has_infotext() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderUpdate::clear_infotext() {
  infotext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infotext();
}
inline const ::std::string& OrderUpdate::infotext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.InfoText)
  return infotext_.GetNoArena();
}
inline void OrderUpdate::set_infotext(const ::std::string& value) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.InfoText)
}
#if LANG_CXX11
inline void OrderUpdate::set_infotext(::std::string&& value) {
  set_has_infotext();
  infotext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.InfoText)
}
#endif
inline void OrderUpdate::set_infotext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.InfoText)
}
inline void OrderUpdate::set_infotext(const char* value, size_t size) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.InfoText)
}
inline ::std::string* OrderUpdate::mutable_infotext() {
  set_has_infotext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.InfoText)
  return infotext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_infotext() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.InfoText)
  if (!has_infotext()) {
    return NULL;
  }
  clear_has_infotext();
  return infotext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_infotext(::std::string* infotext) {
  if (infotext != NULL) {
    set_has_infotext();
  } else {
    clear_has_infotext();
  }
  infotext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infotext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.InfoText)
}

// optional uint32 NoOrders = 28;
inline bool OrderUpdate::has_noorders() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void OrderUpdate::set_has_noorders() {
  _has_bits_[0] |= 0x80000000u;
}
inline void OrderUpdate::clear_has_noorders() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void OrderUpdate::clear_noorders() {
  noorders_ = 0u;
  clear_has_noorders();
}
inline ::google::protobuf::uint32 OrderUpdate::noorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.NoOrders)
  return noorders_;
}
inline void OrderUpdate::set_noorders(::google::protobuf::uint32 value) {
  set_has_noorders();
  noorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.NoOrders)
}

// optional string ParentServerOrderID = 29;
inline bool OrderUpdate::has_parentserverorderid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderUpdate::set_has_parentserverorderid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderUpdate::clear_has_parentserverorderid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderUpdate::clear_parentserverorderid() {
  parentserverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parentserverorderid();
}
inline const ::std::string& OrderUpdate::parentserverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ParentServerOrderID)
  return parentserverorderid_.GetNoArena();
}
inline void OrderUpdate::set_parentserverorderid(const ::std::string& value) {
  set_has_parentserverorderid();
  parentserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ParentServerOrderID)
}
#if LANG_CXX11
inline void OrderUpdate::set_parentserverorderid(::std::string&& value) {
  set_has_parentserverorderid();
  parentserverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.ParentServerOrderID)
}
#endif
inline void OrderUpdate::set_parentserverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parentserverorderid();
  parentserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ParentServerOrderID)
}
inline void OrderUpdate::set_parentserverorderid(const char* value, size_t size) {
  set_has_parentserverorderid();
  parentserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ParentServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_parentserverorderid() {
  set_has_parentserverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ParentServerOrderID)
  return parentserverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_parentserverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.ParentServerOrderID)
  if (!has_parentserverorderid()) {
    return NULL;
  }
  clear_has_parentserverorderid();
  return parentserverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_parentserverorderid(::std::string* parentserverorderid) {
  if (parentserverorderid != NULL) {
    set_has_parentserverorderid();
  } else {
    clear_has_parentserverorderid();
  }
  parentserverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parentserverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ParentServerOrderID)
}

// optional string OCOLinkedOrderServerOrderID = 30;
inline bool OrderUpdate::has_ocolinkedorderserverorderid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderUpdate::set_has_ocolinkedorderserverorderid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderUpdate::clear_has_ocolinkedorderserverorderid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderUpdate::clear_ocolinkedorderserverorderid() {
  ocolinkedorderserverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ocolinkedorderserverorderid();
}
inline const ::std::string& OrderUpdate::ocolinkedorderserverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
  return ocolinkedorderserverorderid_.GetNoArena();
}
inline void OrderUpdate::set_ocolinkedorderserverorderid(const ::std::string& value) {
  set_has_ocolinkedorderserverorderid();
  ocolinkedorderserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}
#if LANG_CXX11
inline void OrderUpdate::set_ocolinkedorderserverorderid(::std::string&& value) {
  set_has_ocolinkedorderserverorderid();
  ocolinkedorderserverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}
#endif
inline void OrderUpdate::set_ocolinkedorderserverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ocolinkedorderserverorderid();
  ocolinkedorderserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}
inline void OrderUpdate::set_ocolinkedorderserverorderid(const char* value, size_t size) {
  set_has_ocolinkedorderserverorderid();
  ocolinkedorderserverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_ocolinkedorderserverorderid() {
  set_has_ocolinkedorderserverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
  return ocolinkedorderserverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_ocolinkedorderserverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
  if (!has_ocolinkedorderserverorderid()) {
    return NULL;
  }
  clear_has_ocolinkedorderserverorderid();
  return ocolinkedorderserverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_ocolinkedorderserverorderid(::std::string* ocolinkedorderserverorderid) {
  if (ocolinkedorderserverorderid != NULL) {
    set_has_ocolinkedorderserverorderid();
  } else {
    clear_has_ocolinkedorderserverorderid();
  }
  ocolinkedorderserverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ocolinkedorderserverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 31;
inline bool OrderUpdate::has_openorclose() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void OrderUpdate::set_has_openorclose() {
  _has_bits_[1] |= 0x00000001u;
}
inline void OrderUpdate::clear_has_openorclose() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void OrderUpdate::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum OrderUpdate::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void OrderUpdate::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OpenOrClose)
}

// optional string PreviousClientOrderID = 32;
inline bool OrderUpdate::has_previousclientorderid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderUpdate::set_has_previousclientorderid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderUpdate::clear_has_previousclientorderid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderUpdate::clear_previousclientorderid() {
  previousclientorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previousclientorderid();
}
inline const ::std::string& OrderUpdate::previousclientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.PreviousClientOrderID)
  return previousclientorderid_.GetNoArena();
}
inline void OrderUpdate::set_previousclientorderid(const ::std::string& value) {
  set_has_previousclientorderid();
  previousclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.PreviousClientOrderID)
}
#if LANG_CXX11
inline void OrderUpdate::set_previousclientorderid(::std::string&& value) {
  set_has_previousclientorderid();
  previousclientorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.PreviousClientOrderID)
}
#endif
inline void OrderUpdate::set_previousclientorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previousclientorderid();
  previousclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.PreviousClientOrderID)
}
inline void OrderUpdate::set_previousclientorderid(const char* value, size_t size) {
  set_has_previousclientorderid();
  previousclientorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.PreviousClientOrderID)
}
inline ::std::string* OrderUpdate::mutable_previousclientorderid() {
  set_has_previousclientorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.PreviousClientOrderID)
  return previousclientorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_previousclientorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.PreviousClientOrderID)
  if (!has_previousclientorderid()) {
    return NULL;
  }
  clear_has_previousclientorderid();
  return previousclientorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_previousclientorderid(::std::string* previousclientorderid) {
  if (previousclientorderid != NULL) {
    set_has_previousclientorderid();
  } else {
    clear_has_previousclientorderid();
  }
  previousclientorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previousclientorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.PreviousClientOrderID)
}

// optional string FreeFormText = 33;
inline bool OrderUpdate::has_freeformtext() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderUpdate::set_has_freeformtext() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderUpdate::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderUpdate::clear_freeformtext() {
  freeformtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_freeformtext();
}
inline const ::std::string& OrderUpdate::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.FreeFormText)
  return freeformtext_.GetNoArena();
}
inline void OrderUpdate::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.FreeFormText)
}
#if LANG_CXX11
inline void OrderUpdate::set_freeformtext(::std::string&& value) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OrderUpdate.FreeFormText)
}
#endif
inline void OrderUpdate::set_freeformtext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.FreeFormText)
}
inline void OrderUpdate::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  freeformtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.FreeFormText)
}
inline ::std::string* OrderUpdate::mutable_freeformtext() {
  set_has_freeformtext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.FreeFormText)
  return freeformtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderUpdate::release_freeformtext() {
  // @@protoc_insertion_point(field_release:DTC_PB.OrderUpdate.FreeFormText)
  if (!has_freeformtext()) {
    return NULL;
  }
  clear_has_freeformtext();
  return freeformtext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderUpdate::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext != NULL) {
    set_has_freeformtext();
  } else {
    clear_has_freeformtext();
  }
  freeformtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), freeformtext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.FreeFormText)
}

// optional sfixed64 OrderReceivedDateTime = 34;
inline bool OrderUpdate::has_orderreceiveddatetime() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void OrderUpdate::set_has_orderreceiveddatetime() {
  _has_bits_[1] |= 0x00000002u;
}
inline void OrderUpdate::clear_has_orderreceiveddatetime() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void OrderUpdate::clear_orderreceiveddatetime() {
  orderreceiveddatetime_ = GOOGLE_LONGLONG(0);
  clear_has_orderreceiveddatetime();
}
inline ::google::protobuf::int64 OrderUpdate::orderreceiveddatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderReceivedDateTime)
  return orderreceiveddatetime_;
}
inline void OrderUpdate::set_orderreceiveddatetime(::google::protobuf::int64 value) {
  set_has_orderreceiveddatetime();
  orderreceiveddatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderReceivedDateTime)
}

// -------------------------------------------------------------------

// OpenOrdersReject

// optional int32 RequestID = 1;
inline bool OpenOrdersReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenOrdersReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenOrdersReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenOrdersReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 OpenOrdersReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersReject.RequestID)
  return requestid_;
}
inline void OpenOrdersReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersReject.RequestID)
}

// optional string RejectText = 2;
inline bool OpenOrdersReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenOrdersReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenOrdersReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenOrdersReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& OpenOrdersReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void OpenOrdersReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersReject.RejectText)
}
#if LANG_CXX11
inline void OpenOrdersReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.OpenOrdersReject.RejectText)
}
#endif
inline void OpenOrdersReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.OpenOrdersReject.RejectText)
}
inline void OpenOrdersReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OpenOrdersReject.RejectText)
}
inline ::std::string* OpenOrdersReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.OpenOrdersReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenOrdersReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.OpenOrdersReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenOrdersReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OpenOrdersReject.RejectText)
}

// -------------------------------------------------------------------

// HistoricalOrderFillResponse

// optional int32 RequestID = 1;
inline bool HistoricalOrderFillResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalOrderFillResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalOrderFillResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalOrderFillResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.RequestID)
  return requestid_;
}
inline void HistoricalOrderFillResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.RequestID)
}

// optional int32 TotalNumberMessages = 2;
inline bool HistoricalOrderFillResponse::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalOrderFillResponse::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalOrderFillResponse::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 HistoricalOrderFillResponse::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void HistoricalOrderFillResponse::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.TotalNumberMessages)
}

// optional int32 MessageNumber = 3;
inline bool HistoricalOrderFillResponse::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalOrderFillResponse::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalOrderFillResponse::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 HistoricalOrderFillResponse::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.MessageNumber)
  return messagenumber_;
}
inline void HistoricalOrderFillResponse::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.MessageNumber)
}

// optional string Symbol = 4;
inline bool HistoricalOrderFillResponse::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalOrderFillResponse::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalOrderFillResponse::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& HistoricalOrderFillResponse::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Symbol)
  return symbol_.GetNoArena();
}
inline void HistoricalOrderFillResponse::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Symbol)
}
#if LANG_CXX11
inline void HistoricalOrderFillResponse::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillResponse.Symbol)
}
#endif
inline void HistoricalOrderFillResponse::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.Symbol)
}
inline void HistoricalOrderFillResponse::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.Symbol)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillResponse::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillResponse.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillResponse::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.Symbol)
}

// optional string Exchange = 5;
inline bool HistoricalOrderFillResponse::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalOrderFillResponse::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalOrderFillResponse::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& HistoricalOrderFillResponse::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Exchange)
  return exchange_.GetNoArena();
}
inline void HistoricalOrderFillResponse::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Exchange)
}
#if LANG_CXX11
inline void HistoricalOrderFillResponse::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillResponse.Exchange)
}
#endif
inline void HistoricalOrderFillResponse::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.Exchange)
}
inline void HistoricalOrderFillResponse::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.Exchange)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillResponse::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillResponse.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillResponse::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.Exchange)
}

// optional string ServerOrderID = 6;
inline bool HistoricalOrderFillResponse::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalOrderFillResponse::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalOrderFillResponse::clear_serverorderid() {
  serverorderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverorderid();
}
inline const ::std::string& HistoricalOrderFillResponse::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
  return serverorderid_.GetNoArena();
}
inline void HistoricalOrderFillResponse::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}
#if LANG_CXX11
inline void HistoricalOrderFillResponse::set_serverorderid(::std::string&& value) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}
#endif
inline void HistoricalOrderFillResponse::set_serverorderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}
inline void HistoricalOrderFillResponse::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  serverorderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_serverorderid() {
  set_has_serverorderid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
  return serverorderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillResponse::release_serverorderid() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
  if (!has_serverorderid()) {
    return NULL;
  }
  clear_has_serverorderid();
  return serverorderid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillResponse::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid != NULL) {
    set_has_serverorderid();
  } else {
    clear_has_serverorderid();
  }
  serverorderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverorderid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}

// optional .DTC_PB.BuySellEnum BuySell = 7;
inline bool HistoricalOrderFillResponse::has_buysell() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_buysell() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalOrderFillResponse::clear_has_buysell() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalOrderFillResponse::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum HistoricalOrderFillResponse::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void HistoricalOrderFillResponse::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.BuySell)
}

// optional double Price = 8;
inline bool HistoricalOrderFillResponse::has_price() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_price() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoricalOrderFillResponse::clear_has_price() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoricalOrderFillResponse::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double HistoricalOrderFillResponse::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Price)
  return price_;
}
inline void HistoricalOrderFillResponse::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Price)
}

// optional sfixed64 DateTime = 9;
inline bool HistoricalOrderFillResponse::has_datetime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_datetime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HistoricalOrderFillResponse::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HistoricalOrderFillResponse::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 HistoricalOrderFillResponse::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.DateTime)
  return datetime_;
}
inline void HistoricalOrderFillResponse::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.DateTime)
}

// optional double Quantity = 10;
inline bool HistoricalOrderFillResponse::has_quantity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_quantity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HistoricalOrderFillResponse::clear_has_quantity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HistoricalOrderFillResponse::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double HistoricalOrderFillResponse::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Quantity)
  return quantity_;
}
inline void HistoricalOrderFillResponse::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Quantity)
}

// optional string UniqueExecutionID = 11;
inline bool HistoricalOrderFillResponse::has_uniqueexecutionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_uniqueexecutionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalOrderFillResponse::clear_has_uniqueexecutionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalOrderFillResponse::clear_uniqueexecutionid() {
  uniqueexecutionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uniqueexecutionid();
}
inline const ::std::string& HistoricalOrderFillResponse::uniqueexecutionid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
  return uniqueexecutionid_.GetNoArena();
}
inline void HistoricalOrderFillResponse::set_uniqueexecutionid(const ::std::string& value) {
  set_has_uniqueexecutionid();
  uniqueexecutionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}
#if LANG_CXX11
inline void HistoricalOrderFillResponse::set_uniqueexecutionid(::std::string&& value) {
  set_has_uniqueexecutionid();
  uniqueexecutionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}
#endif
inline void HistoricalOrderFillResponse::set_uniqueexecutionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uniqueexecutionid();
  uniqueexecutionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}
inline void HistoricalOrderFillResponse::set_uniqueexecutionid(const char* value, size_t size) {
  set_has_uniqueexecutionid();
  uniqueexecutionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_uniqueexecutionid() {
  set_has_uniqueexecutionid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
  return uniqueexecutionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillResponse::release_uniqueexecutionid() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
  if (!has_uniqueexecutionid()) {
    return NULL;
  }
  clear_has_uniqueexecutionid();
  return uniqueexecutionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillResponse::set_allocated_uniqueexecutionid(::std::string* uniqueexecutionid) {
  if (uniqueexecutionid != NULL) {
    set_has_uniqueexecutionid();
  } else {
    clear_has_uniqueexecutionid();
  }
  uniqueexecutionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uniqueexecutionid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}

// optional string TradeAccount = 12;
inline bool HistoricalOrderFillResponse::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalOrderFillResponse::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalOrderFillResponse::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& HistoricalOrderFillResponse::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void HistoricalOrderFillResponse::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}
#if LANG_CXX11
inline void HistoricalOrderFillResponse::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}
#endif
inline void HistoricalOrderFillResponse::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}
inline void HistoricalOrderFillResponse::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillResponse::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillResponse::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenClose = 13;
inline bool HistoricalOrderFillResponse::has_openclose() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_openclose() {
  _has_bits_[0] |= 0x00002000u;
}
inline void HistoricalOrderFillResponse::clear_has_openclose() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void HistoricalOrderFillResponse::clear_openclose() {
  openclose_ = 0;
  clear_has_openclose();
}
inline ::DTC_PB::OpenCloseTradeEnum HistoricalOrderFillResponse::openclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.OpenClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openclose_);
}
inline void HistoricalOrderFillResponse::set_openclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openclose();
  openclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.OpenClose)
}

// optional uint32 NoOrderFills = 14;
inline bool HistoricalOrderFillResponse::has_noorderfills() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_noorderfills() {
  _has_bits_[0] |= 0x00004000u;
}
inline void HistoricalOrderFillResponse::clear_has_noorderfills() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void HistoricalOrderFillResponse::clear_noorderfills() {
  noorderfills_ = 0u;
  clear_has_noorderfills();
}
inline ::google::protobuf::uint32 HistoricalOrderFillResponse::noorderfills() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.NoOrderFills)
  return noorderfills_;
}
inline void HistoricalOrderFillResponse::set_noorderfills(::google::protobuf::uint32 value) {
  set_has_noorderfills();
  noorderfills_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.NoOrderFills)
}

// optional string InfoText = 15;
inline bool HistoricalOrderFillResponse::has_infotext() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_infotext() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalOrderFillResponse::clear_has_infotext() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalOrderFillResponse::clear_infotext() {
  infotext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infotext();
}
inline const ::std::string& HistoricalOrderFillResponse::infotext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.InfoText)
  return infotext_.GetNoArena();
}
inline void HistoricalOrderFillResponse::set_infotext(const ::std::string& value) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.InfoText)
}
#if LANG_CXX11
inline void HistoricalOrderFillResponse::set_infotext(::std::string&& value) {
  set_has_infotext();
  infotext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalOrderFillResponse.InfoText)
}
#endif
inline void HistoricalOrderFillResponse::set_infotext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.InfoText)
}
inline void HistoricalOrderFillResponse::set_infotext(const char* value, size_t size) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.InfoText)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_infotext() {
  set_has_infotext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.InfoText)
  return infotext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalOrderFillResponse::release_infotext() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalOrderFillResponse.InfoText)
  if (!has_infotext()) {
    return NULL;
  }
  clear_has_infotext();
  return infotext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalOrderFillResponse::set_allocated_infotext(::std::string* infotext) {
  if (infotext != NULL) {
    set_has_infotext();
  } else {
    clear_has_infotext();
  }
  infotext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infotext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.InfoText)
}

// optional double HighPriceDuringPosition = 16;
inline bool HistoricalOrderFillResponse::has_highpriceduringposition() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_highpriceduringposition() {
  _has_bits_[0] |= 0x00008000u;
}
inline void HistoricalOrderFillResponse::clear_has_highpriceduringposition() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void HistoricalOrderFillResponse::clear_highpriceduringposition() {
  highpriceduringposition_ = 0;
  clear_has_highpriceduringposition();
}
inline double HistoricalOrderFillResponse::highpriceduringposition() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.HighPriceDuringPosition)
  return highpriceduringposition_;
}
inline void HistoricalOrderFillResponse::set_highpriceduringposition(double value) {
  set_has_highpriceduringposition();
  highpriceduringposition_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.HighPriceDuringPosition)
}

// optional double LowPriceDuringPosition = 17;
inline bool HistoricalOrderFillResponse::has_lowpriceduringposition() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_lowpriceduringposition() {
  _has_bits_[0] |= 0x00010000u;
}
inline void HistoricalOrderFillResponse::clear_has_lowpriceduringposition() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void HistoricalOrderFillResponse::clear_lowpriceduringposition() {
  lowpriceduringposition_ = 0;
  clear_has_lowpriceduringposition();
}
inline double HistoricalOrderFillResponse::lowpriceduringposition() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.LowPriceDuringPosition)
  return lowpriceduringposition_;
}
inline void HistoricalOrderFillResponse::set_lowpriceduringposition(double value) {
  set_has_lowpriceduringposition();
  lowpriceduringposition_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.LowPriceDuringPosition)
}

// optional double PositionQuantity = 18;
inline bool HistoricalOrderFillResponse::has_positionquantity() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_positionquantity() {
  _has_bits_[0] |= 0x00020000u;
}
inline void HistoricalOrderFillResponse::clear_has_positionquantity() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void HistoricalOrderFillResponse::clear_positionquantity() {
  positionquantity_ = 0;
  clear_has_positionquantity();
}
inline double HistoricalOrderFillResponse::positionquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.PositionQuantity)
  return positionquantity_;
}
inline void HistoricalOrderFillResponse::set_positionquantity(double value) {
  set_has_positionquantity();
  positionquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.PositionQuantity)
}

// -------------------------------------------------------------------

// PositionUpdate

// optional int32 RequestID = 1;
inline bool PositionUpdate::has_requestid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PositionUpdate::set_has_requestid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PositionUpdate::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PositionUpdate::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 PositionUpdate::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.RequestID)
  return requestid_;
}
inline void PositionUpdate::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.RequestID)
}

// optional int32 TotalNumberMessages = 2;
inline bool PositionUpdate::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PositionUpdate::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PositionUpdate::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PositionUpdate::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 PositionUpdate::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void PositionUpdate::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.TotalNumberMessages)
}

// optional int32 MessageNumber = 3;
inline bool PositionUpdate::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PositionUpdate::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PositionUpdate::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PositionUpdate::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 PositionUpdate::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.MessageNumber)
  return messagenumber_;
}
inline void PositionUpdate::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.MessageNumber)
}

// optional string Symbol = 4;
inline bool PositionUpdate::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionUpdate::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionUpdate::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionUpdate::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& PositionUpdate::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Symbol)
  return symbol_.GetNoArena();
}
inline void PositionUpdate::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Symbol)
}
#if LANG_CXX11
inline void PositionUpdate::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.PositionUpdate.Symbol)
}
#endif
inline void PositionUpdate::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.Symbol)
}
inline void PositionUpdate::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.Symbol)
}
inline ::std::string* PositionUpdate::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PositionUpdate::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.PositionUpdate.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PositionUpdate::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.Symbol)
}

// optional string Exchange = 5;
inline bool PositionUpdate::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionUpdate::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionUpdate::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionUpdate::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& PositionUpdate::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Exchange)
  return exchange_.GetNoArena();
}
inline void PositionUpdate::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Exchange)
}
#if LANG_CXX11
inline void PositionUpdate::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.PositionUpdate.Exchange)
}
#endif
inline void PositionUpdate::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.Exchange)
}
inline void PositionUpdate::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.Exchange)
}
inline ::std::string* PositionUpdate::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PositionUpdate::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.PositionUpdate.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PositionUpdate::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.Exchange)
}

// optional double Quantity = 6;
inline bool PositionUpdate::has_quantity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PositionUpdate::set_has_quantity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PositionUpdate::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PositionUpdate::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double PositionUpdate::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Quantity)
  return quantity_;
}
inline void PositionUpdate::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Quantity)
}

// optional double AveragePrice = 7;
inline bool PositionUpdate::has_averageprice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PositionUpdate::set_has_averageprice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PositionUpdate::clear_has_averageprice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PositionUpdate::clear_averageprice() {
  averageprice_ = 0;
  clear_has_averageprice();
}
inline double PositionUpdate::averageprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.AveragePrice)
  return averageprice_;
}
inline void PositionUpdate::set_averageprice(double value) {
  set_has_averageprice();
  averageprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.AveragePrice)
}

// optional string PositionIdentifier = 8;
inline bool PositionUpdate::has_positionidentifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionUpdate::set_has_positionidentifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionUpdate::clear_has_positionidentifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionUpdate::clear_positionidentifier() {
  positionidentifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_positionidentifier();
}
inline const ::std::string& PositionUpdate::positionidentifier() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.PositionIdentifier)
  return positionidentifier_.GetNoArena();
}
inline void PositionUpdate::set_positionidentifier(const ::std::string& value) {
  set_has_positionidentifier();
  positionidentifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.PositionIdentifier)
}
#if LANG_CXX11
inline void PositionUpdate::set_positionidentifier(::std::string&& value) {
  set_has_positionidentifier();
  positionidentifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.PositionUpdate.PositionIdentifier)
}
#endif
inline void PositionUpdate::set_positionidentifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_positionidentifier();
  positionidentifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.PositionIdentifier)
}
inline void PositionUpdate::set_positionidentifier(const char* value, size_t size) {
  set_has_positionidentifier();
  positionidentifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.PositionIdentifier)
}
inline ::std::string* PositionUpdate::mutable_positionidentifier() {
  set_has_positionidentifier();
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.PositionIdentifier)
  return positionidentifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PositionUpdate::release_positionidentifier() {
  // @@protoc_insertion_point(field_release:DTC_PB.PositionUpdate.PositionIdentifier)
  if (!has_positionidentifier()) {
    return NULL;
  }
  clear_has_positionidentifier();
  return positionidentifier_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PositionUpdate::set_allocated_positionidentifier(::std::string* positionidentifier) {
  if (positionidentifier != NULL) {
    set_has_positionidentifier();
  } else {
    clear_has_positionidentifier();
  }
  positionidentifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), positionidentifier);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.PositionIdentifier)
}

// optional string TradeAccount = 9;
inline bool PositionUpdate::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionUpdate::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionUpdate::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionUpdate::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& PositionUpdate::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void PositionUpdate::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.TradeAccount)
}
#if LANG_CXX11
inline void PositionUpdate::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.PositionUpdate.TradeAccount)
}
#endif
inline void PositionUpdate::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.TradeAccount)
}
inline void PositionUpdate::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.TradeAccount)
}
inline ::std::string* PositionUpdate::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PositionUpdate::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.PositionUpdate.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PositionUpdate::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.TradeAccount)
}

// optional uint32 NoPositions = 10;
inline bool PositionUpdate::has_nopositions() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PositionUpdate::set_has_nopositions() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PositionUpdate::clear_has_nopositions() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PositionUpdate::clear_nopositions() {
  nopositions_ = 0u;
  clear_has_nopositions();
}
inline ::google::protobuf::uint32 PositionUpdate::nopositions() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.NoPositions)
  return nopositions_;
}
inline void PositionUpdate::set_nopositions(::google::protobuf::uint32 value) {
  set_has_nopositions();
  nopositions_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.NoPositions)
}

// optional uint32 Unsolicited = 11;
inline bool PositionUpdate::has_unsolicited() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PositionUpdate::set_has_unsolicited() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PositionUpdate::clear_has_unsolicited() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PositionUpdate::clear_unsolicited() {
  unsolicited_ = 0u;
  clear_has_unsolicited();
}
inline ::google::protobuf::uint32 PositionUpdate::unsolicited() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Unsolicited)
  return unsolicited_;
}
inline void PositionUpdate::set_unsolicited(::google::protobuf::uint32 value) {
  set_has_unsolicited();
  unsolicited_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Unsolicited)
}

// optional double MarginRequirement = 12;
inline bool PositionUpdate::has_marginrequirement() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PositionUpdate::set_has_marginrequirement() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PositionUpdate::clear_has_marginrequirement() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PositionUpdate::clear_marginrequirement() {
  marginrequirement_ = 0;
  clear_has_marginrequirement();
}
inline double PositionUpdate::marginrequirement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.MarginRequirement)
  return marginrequirement_;
}
inline void PositionUpdate::set_marginrequirement(double value) {
  set_has_marginrequirement();
  marginrequirement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.MarginRequirement)
}

// -------------------------------------------------------------------

// TradeAccountsRequest

// optional int32 RequestID = 1;
inline bool TradeAccountsRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeAccountsRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeAccountsRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeAccountsRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 TradeAccountsRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountsRequest.RequestID)
  return requestid_;
}
inline void TradeAccountsRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountsRequest.RequestID)
}

// -------------------------------------------------------------------

// TradeAccountResponse

// optional int32 TotalNumberMessages = 1;
inline bool TradeAccountResponse::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeAccountResponse::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeAccountResponse::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeAccountResponse::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 TradeAccountResponse::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void TradeAccountResponse::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.TotalNumberMessages)
}

// optional int32 MessageNumber = 2;
inline bool TradeAccountResponse::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeAccountResponse::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeAccountResponse::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeAccountResponse::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 TradeAccountResponse::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.MessageNumber)
  return messagenumber_;
}
inline void TradeAccountResponse::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.MessageNumber)
}

// optional string TradeAccount = 3;
inline bool TradeAccountResponse::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeAccountResponse::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeAccountResponse::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeAccountResponse::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& TradeAccountResponse::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void TradeAccountResponse::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.TradeAccount)
}
#if LANG_CXX11
inline void TradeAccountResponse::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.TradeAccountResponse.TradeAccount)
}
#endif
inline void TradeAccountResponse::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.TradeAccountResponse.TradeAccount)
}
inline void TradeAccountResponse::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.TradeAccountResponse.TradeAccount)
}
inline ::std::string* TradeAccountResponse::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.TradeAccountResponse.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TradeAccountResponse::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.TradeAccountResponse.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TradeAccountResponse::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.TradeAccountResponse.TradeAccount)
}

// optional int32 RequestID = 4;
inline bool TradeAccountResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeAccountResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeAccountResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeAccountResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 TradeAccountResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.RequestID)
  return requestid_;
}
inline void TradeAccountResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.RequestID)
}

// -------------------------------------------------------------------

// ExchangeListRequest

// optional int32 RequestID = 1;
inline bool ExchangeListRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeListRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeListRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeListRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 ExchangeListRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListRequest.RequestID)
  return requestid_;
}
inline void ExchangeListRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListRequest.RequestID)
}

// -------------------------------------------------------------------

// ExchangeListResponse

// optional int32 RequestID = 1;
inline bool ExchangeListResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeListResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeListResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeListResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 ExchangeListResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.RequestID)
  return requestid_;
}
inline void ExchangeListResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.RequestID)
}

// optional string Exchange = 2;
inline bool ExchangeListResponse::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeListResponse::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeListResponse::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeListResponse::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& ExchangeListResponse::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.Exchange)
  return exchange_.GetNoArena();
}
inline void ExchangeListResponse::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.Exchange)
}
#if LANG_CXX11
inline void ExchangeListResponse::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.ExchangeListResponse.Exchange)
}
#endif
inline void ExchangeListResponse::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.ExchangeListResponse.Exchange)
}
inline void ExchangeListResponse::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.ExchangeListResponse.Exchange)
}
inline ::std::string* ExchangeListResponse::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.ExchangeListResponse.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExchangeListResponse::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.ExchangeListResponse.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExchangeListResponse::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.ExchangeListResponse.Exchange)
}

// optional uint32 IsFinalMessage = 3;
inline bool ExchangeListResponse::has_isfinalmessage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExchangeListResponse::set_has_isfinalmessage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExchangeListResponse::clear_has_isfinalmessage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExchangeListResponse::clear_isfinalmessage() {
  isfinalmessage_ = 0u;
  clear_has_isfinalmessage();
}
inline ::google::protobuf::uint32 ExchangeListResponse::isfinalmessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.IsFinalMessage)
  return isfinalmessage_;
}
inline void ExchangeListResponse::set_isfinalmessage(::google::protobuf::uint32 value) {
  set_has_isfinalmessage();
  isfinalmessage_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.IsFinalMessage)
}

// optional string Description = 4;
inline bool ExchangeListResponse::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeListResponse::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeListResponse::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeListResponse::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& ExchangeListResponse::description() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.Description)
  return description_.GetNoArena();
}
inline void ExchangeListResponse::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.Description)
}
#if LANG_CXX11
inline void ExchangeListResponse::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.ExchangeListResponse.Description)
}
#endif
inline void ExchangeListResponse::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.ExchangeListResponse.Description)
}
inline void ExchangeListResponse::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.ExchangeListResponse.Description)
}
inline ::std::string* ExchangeListResponse::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:DTC_PB.ExchangeListResponse.Description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExchangeListResponse::release_description() {
  // @@protoc_insertion_point(field_release:DTC_PB.ExchangeListResponse.Description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExchangeListResponse::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.ExchangeListResponse.Description)
}

// -------------------------------------------------------------------

// SymbolsForExchangeRequest

// optional int32 RequestID = 1;
inline bool SymbolsForExchangeRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolsForExchangeRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolsForExchangeRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SymbolsForExchangeRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.RequestID)
  return requestid_;
}
inline void SymbolsForExchangeRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.RequestID)
}

// optional string Exchange = 2;
inline bool SymbolsForExchangeRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolsForExchangeRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolsForExchangeRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SymbolsForExchangeRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void SymbolsForExchangeRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.Exchange)
}
#if LANG_CXX11
inline void SymbolsForExchangeRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SymbolsForExchangeRequest.Exchange)
}
#endif
inline void SymbolsForExchangeRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolsForExchangeRequest.Exchange)
}
inline void SymbolsForExchangeRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolsForExchangeRequest.Exchange)
}
inline ::std::string* SymbolsForExchangeRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolsForExchangeRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolsForExchangeRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SymbolsForExchangeRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolsForExchangeRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolsForExchangeRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
inline bool SymbolsForExchangeRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolsForExchangeRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolsForExchangeRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SymbolsForExchangeRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SymbolsForExchangeRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.SecurityType)
}

// optional .DTC_PB.RequestActionEnum RequestAction = 4;
inline bool SymbolsForExchangeRequest::has_requestaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_requestaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolsForExchangeRequest::clear_has_requestaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolsForExchangeRequest::clear_requestaction() {
  requestaction_ = 1;
  clear_has_requestaction();
}
inline ::DTC_PB::RequestActionEnum SymbolsForExchangeRequest::requestaction() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.RequestAction)
  return static_cast< ::DTC_PB::RequestActionEnum >(requestaction_);
}
inline void SymbolsForExchangeRequest::set_requestaction(::DTC_PB::RequestActionEnum value) {
  assert(::DTC_PB::RequestActionEnum_IsValid(value));
  set_has_requestaction();
  requestaction_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.RequestAction)
}

// optional string Symbol = 5;
inline bool SymbolsForExchangeRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolsForExchangeRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolsForExchangeRequest::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SymbolsForExchangeRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.Symbol)
  return symbol_.GetNoArena();
}
inline void SymbolsForExchangeRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.Symbol)
}
#if LANG_CXX11
inline void SymbolsForExchangeRequest::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SymbolsForExchangeRequest.Symbol)
}
#endif
inline void SymbolsForExchangeRequest::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolsForExchangeRequest.Symbol)
}
inline void SymbolsForExchangeRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolsForExchangeRequest.Symbol)
}
inline ::std::string* SymbolsForExchangeRequest::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolsForExchangeRequest.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolsForExchangeRequest::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SymbolsForExchangeRequest.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolsForExchangeRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolsForExchangeRequest.Symbol)
}

// -------------------------------------------------------------------

// UnderlyingSymbolsForExchangeRequest

// optional int32 RequestID = 1;
inline bool UnderlyingSymbolsForExchangeRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnderlyingSymbolsForExchangeRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 UnderlyingSymbolsForExchangeRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UnderlyingSymbolsForExchangeRequest.RequestID)
  return requestid_;
}
inline void UnderlyingSymbolsForExchangeRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.UnderlyingSymbolsForExchangeRequest.RequestID)
}

// optional string Exchange = 2;
inline bool UnderlyingSymbolsForExchangeRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnderlyingSymbolsForExchangeRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& UnderlyingSymbolsForExchangeRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void UnderlyingSymbolsForExchangeRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}
#if LANG_CXX11
inline void UnderlyingSymbolsForExchangeRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}
#endif
inline void UnderlyingSymbolsForExchangeRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}
inline void UnderlyingSymbolsForExchangeRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}
inline ::std::string* UnderlyingSymbolsForExchangeRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnderlyingSymbolsForExchangeRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnderlyingSymbolsForExchangeRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
inline bool UnderlyingSymbolsForExchangeRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnderlyingSymbolsForExchangeRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum UnderlyingSymbolsForExchangeRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UnderlyingSymbolsForExchangeRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void UnderlyingSymbolsForExchangeRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.UnderlyingSymbolsForExchangeRequest.SecurityType)
}

// -------------------------------------------------------------------

// SymbolsForUnderlyingRequest

// optional int32 RequestID = 1;
inline bool SymbolsForUnderlyingRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolsForUnderlyingRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolsForUnderlyingRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SymbolsForUnderlyingRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.RequestID)
  return requestid_;
}
inline void SymbolsForUnderlyingRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.RequestID)
}

// optional string UnderlyingSymbol = 2;
inline bool SymbolsForUnderlyingRequest::has_underlyingsymbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_underlyingsymbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolsForUnderlyingRequest::clear_has_underlyingsymbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolsForUnderlyingRequest::clear_underlyingsymbol() {
  underlyingsymbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_underlyingsymbol();
}
inline const ::std::string& SymbolsForUnderlyingRequest::underlyingsymbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
  return underlyingsymbol_.GetNoArena();
}
inline void SymbolsForUnderlyingRequest::set_underlyingsymbol(const ::std::string& value) {
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}
#if LANG_CXX11
inline void SymbolsForUnderlyingRequest::set_underlyingsymbol(::std::string&& value) {
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}
#endif
inline void SymbolsForUnderlyingRequest::set_underlyingsymbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}
inline void SymbolsForUnderlyingRequest::set_underlyingsymbol(const char* value, size_t size) {
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}
inline ::std::string* SymbolsForUnderlyingRequest::mutable_underlyingsymbol() {
  set_has_underlyingsymbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
  return underlyingsymbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolsForUnderlyingRequest::release_underlyingsymbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
  if (!has_underlyingsymbol()) {
    return NULL;
  }
  clear_has_underlyingsymbol();
  return underlyingsymbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolsForUnderlyingRequest::set_allocated_underlyingsymbol(::std::string* underlyingsymbol) {
  if (underlyingsymbol != NULL) {
    set_has_underlyingsymbol();
  } else {
    clear_has_underlyingsymbol();
  }
  underlyingsymbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), underlyingsymbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}

// optional string Exchange = 3;
inline bool SymbolsForUnderlyingRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolsForUnderlyingRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolsForUnderlyingRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SymbolsForUnderlyingRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void SymbolsForUnderlyingRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}
#if LANG_CXX11
inline void SymbolsForUnderlyingRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}
#endif
inline void SymbolsForUnderlyingRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}
inline void SymbolsForUnderlyingRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}
inline ::std::string* SymbolsForUnderlyingRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolsForUnderlyingRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolsForUnderlyingRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
inline bool SymbolsForUnderlyingRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolsForUnderlyingRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolsForUnderlyingRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SymbolsForUnderlyingRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SymbolsForUnderlyingRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.SecurityType)
}

// -------------------------------------------------------------------

// SymbolSearchRequest

// optional int32 RequestID = 1;
inline bool SymbolSearchRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolSearchRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolSearchRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolSearchRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SymbolSearchRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.RequestID)
  return requestid_;
}
inline void SymbolSearchRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.RequestID)
}

// optional string SearchText = 2;
inline bool SymbolSearchRequest::has_searchtext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolSearchRequest::set_has_searchtext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolSearchRequest::clear_has_searchtext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolSearchRequest::clear_searchtext() {
  searchtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_searchtext();
}
inline const ::std::string& SymbolSearchRequest::searchtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.SearchText)
  return searchtext_.GetNoArena();
}
inline void SymbolSearchRequest::set_searchtext(const ::std::string& value) {
  set_has_searchtext();
  searchtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.SearchText)
}
#if LANG_CXX11
inline void SymbolSearchRequest::set_searchtext(::std::string&& value) {
  set_has_searchtext();
  searchtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SymbolSearchRequest.SearchText)
}
#endif
inline void SymbolSearchRequest::set_searchtext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_searchtext();
  searchtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolSearchRequest.SearchText)
}
inline void SymbolSearchRequest::set_searchtext(const char* value, size_t size) {
  set_has_searchtext();
  searchtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolSearchRequest.SearchText)
}
inline ::std::string* SymbolSearchRequest::mutable_searchtext() {
  set_has_searchtext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolSearchRequest.SearchText)
  return searchtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolSearchRequest::release_searchtext() {
  // @@protoc_insertion_point(field_release:DTC_PB.SymbolSearchRequest.SearchText)
  if (!has_searchtext()) {
    return NULL;
  }
  clear_has_searchtext();
  return searchtext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolSearchRequest::set_allocated_searchtext(::std::string* searchtext) {
  if (searchtext != NULL) {
    set_has_searchtext();
  } else {
    clear_has_searchtext();
  }
  searchtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), searchtext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolSearchRequest.SearchText)
}

// optional string Exchange = 3;
inline bool SymbolSearchRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolSearchRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolSearchRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolSearchRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SymbolSearchRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void SymbolSearchRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.Exchange)
}
#if LANG_CXX11
inline void SymbolSearchRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SymbolSearchRequest.Exchange)
}
#endif
inline void SymbolSearchRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolSearchRequest.Exchange)
}
inline void SymbolSearchRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolSearchRequest.Exchange)
}
inline ::std::string* SymbolSearchRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolSearchRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolSearchRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SymbolSearchRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolSearchRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolSearchRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
inline bool SymbolSearchRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolSearchRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolSearchRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolSearchRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SymbolSearchRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SymbolSearchRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.SecurityType)
}

// optional .DTC_PB.SearchTypeEnum SearchType = 5;
inline bool SymbolSearchRequest::has_searchtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolSearchRequest::set_has_searchtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolSearchRequest::clear_has_searchtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolSearchRequest::clear_searchtype() {
  searchtype_ = 0;
  clear_has_searchtype();
}
inline ::DTC_PB::SearchTypeEnum SymbolSearchRequest::searchtype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.SearchType)
  return static_cast< ::DTC_PB::SearchTypeEnum >(searchtype_);
}
inline void SymbolSearchRequest::set_searchtype(::DTC_PB::SearchTypeEnum value) {
  assert(::DTC_PB::SearchTypeEnum_IsValid(value));
  set_has_searchtype();
  searchtype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.SearchType)
}

// -------------------------------------------------------------------

// SecurityDefinitionForSymbolRequest

// optional int32 RequestID = 1;
inline bool SecurityDefinitionForSymbolRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityDefinitionForSymbolRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityDefinitionForSymbolRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityDefinitionForSymbolRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SecurityDefinitionForSymbolRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionForSymbolRequest.RequestID)
  return requestid_;
}
inline void SecurityDefinitionForSymbolRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionForSymbolRequest.RequestID)
}

// optional string Symbol = 2;
inline bool SecurityDefinitionForSymbolRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionForSymbolRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionForSymbolRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionForSymbolRequest::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SecurityDefinitionForSymbolRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
  return symbol_.GetNoArena();
}
inline void SecurityDefinitionForSymbolRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}
#if LANG_CXX11
inline void SecurityDefinitionForSymbolRequest::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}
#endif
inline void SecurityDefinitionForSymbolRequest::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}
inline void SecurityDefinitionForSymbolRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}
inline ::std::string* SecurityDefinitionForSymbolRequest::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionForSymbolRequest::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionForSymbolRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}

// optional string Exchange = 3;
inline bool SecurityDefinitionForSymbolRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinitionForSymbolRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinitionForSymbolRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinitionForSymbolRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SecurityDefinitionForSymbolRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void SecurityDefinitionForSymbolRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}
#if LANG_CXX11
inline void SecurityDefinitionForSymbolRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}
#endif
inline void SecurityDefinitionForSymbolRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}
inline void SecurityDefinitionForSymbolRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}
inline ::std::string* SecurityDefinitionForSymbolRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionForSymbolRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionForSymbolRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}

// -------------------------------------------------------------------

// SecurityDefinitionResponse

// optional int32 RequestID = 1;
inline bool SecurityDefinitionResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityDefinitionResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityDefinitionResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityDefinitionResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SecurityDefinitionResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.RequestID)
  return requestid_;
}
inline void SecurityDefinitionResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.RequestID)
}

// optional string Symbol = 2;
inline bool SecurityDefinitionResponse::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionResponse::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionResponse::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionResponse::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SecurityDefinitionResponse::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.Symbol)
  return symbol_.GetNoArena();
}
inline void SecurityDefinitionResponse::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.Symbol)
}
#if LANG_CXX11
inline void SecurityDefinitionResponse::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionResponse.Symbol)
}
#endif
inline void SecurityDefinitionResponse::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.Symbol)
}
inline void SecurityDefinitionResponse::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.Symbol)
}
inline ::std::string* SecurityDefinitionResponse::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionResponse::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionResponse.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionResponse::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.Symbol)
}

// optional string Exchange = 3;
inline bool SecurityDefinitionResponse::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinitionResponse::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinitionResponse::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinitionResponse::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& SecurityDefinitionResponse::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.Exchange)
  return exchange_.GetNoArena();
}
inline void SecurityDefinitionResponse::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.Exchange)
}
#if LANG_CXX11
inline void SecurityDefinitionResponse::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionResponse.Exchange)
}
#endif
inline void SecurityDefinitionResponse::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.Exchange)
}
inline void SecurityDefinitionResponse::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.Exchange)
}
inline ::std::string* SecurityDefinitionResponse::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionResponse::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionResponse.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionResponse::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
inline bool SecurityDefinitionResponse::has_securitytype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityDefinitionResponse::set_has_securitytype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityDefinitionResponse::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityDefinitionResponse::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SecurityDefinitionResponse::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SecurityDefinitionResponse::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SecurityType)
}

// optional string Description = 5;
inline bool SecurityDefinitionResponse::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityDefinitionResponse::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityDefinitionResponse::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityDefinitionResponse::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& SecurityDefinitionResponse::description() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.Description)
  return description_.GetNoArena();
}
inline void SecurityDefinitionResponse::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.Description)
}
#if LANG_CXX11
inline void SecurityDefinitionResponse::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionResponse.Description)
}
#endif
inline void SecurityDefinitionResponse::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.Description)
}
inline void SecurityDefinitionResponse::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.Description)
}
inline ::std::string* SecurityDefinitionResponse::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.Description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionResponse::release_description() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionResponse.Description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionResponse::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.Description)
}

// optional float MinPriceIncrement = 6;
inline bool SecurityDefinitionResponse::has_minpriceincrement() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityDefinitionResponse::set_has_minpriceincrement() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityDefinitionResponse::clear_has_minpriceincrement() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityDefinitionResponse::clear_minpriceincrement() {
  minpriceincrement_ = 0;
  clear_has_minpriceincrement();
}
inline float SecurityDefinitionResponse::minpriceincrement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.MinPriceIncrement)
  return minpriceincrement_;
}
inline void SecurityDefinitionResponse::set_minpriceincrement(float value) {
  set_has_minpriceincrement();
  minpriceincrement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.MinPriceIncrement)
}

// optional .DTC_PB.PriceDisplayFormatEnum PriceDisplayFormat = 7;
inline bool SecurityDefinitionResponse::has_pricedisplayformat() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_pricedisplayformat() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SecurityDefinitionResponse::clear_has_pricedisplayformat() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SecurityDefinitionResponse::clear_pricedisplayformat() {
  pricedisplayformat_ = -1;
  clear_has_pricedisplayformat();
}
inline ::DTC_PB::PriceDisplayFormatEnum SecurityDefinitionResponse::pricedisplayformat() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.PriceDisplayFormat)
  return static_cast< ::DTC_PB::PriceDisplayFormatEnum >(pricedisplayformat_);
}
inline void SecurityDefinitionResponse::set_pricedisplayformat(::DTC_PB::PriceDisplayFormatEnum value) {
  assert(::DTC_PB::PriceDisplayFormatEnum_IsValid(value));
  set_has_pricedisplayformat();
  pricedisplayformat_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.PriceDisplayFormat)
}

// optional float CurrencyValuePerIncrement = 8;
inline bool SecurityDefinitionResponse::has_currencyvalueperincrement() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityDefinitionResponse::set_has_currencyvalueperincrement() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityDefinitionResponse::clear_has_currencyvalueperincrement() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityDefinitionResponse::clear_currencyvalueperincrement() {
  currencyvalueperincrement_ = 0;
  clear_has_currencyvalueperincrement();
}
inline float SecurityDefinitionResponse::currencyvalueperincrement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.CurrencyValuePerIncrement)
  return currencyvalueperincrement_;
}
inline void SecurityDefinitionResponse::set_currencyvalueperincrement(float value) {
  set_has_currencyvalueperincrement();
  currencyvalueperincrement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.CurrencyValuePerIncrement)
}

// optional uint32 IsFinalMessage = 9;
inline bool SecurityDefinitionResponse::has_isfinalmessage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityDefinitionResponse::set_has_isfinalmessage() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityDefinitionResponse::clear_has_isfinalmessage() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityDefinitionResponse::clear_isfinalmessage() {
  isfinalmessage_ = 0u;
  clear_has_isfinalmessage();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::isfinalmessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.IsFinalMessage)
  return isfinalmessage_;
}
inline void SecurityDefinitionResponse::set_isfinalmessage(::google::protobuf::uint32 value) {
  set_has_isfinalmessage();
  isfinalmessage_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.IsFinalMessage)
}

// optional float FloatToIntPriceMultiplier = 10;
inline bool SecurityDefinitionResponse::has_floattointpricemultiplier() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecurityDefinitionResponse::set_has_floattointpricemultiplier() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecurityDefinitionResponse::clear_has_floattointpricemultiplier() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecurityDefinitionResponse::clear_floattointpricemultiplier() {
  floattointpricemultiplier_ = 0;
  clear_has_floattointpricemultiplier();
}
inline float SecurityDefinitionResponse::floattointpricemultiplier() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.FloatToIntPriceMultiplier)
  return floattointpricemultiplier_;
}
inline void SecurityDefinitionResponse::set_floattointpricemultiplier(float value) {
  set_has_floattointpricemultiplier();
  floattointpricemultiplier_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.FloatToIntPriceMultiplier)
}

// optional float IntToFloatPriceDivisor = 11;
inline bool SecurityDefinitionResponse::has_inttofloatpricedivisor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_inttofloatpricedivisor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityDefinitionResponse::clear_has_inttofloatpricedivisor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityDefinitionResponse::clear_inttofloatpricedivisor() {
  inttofloatpricedivisor_ = 0;
  clear_has_inttofloatpricedivisor();
}
inline float SecurityDefinitionResponse::inttofloatpricedivisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.IntToFloatPriceDivisor)
  return inttofloatpricedivisor_;
}
inline void SecurityDefinitionResponse::set_inttofloatpricedivisor(float value) {
  set_has_inttofloatpricedivisor();
  inttofloatpricedivisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.IntToFloatPriceDivisor)
}

// optional string UnderlyingSymbol = 12;
inline bool SecurityDefinitionResponse::has_underlyingsymbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityDefinitionResponse::set_has_underlyingsymbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityDefinitionResponse::clear_has_underlyingsymbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityDefinitionResponse::clear_underlyingsymbol() {
  underlyingsymbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_underlyingsymbol();
}
inline const ::std::string& SecurityDefinitionResponse::underlyingsymbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
  return underlyingsymbol_.GetNoArena();
}
inline void SecurityDefinitionResponse::set_underlyingsymbol(const ::std::string& value) {
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}
#if LANG_CXX11
inline void SecurityDefinitionResponse::set_underlyingsymbol(::std::string&& value) {
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}
#endif
inline void SecurityDefinitionResponse::set_underlyingsymbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}
inline void SecurityDefinitionResponse::set_underlyingsymbol(const char* value, size_t size) {
  set_has_underlyingsymbol();
  underlyingsymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}
inline ::std::string* SecurityDefinitionResponse::mutable_underlyingsymbol() {
  set_has_underlyingsymbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
  return underlyingsymbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionResponse::release_underlyingsymbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
  if (!has_underlyingsymbol()) {
    return NULL;
  }
  clear_has_underlyingsymbol();
  return underlyingsymbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionResponse::set_allocated_underlyingsymbol(::std::string* underlyingsymbol) {
  if (underlyingsymbol != NULL) {
    set_has_underlyingsymbol();
  } else {
    clear_has_underlyingsymbol();
  }
  underlyingsymbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), underlyingsymbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}

// optional uint32 UpdatesBidAskOnly = 13;
inline bool SecurityDefinitionResponse::has_updatesbidaskonly() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_updatesbidaskonly() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SecurityDefinitionResponse::clear_has_updatesbidaskonly() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SecurityDefinitionResponse::clear_updatesbidaskonly() {
  updatesbidaskonly_ = 0u;
  clear_has_updatesbidaskonly();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::updatesbidaskonly() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.UpdatesBidAskOnly)
  return updatesbidaskonly_;
}
inline void SecurityDefinitionResponse::set_updatesbidaskonly(::google::protobuf::uint32 value) {
  set_has_updatesbidaskonly();
  updatesbidaskonly_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.UpdatesBidAskOnly)
}

// optional float StrikePrice = 14;
inline bool SecurityDefinitionResponse::has_strikeprice() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_strikeprice() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecurityDefinitionResponse::clear_has_strikeprice() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecurityDefinitionResponse::clear_strikeprice() {
  strikeprice_ = 0;
  clear_has_strikeprice();
}
inline float SecurityDefinitionResponse::strikeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.StrikePrice)
  return strikeprice_;
}
inline void SecurityDefinitionResponse::set_strikeprice(float value) {
  set_has_strikeprice();
  strikeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.StrikePrice)
}

// optional .DTC_PB.PutCallEnum PutOrCall = 15;
inline bool SecurityDefinitionResponse::has_putorcall() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_putorcall() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SecurityDefinitionResponse::clear_has_putorcall() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SecurityDefinitionResponse::clear_putorcall() {
  putorcall_ = 0;
  clear_has_putorcall();
}
inline ::DTC_PB::PutCallEnum SecurityDefinitionResponse::putorcall() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.PutOrCall)
  return static_cast< ::DTC_PB::PutCallEnum >(putorcall_);
}
inline void SecurityDefinitionResponse::set_putorcall(::DTC_PB::PutCallEnum value) {
  assert(::DTC_PB::PutCallEnum_IsValid(value));
  set_has_putorcall();
  putorcall_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.PutOrCall)
}

// optional uint32 ShortInterest = 16;
inline bool SecurityDefinitionResponse::has_shortinterest() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_shortinterest() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SecurityDefinitionResponse::clear_has_shortinterest() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SecurityDefinitionResponse::clear_shortinterest() {
  shortinterest_ = 0u;
  clear_has_shortinterest();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::shortinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.ShortInterest)
  return shortinterest_;
}
inline void SecurityDefinitionResponse::set_shortinterest(::google::protobuf::uint32 value) {
  set_has_shortinterest();
  shortinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.ShortInterest)
}

// optional sfixed32 SecurityExpirationDate = 17;
inline bool SecurityDefinitionResponse::has_securityexpirationdate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_securityexpirationdate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SecurityDefinitionResponse::clear_has_securityexpirationdate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SecurityDefinitionResponse::clear_securityexpirationdate() {
  securityexpirationdate_ = 0;
  clear_has_securityexpirationdate();
}
inline ::google::protobuf::int32 SecurityDefinitionResponse::securityexpirationdate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SecurityExpirationDate)
  return securityexpirationdate_;
}
inline void SecurityDefinitionResponse::set_securityexpirationdate(::google::protobuf::int32 value) {
  set_has_securityexpirationdate();
  securityexpirationdate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SecurityExpirationDate)
}

// optional float BuyRolloverInterest = 18;
inline bool SecurityDefinitionResponse::has_buyrolloverinterest() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_buyrolloverinterest() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityDefinitionResponse::clear_has_buyrolloverinterest() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityDefinitionResponse::clear_buyrolloverinterest() {
  buyrolloverinterest_ = 0;
  clear_has_buyrolloverinterest();
}
inline float SecurityDefinitionResponse::buyrolloverinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.BuyRolloverInterest)
  return buyrolloverinterest_;
}
inline void SecurityDefinitionResponse::set_buyrolloverinterest(float value) {
  set_has_buyrolloverinterest();
  buyrolloverinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.BuyRolloverInterest)
}

// optional float SellRolloverInterest = 19;
inline bool SecurityDefinitionResponse::has_sellrolloverinterest() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_sellrolloverinterest() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SecurityDefinitionResponse::clear_has_sellrolloverinterest() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SecurityDefinitionResponse::clear_sellrolloverinterest() {
  sellrolloverinterest_ = 0;
  clear_has_sellrolloverinterest();
}
inline float SecurityDefinitionResponse::sellrolloverinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SellRolloverInterest)
  return sellrolloverinterest_;
}
inline void SecurityDefinitionResponse::set_sellrolloverinterest(float value) {
  set_has_sellrolloverinterest();
  sellrolloverinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SellRolloverInterest)
}

// optional float EarningsPerShare = 20;
inline bool SecurityDefinitionResponse::has_earningspershare() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_earningspershare() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SecurityDefinitionResponse::clear_has_earningspershare() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SecurityDefinitionResponse::clear_earningspershare() {
  earningspershare_ = 0;
  clear_has_earningspershare();
}
inline float SecurityDefinitionResponse::earningspershare() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.EarningsPerShare)
  return earningspershare_;
}
inline void SecurityDefinitionResponse::set_earningspershare(float value) {
  set_has_earningspershare();
  earningspershare_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.EarningsPerShare)
}

// optional uint32 SharesOutstanding = 21;
inline bool SecurityDefinitionResponse::has_sharesoutstanding() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_sharesoutstanding() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SecurityDefinitionResponse::clear_has_sharesoutstanding() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SecurityDefinitionResponse::clear_sharesoutstanding() {
  sharesoutstanding_ = 0u;
  clear_has_sharesoutstanding();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::sharesoutstanding() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SharesOutstanding)
  return sharesoutstanding_;
}
inline void SecurityDefinitionResponse::set_sharesoutstanding(::google::protobuf::uint32 value) {
  set_has_sharesoutstanding();
  sharesoutstanding_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SharesOutstanding)
}

// optional float IntToFloatQuantityDivisor = 22;
inline bool SecurityDefinitionResponse::has_inttofloatquantitydivisor() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_inttofloatquantitydivisor() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SecurityDefinitionResponse::clear_has_inttofloatquantitydivisor() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SecurityDefinitionResponse::clear_inttofloatquantitydivisor() {
  inttofloatquantitydivisor_ = 0;
  clear_has_inttofloatquantitydivisor();
}
inline float SecurityDefinitionResponse::inttofloatquantitydivisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.IntToFloatQuantityDivisor)
  return inttofloatquantitydivisor_;
}
inline void SecurityDefinitionResponse::set_inttofloatquantitydivisor(float value) {
  set_has_inttofloatquantitydivisor();
  inttofloatquantitydivisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.IntToFloatQuantityDivisor)
}

// optional uint32 HasMarketDepthData = 23;
inline bool SecurityDefinitionResponse::has_hasmarketdepthdata() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_hasmarketdepthdata() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SecurityDefinitionResponse::clear_has_hasmarketdepthdata() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SecurityDefinitionResponse::clear_hasmarketdepthdata() {
  hasmarketdepthdata_ = 0u;
  clear_has_hasmarketdepthdata();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::hasmarketdepthdata() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.HasMarketDepthData)
  return hasmarketdepthdata_;
}
inline void SecurityDefinitionResponse::set_hasmarketdepthdata(::google::protobuf::uint32 value) {
  set_has_hasmarketdepthdata();
  hasmarketdepthdata_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.HasMarketDepthData)
}

// optional float DisplayPriceMultiplier = 24;
inline bool SecurityDefinitionResponse::has_displaypricemultiplier() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_displaypricemultiplier() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SecurityDefinitionResponse::clear_has_displaypricemultiplier() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SecurityDefinitionResponse::clear_displaypricemultiplier() {
  displaypricemultiplier_ = 0;
  clear_has_displaypricemultiplier();
}
inline float SecurityDefinitionResponse::displaypricemultiplier() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.DisplayPriceMultiplier)
  return displaypricemultiplier_;
}
inline void SecurityDefinitionResponse::set_displaypricemultiplier(float value) {
  set_has_displaypricemultiplier();
  displaypricemultiplier_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.DisplayPriceMultiplier)
}

// optional string ExchangeSymbol = 25;
inline bool SecurityDefinitionResponse::has_exchangesymbol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityDefinitionResponse::set_has_exchangesymbol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityDefinitionResponse::clear_has_exchangesymbol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityDefinitionResponse::clear_exchangesymbol() {
  exchangesymbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchangesymbol();
}
inline const ::std::string& SecurityDefinitionResponse::exchangesymbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
  return exchangesymbol_.GetNoArena();
}
inline void SecurityDefinitionResponse::set_exchangesymbol(const ::std::string& value) {
  set_has_exchangesymbol();
  exchangesymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
}
#if LANG_CXX11
inline void SecurityDefinitionResponse::set_exchangesymbol(::std::string&& value) {
  set_has_exchangesymbol();
  exchangesymbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
}
#endif
inline void SecurityDefinitionResponse::set_exchangesymbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchangesymbol();
  exchangesymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
}
inline void SecurityDefinitionResponse::set_exchangesymbol(const char* value, size_t size) {
  set_has_exchangesymbol();
  exchangesymbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
}
inline ::std::string* SecurityDefinitionResponse::mutable_exchangesymbol() {
  set_has_exchangesymbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
  return exchangesymbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionResponse::release_exchangesymbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
  if (!has_exchangesymbol()) {
    return NULL;
  }
  clear_has_exchangesymbol();
  return exchangesymbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionResponse::set_allocated_exchangesymbol(::std::string* exchangesymbol) {
  if (exchangesymbol != NULL) {
    set_has_exchangesymbol();
  } else {
    clear_has_exchangesymbol();
  }
  exchangesymbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchangesymbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.ExchangeSymbol)
}

// optional float InitialMarginRequirement = 26;
inline bool SecurityDefinitionResponse::has_initialmarginrequirement() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_initialmarginrequirement() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SecurityDefinitionResponse::clear_has_initialmarginrequirement() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SecurityDefinitionResponse::clear_initialmarginrequirement() {
  initialmarginrequirement_ = 0;
  clear_has_initialmarginrequirement();
}
inline float SecurityDefinitionResponse::initialmarginrequirement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.InitialMarginRequirement)
  return initialmarginrequirement_;
}
inline void SecurityDefinitionResponse::set_initialmarginrequirement(float value) {
  set_has_initialmarginrequirement();
  initialmarginrequirement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.InitialMarginRequirement)
}

// optional float MaintenanceMarginRequirement = 27;
inline bool SecurityDefinitionResponse::has_maintenancemarginrequirement() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_maintenancemarginrequirement() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SecurityDefinitionResponse::clear_has_maintenancemarginrequirement() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SecurityDefinitionResponse::clear_maintenancemarginrequirement() {
  maintenancemarginrequirement_ = 0;
  clear_has_maintenancemarginrequirement();
}
inline float SecurityDefinitionResponse::maintenancemarginrequirement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.MaintenanceMarginRequirement)
  return maintenancemarginrequirement_;
}
inline void SecurityDefinitionResponse::set_maintenancemarginrequirement(float value) {
  set_has_maintenancemarginrequirement();
  maintenancemarginrequirement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.MaintenanceMarginRequirement)
}

// optional string Currency = 28;
inline bool SecurityDefinitionResponse::has_currency() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityDefinitionResponse::set_has_currency() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityDefinitionResponse::clear_has_currency() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityDefinitionResponse::clear_currency() {
  currency_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_currency();
}
inline const ::std::string& SecurityDefinitionResponse::currency() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.Currency)
  return currency_.GetNoArena();
}
inline void SecurityDefinitionResponse::set_currency(const ::std::string& value) {
  set_has_currency();
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.Currency)
}
#if LANG_CXX11
inline void SecurityDefinitionResponse::set_currency(::std::string&& value) {
  set_has_currency();
  currency_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionResponse.Currency)
}
#endif
inline void SecurityDefinitionResponse::set_currency(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_currency();
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.Currency)
}
inline void SecurityDefinitionResponse::set_currency(const char* value, size_t size) {
  set_has_currency();
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.Currency)
}
inline ::std::string* SecurityDefinitionResponse::mutable_currency() {
  set_has_currency();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.Currency)
  return currency_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionResponse::release_currency() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionResponse.Currency)
  if (!has_currency()) {
    return NULL;
  }
  clear_has_currency();
  return currency_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionResponse::set_allocated_currency(::std::string* currency) {
  if (currency != NULL) {
    set_has_currency();
  } else {
    clear_has_currency();
  }
  currency_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currency);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.Currency)
}

// -------------------------------------------------------------------

// SecurityDefinitionReject

// optional int32 RequestID = 1;
inline bool SecurityDefinitionReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinitionReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinitionReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinitionReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SecurityDefinitionReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionReject.RequestID)
  return requestid_;
}
inline void SecurityDefinitionReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionReject.RequestID)
}

// optional string RejectText = 2;
inline bool SecurityDefinitionReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& SecurityDefinitionReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void SecurityDefinitionReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionReject.RejectText)
}
#if LANG_CXX11
inline void SecurityDefinitionReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.SecurityDefinitionReject.RejectText)
}
#endif
inline void SecurityDefinitionReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionReject.RejectText)
}
inline void SecurityDefinitionReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionReject.RejectText)
}
inline ::std::string* SecurityDefinitionReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecurityDefinitionReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.SecurityDefinitionReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityDefinitionReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionReject.RejectText)
}

// -------------------------------------------------------------------

// AccountBalanceRequest

// optional int32 RequestID = 1;
inline bool AccountBalanceRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountBalanceRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountBalanceRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountBalanceRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AccountBalanceRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceRequest.RequestID)
  return requestid_;
}
inline void AccountBalanceRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceRequest.RequestID)
}

// optional string TradeAccount = 2;
inline bool AccountBalanceRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBalanceRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBalanceRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBalanceRequest::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& AccountBalanceRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceRequest.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void AccountBalanceRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceRequest.TradeAccount)
}
#if LANG_CXX11
inline void AccountBalanceRequest::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.AccountBalanceRequest.TradeAccount)
}
#endif
inline void AccountBalanceRequest::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceRequest.TradeAccount)
}
inline void AccountBalanceRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceRequest.TradeAccount)
}
inline ::std::string* AccountBalanceRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceRequest.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountBalanceRequest::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.AccountBalanceRequest.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountBalanceRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceRequest.TradeAccount)
}

// -------------------------------------------------------------------

// AccountBalanceReject

// optional int32 RequestID = 1;
inline bool AccountBalanceReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountBalanceReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountBalanceReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountBalanceReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AccountBalanceReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceReject.RequestID)
  return requestid_;
}
inline void AccountBalanceReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceReject.RequestID)
}

// optional string RejectText = 2;
inline bool AccountBalanceReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBalanceReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBalanceReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBalanceReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& AccountBalanceReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void AccountBalanceReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceReject.RejectText)
}
#if LANG_CXX11
inline void AccountBalanceReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.AccountBalanceReject.RejectText)
}
#endif
inline void AccountBalanceReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceReject.RejectText)
}
inline void AccountBalanceReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceReject.RejectText)
}
inline ::std::string* AccountBalanceReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountBalanceReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.AccountBalanceReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountBalanceReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceReject.RejectText)
}

// -------------------------------------------------------------------

// AccountBalanceUpdate

// optional int32 RequestID = 1;
inline bool AccountBalanceUpdate::has_requestid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountBalanceUpdate::set_has_requestid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountBalanceUpdate::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountBalanceUpdate::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AccountBalanceUpdate::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.RequestID)
  return requestid_;
}
inline void AccountBalanceUpdate::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.RequestID)
}

// optional double CashBalance = 2;
inline bool AccountBalanceUpdate::has_cashbalance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountBalanceUpdate::set_has_cashbalance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountBalanceUpdate::clear_has_cashbalance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountBalanceUpdate::clear_cashbalance() {
  cashbalance_ = 0;
  clear_has_cashbalance();
}
inline double AccountBalanceUpdate::cashbalance() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.CashBalance)
  return cashbalance_;
}
inline void AccountBalanceUpdate::set_cashbalance(double value) {
  set_has_cashbalance();
  cashbalance_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.CashBalance)
}

// optional double BalanceAvailableForNewPositions = 3;
inline bool AccountBalanceUpdate::has_balanceavailablefornewpositions() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountBalanceUpdate::set_has_balanceavailablefornewpositions() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountBalanceUpdate::clear_has_balanceavailablefornewpositions() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountBalanceUpdate::clear_balanceavailablefornewpositions() {
  balanceavailablefornewpositions_ = 0;
  clear_has_balanceavailablefornewpositions();
}
inline double AccountBalanceUpdate::balanceavailablefornewpositions() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.BalanceAvailableForNewPositions)
  return balanceavailablefornewpositions_;
}
inline void AccountBalanceUpdate::set_balanceavailablefornewpositions(double value) {
  set_has_balanceavailablefornewpositions();
  balanceavailablefornewpositions_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.BalanceAvailableForNewPositions)
}

// optional string AccountCurrency = 4;
inline bool AccountBalanceUpdate::has_accountcurrency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBalanceUpdate::set_has_accountcurrency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBalanceUpdate::clear_has_accountcurrency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBalanceUpdate::clear_accountcurrency() {
  accountcurrency_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_accountcurrency();
}
inline const ::std::string& AccountBalanceUpdate::accountcurrency() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.AccountCurrency)
  return accountcurrency_.GetNoArena();
}
inline void AccountBalanceUpdate::set_accountcurrency(const ::std::string& value) {
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}
#if LANG_CXX11
inline void AccountBalanceUpdate::set_accountcurrency(::std::string&& value) {
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}
#endif
inline void AccountBalanceUpdate::set_accountcurrency(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}
inline void AccountBalanceUpdate::set_accountcurrency(const char* value, size_t size) {
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}
inline ::std::string* AccountBalanceUpdate::mutable_accountcurrency() {
  set_has_accountcurrency();
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceUpdate.AccountCurrency)
  return accountcurrency_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountBalanceUpdate::release_accountcurrency() {
  // @@protoc_insertion_point(field_release:DTC_PB.AccountBalanceUpdate.AccountCurrency)
  if (!has_accountcurrency()) {
    return NULL;
  }
  clear_has_accountcurrency();
  return accountcurrency_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountBalanceUpdate::set_allocated_accountcurrency(::std::string* accountcurrency) {
  if (accountcurrency != NULL) {
    set_has_accountcurrency();
  } else {
    clear_has_accountcurrency();
  }
  accountcurrency_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accountcurrency);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}

// optional string TradeAccount = 5;
inline bool AccountBalanceUpdate::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountBalanceUpdate::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountBalanceUpdate::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountBalanceUpdate::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& AccountBalanceUpdate::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void AccountBalanceUpdate::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.TradeAccount)
}
#if LANG_CXX11
inline void AccountBalanceUpdate::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.AccountBalanceUpdate.TradeAccount)
}
#endif
inline void AccountBalanceUpdate::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceUpdate.TradeAccount)
}
inline void AccountBalanceUpdate::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceUpdate.TradeAccount)
}
inline ::std::string* AccountBalanceUpdate::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceUpdate.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountBalanceUpdate::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.AccountBalanceUpdate.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountBalanceUpdate::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceUpdate.TradeAccount)
}

// optional double SecuritiesValue = 6;
inline bool AccountBalanceUpdate::has_securitiesvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountBalanceUpdate::set_has_securitiesvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountBalanceUpdate::clear_has_securitiesvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountBalanceUpdate::clear_securitiesvalue() {
  securitiesvalue_ = 0;
  clear_has_securitiesvalue();
}
inline double AccountBalanceUpdate::securitiesvalue() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.SecuritiesValue)
  return securitiesvalue_;
}
inline void AccountBalanceUpdate::set_securitiesvalue(double value) {
  set_has_securitiesvalue();
  securitiesvalue_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.SecuritiesValue)
}

// optional double MarginRequirement = 7;
inline bool AccountBalanceUpdate::has_marginrequirement() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountBalanceUpdate::set_has_marginrequirement() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountBalanceUpdate::clear_has_marginrequirement() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountBalanceUpdate::clear_marginrequirement() {
  marginrequirement_ = 0;
  clear_has_marginrequirement();
}
inline double AccountBalanceUpdate::marginrequirement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.MarginRequirement)
  return marginrequirement_;
}
inline void AccountBalanceUpdate::set_marginrequirement(double value) {
  set_has_marginrequirement();
  marginrequirement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.MarginRequirement)
}

// optional int32 TotalNumberMessages = 8;
inline bool AccountBalanceUpdate::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountBalanceUpdate::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountBalanceUpdate::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountBalanceUpdate::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 AccountBalanceUpdate::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void AccountBalanceUpdate::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.TotalNumberMessages)
}

// optional int32 MessageNumber = 9;
inline bool AccountBalanceUpdate::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountBalanceUpdate::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountBalanceUpdate::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountBalanceUpdate::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 AccountBalanceUpdate::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.MessageNumber)
  return messagenumber_;
}
inline void AccountBalanceUpdate::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.MessageNumber)
}

// optional uint32 NoAccountBalances = 10;
inline bool AccountBalanceUpdate::has_noaccountbalances() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AccountBalanceUpdate::set_has_noaccountbalances() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AccountBalanceUpdate::clear_has_noaccountbalances() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AccountBalanceUpdate::clear_noaccountbalances() {
  noaccountbalances_ = 0u;
  clear_has_noaccountbalances();
}
inline ::google::protobuf::uint32 AccountBalanceUpdate::noaccountbalances() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.NoAccountBalances)
  return noaccountbalances_;
}
inline void AccountBalanceUpdate::set_noaccountbalances(::google::protobuf::uint32 value) {
  set_has_noaccountbalances();
  noaccountbalances_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.NoAccountBalances)
}

// optional uint32 Unsolicited = 11;
inline bool AccountBalanceUpdate::has_unsolicited() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AccountBalanceUpdate::set_has_unsolicited() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AccountBalanceUpdate::clear_has_unsolicited() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AccountBalanceUpdate::clear_unsolicited() {
  unsolicited_ = 0u;
  clear_has_unsolicited();
}
inline ::google::protobuf::uint32 AccountBalanceUpdate::unsolicited() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.Unsolicited)
  return unsolicited_;
}
inline void AccountBalanceUpdate::set_unsolicited(::google::protobuf::uint32 value) {
  set_has_unsolicited();
  unsolicited_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.Unsolicited)
}

// optional double OpenPositionsProfitLoss = 12;
inline bool AccountBalanceUpdate::has_openpositionsprofitloss() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AccountBalanceUpdate::set_has_openpositionsprofitloss() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AccountBalanceUpdate::clear_has_openpositionsprofitloss() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AccountBalanceUpdate::clear_openpositionsprofitloss() {
  openpositionsprofitloss_ = 0;
  clear_has_openpositionsprofitloss();
}
inline double AccountBalanceUpdate::openpositionsprofitloss() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.OpenPositionsProfitLoss)
  return openpositionsprofitloss_;
}
inline void AccountBalanceUpdate::set_openpositionsprofitloss(double value) {
  set_has_openpositionsprofitloss();
  openpositionsprofitloss_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.OpenPositionsProfitLoss)
}

// optional double DailyProfitLoss = 13;
inline bool AccountBalanceUpdate::has_dailyprofitloss() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AccountBalanceUpdate::set_has_dailyprofitloss() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AccountBalanceUpdate::clear_has_dailyprofitloss() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AccountBalanceUpdate::clear_dailyprofitloss() {
  dailyprofitloss_ = 0;
  clear_has_dailyprofitloss();
}
inline double AccountBalanceUpdate::dailyprofitloss() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.DailyProfitLoss)
  return dailyprofitloss_;
}
inline void AccountBalanceUpdate::set_dailyprofitloss(double value) {
  set_has_dailyprofitloss();
  dailyprofitloss_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.DailyProfitLoss)
}

// optional string InfoText = 14;
inline bool AccountBalanceUpdate::has_infotext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountBalanceUpdate::set_has_infotext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountBalanceUpdate::clear_has_infotext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountBalanceUpdate::clear_infotext() {
  infotext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infotext();
}
inline const ::std::string& AccountBalanceUpdate::infotext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.InfoText)
  return infotext_.GetNoArena();
}
inline void AccountBalanceUpdate::set_infotext(const ::std::string& value) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.InfoText)
}
#if LANG_CXX11
inline void AccountBalanceUpdate::set_infotext(::std::string&& value) {
  set_has_infotext();
  infotext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.AccountBalanceUpdate.InfoText)
}
#endif
inline void AccountBalanceUpdate::set_infotext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceUpdate.InfoText)
}
inline void AccountBalanceUpdate::set_infotext(const char* value, size_t size) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceUpdate.InfoText)
}
inline ::std::string* AccountBalanceUpdate::mutable_infotext() {
  set_has_infotext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceUpdate.InfoText)
  return infotext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountBalanceUpdate::release_infotext() {
  // @@protoc_insertion_point(field_release:DTC_PB.AccountBalanceUpdate.InfoText)
  if (!has_infotext()) {
    return NULL;
  }
  clear_has_infotext();
  return infotext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountBalanceUpdate::set_allocated_infotext(::std::string* infotext) {
  if (infotext != NULL) {
    set_has_infotext();
  } else {
    clear_has_infotext();
  }
  infotext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infotext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceUpdate.InfoText)
}

// -------------------------------------------------------------------

// HistoricalAccountBalancesRequest

// optional int32 RequestID = 1;
inline bool HistoricalAccountBalancesRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalAccountBalancesRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalAccountBalancesRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalAccountBalancesRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalAccountBalancesRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalancesRequest.RequestID)
  return requestid_;
}
inline void HistoricalAccountBalancesRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalancesRequest.RequestID)
}

// optional string TradeAccount = 2;
inline bool HistoricalAccountBalancesRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalAccountBalancesRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalAccountBalancesRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalAccountBalancesRequest::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& HistoricalAccountBalancesRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void HistoricalAccountBalancesRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
}
#if LANG_CXX11
inline void HistoricalAccountBalancesRequest::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
}
#endif
inline void HistoricalAccountBalancesRequest::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
}
inline void HistoricalAccountBalancesRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
}
inline ::std::string* HistoricalAccountBalancesRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalAccountBalancesRequest::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalAccountBalancesRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalAccountBalancesRequest.TradeAccount)
}

// optional sfixed64 StartDateTime = 3;
inline bool HistoricalAccountBalancesRequest::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalAccountBalancesRequest::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalAccountBalancesRequest::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalAccountBalancesRequest::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 HistoricalAccountBalancesRequest::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalancesRequest.StartDateTime)
  return startdatetime_;
}
inline void HistoricalAccountBalancesRequest::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalancesRequest.StartDateTime)
}

// -------------------------------------------------------------------

// HistoricalAccountBalancesReject

// optional int32 RequestID = 1;
inline bool HistoricalAccountBalancesReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalAccountBalancesReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalAccountBalancesReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalAccountBalancesReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalAccountBalancesReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalancesReject.RequestID)
  return requestid_;
}
inline void HistoricalAccountBalancesReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalancesReject.RequestID)
}

// optional string RejectText = 2;
inline bool HistoricalAccountBalancesReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalAccountBalancesReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalAccountBalancesReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalAccountBalancesReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& HistoricalAccountBalancesReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalancesReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void HistoricalAccountBalancesReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalancesReject.RejectText)
}
#if LANG_CXX11
inline void HistoricalAccountBalancesReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalAccountBalancesReject.RejectText)
}
#endif
inline void HistoricalAccountBalancesReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalAccountBalancesReject.RejectText)
}
inline void HistoricalAccountBalancesReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalAccountBalancesReject.RejectText)
}
inline ::std::string* HistoricalAccountBalancesReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalAccountBalancesReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalAccountBalancesReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalAccountBalancesReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalAccountBalancesReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalAccountBalancesReject.RejectText)
}

// -------------------------------------------------------------------

// HistoricalAccountBalanceResponse

// optional int32 RequestID = 1;
inline bool HistoricalAccountBalanceResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalAccountBalanceResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalAccountBalanceResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalAccountBalanceResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.RequestID)
  return requestid_;
}
inline void HistoricalAccountBalanceResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.RequestID)
}

// optional double DateTime = 2;
inline bool HistoricalAccountBalanceResponse::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalAccountBalanceResponse::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalAccountBalanceResponse::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double HistoricalAccountBalanceResponse::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.DateTime)
  return datetime_;
}
inline void HistoricalAccountBalanceResponse::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.DateTime)
}

// optional double CashBalance = 3;
inline bool HistoricalAccountBalanceResponse::has_cashbalance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_cashbalance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalAccountBalanceResponse::clear_has_cashbalance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalAccountBalanceResponse::clear_cashbalance() {
  cashbalance_ = 0;
  clear_has_cashbalance();
}
inline double HistoricalAccountBalanceResponse::cashbalance() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.CashBalance)
  return cashbalance_;
}
inline void HistoricalAccountBalanceResponse::set_cashbalance(double value) {
  set_has_cashbalance();
  cashbalance_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.CashBalance)
}

// optional string AccountCurrency = 4;
inline bool HistoricalAccountBalanceResponse::has_accountcurrency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_accountcurrency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalAccountBalanceResponse::clear_has_accountcurrency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalAccountBalanceResponse::clear_accountcurrency() {
  accountcurrency_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_accountcurrency();
}
inline const ::std::string& HistoricalAccountBalanceResponse::accountcurrency() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
  return accountcurrency_.GetNoArena();
}
inline void HistoricalAccountBalanceResponse::set_accountcurrency(const ::std::string& value) {
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
}
#if LANG_CXX11
inline void HistoricalAccountBalanceResponse::set_accountcurrency(::std::string&& value) {
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
}
#endif
inline void HistoricalAccountBalanceResponse::set_accountcurrency(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
}
inline void HistoricalAccountBalanceResponse::set_accountcurrency(const char* value, size_t size) {
  set_has_accountcurrency();
  accountcurrency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
}
inline ::std::string* HistoricalAccountBalanceResponse::mutable_accountcurrency() {
  set_has_accountcurrency();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
  return accountcurrency_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalAccountBalanceResponse::release_accountcurrency() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
  if (!has_accountcurrency()) {
    return NULL;
  }
  clear_has_accountcurrency();
  return accountcurrency_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalAccountBalanceResponse::set_allocated_accountcurrency(::std::string* accountcurrency) {
  if (accountcurrency != NULL) {
    set_has_accountcurrency();
  } else {
    clear_has_accountcurrency();
  }
  accountcurrency_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accountcurrency);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalAccountBalanceResponse.AccountCurrency)
}

// optional string TradeAccount = 5;
inline bool HistoricalAccountBalanceResponse::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalAccountBalanceResponse::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalAccountBalanceResponse::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& HistoricalAccountBalanceResponse::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void HistoricalAccountBalanceResponse::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
}
#if LANG_CXX11
inline void HistoricalAccountBalanceResponse::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
}
#endif
inline void HistoricalAccountBalanceResponse::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
}
inline void HistoricalAccountBalanceResponse::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
}
inline ::std::string* HistoricalAccountBalanceResponse::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalAccountBalanceResponse::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalAccountBalanceResponse::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalAccountBalanceResponse.TradeAccount)
}

// optional int32 TotalNumberMessages = 6;
inline bool HistoricalAccountBalanceResponse::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalAccountBalanceResponse::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalAccountBalanceResponse::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 HistoricalAccountBalanceResponse::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void HistoricalAccountBalanceResponse::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.TotalNumberMessages)
}

// optional int32 MessageNumber = 7;
inline bool HistoricalAccountBalanceResponse::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalAccountBalanceResponse::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalAccountBalanceResponse::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 HistoricalAccountBalanceResponse::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.MessageNumber)
  return messagenumber_;
}
inline void HistoricalAccountBalanceResponse::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.MessageNumber)
}

// optional uint32 NoAccountBalances = 8;
inline bool HistoricalAccountBalanceResponse::has_noaccountbalances() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_noaccountbalances() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalAccountBalanceResponse::clear_has_noaccountbalances() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalAccountBalanceResponse::clear_noaccountbalances() {
  noaccountbalances_ = 0u;
  clear_has_noaccountbalances();
}
inline ::google::protobuf::uint32 HistoricalAccountBalanceResponse::noaccountbalances() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.NoAccountBalances)
  return noaccountbalances_;
}
inline void HistoricalAccountBalanceResponse::set_noaccountbalances(::google::protobuf::uint32 value) {
  set_has_noaccountbalances();
  noaccountbalances_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.NoAccountBalances)
}

// optional string InfoText = 9;
inline bool HistoricalAccountBalanceResponse::has_infotext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_infotext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalAccountBalanceResponse::clear_has_infotext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalAccountBalanceResponse::clear_infotext() {
  infotext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infotext();
}
inline const ::std::string& HistoricalAccountBalanceResponse::infotext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
  return infotext_.GetNoArena();
}
inline void HistoricalAccountBalanceResponse::set_infotext(const ::std::string& value) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
}
#if LANG_CXX11
inline void HistoricalAccountBalanceResponse::set_infotext(::std::string&& value) {
  set_has_infotext();
  infotext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
}
#endif
inline void HistoricalAccountBalanceResponse::set_infotext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
}
inline void HistoricalAccountBalanceResponse::set_infotext(const char* value, size_t size) {
  set_has_infotext();
  infotext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
}
inline ::std::string* HistoricalAccountBalanceResponse::mutable_infotext() {
  set_has_infotext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
  return infotext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalAccountBalanceResponse::release_infotext() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
  if (!has_infotext()) {
    return NULL;
  }
  clear_has_infotext();
  return infotext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalAccountBalanceResponse::set_allocated_infotext(::std::string* infotext) {
  if (infotext != NULL) {
    set_has_infotext();
  } else {
    clear_has_infotext();
  }
  infotext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infotext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalAccountBalanceResponse.InfoText)
}

// optional string TransactionId = 10;
inline bool HistoricalAccountBalanceResponse::has_transactionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalAccountBalanceResponse::set_has_transactionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalAccountBalanceResponse::clear_has_transactionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalAccountBalanceResponse::clear_transactionid() {
  transactionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transactionid();
}
inline const ::std::string& HistoricalAccountBalanceResponse::transactionid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
  return transactionid_.GetNoArena();
}
inline void HistoricalAccountBalanceResponse::set_transactionid(const ::std::string& value) {
  set_has_transactionid();
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
}
#if LANG_CXX11
inline void HistoricalAccountBalanceResponse::set_transactionid(::std::string&& value) {
  set_has_transactionid();
  transactionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
}
#endif
inline void HistoricalAccountBalanceResponse::set_transactionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_transactionid();
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
}
inline void HistoricalAccountBalanceResponse::set_transactionid(const char* value, size_t size) {
  set_has_transactionid();
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
}
inline ::std::string* HistoricalAccountBalanceResponse::mutable_transactionid() {
  set_has_transactionid();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
  return transactionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalAccountBalanceResponse::release_transactionid() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
  if (!has_transactionid()) {
    return NULL;
  }
  clear_has_transactionid();
  return transactionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalAccountBalanceResponse::set_allocated_transactionid(::std::string* transactionid) {
  if (transactionid != NULL) {
    set_has_transactionid();
  } else {
    clear_has_transactionid();
  }
  transactionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transactionid);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalAccountBalanceResponse.TransactionId)
}

// -------------------------------------------------------------------

// UserMessage

// optional string UserMessage = 1;
inline bool UserMessage::has_usermessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMessage::set_has_usermessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMessage::clear_has_usermessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMessage::clear_usermessage() {
  usermessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_usermessage();
}
inline const ::std::string& UserMessage::usermessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UserMessage.UserMessage)
  return usermessage_.GetNoArena();
}
inline void UserMessage::set_usermessage(const ::std::string& value) {
  set_has_usermessage();
  usermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.UserMessage.UserMessage)
}
#if LANG_CXX11
inline void UserMessage::set_usermessage(::std::string&& value) {
  set_has_usermessage();
  usermessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.UserMessage.UserMessage)
}
#endif
inline void UserMessage::set_usermessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_usermessage();
  usermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.UserMessage.UserMessage)
}
inline void UserMessage::set_usermessage(const char* value, size_t size) {
  set_has_usermessage();
  usermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.UserMessage.UserMessage)
}
inline ::std::string* UserMessage::mutable_usermessage() {
  set_has_usermessage();
  // @@protoc_insertion_point(field_mutable:DTC_PB.UserMessage.UserMessage)
  return usermessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserMessage::release_usermessage() {
  // @@protoc_insertion_point(field_release:DTC_PB.UserMessage.UserMessage)
  if (!has_usermessage()) {
    return NULL;
  }
  clear_has_usermessage();
  return usermessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserMessage::set_allocated_usermessage(::std::string* usermessage) {
  if (usermessage != NULL) {
    set_has_usermessage();
  } else {
    clear_has_usermessage();
  }
  usermessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usermessage);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.UserMessage.UserMessage)
}

// optional uint32 IsPopupMessage = 2;
inline bool UserMessage::has_ispopupmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMessage::set_has_ispopupmessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMessage::clear_has_ispopupmessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMessage::clear_ispopupmessage() {
  ispopupmessage_ = 0u;
  clear_has_ispopupmessage();
}
inline ::google::protobuf::uint32 UserMessage::ispopupmessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UserMessage.IsPopupMessage)
  return ispopupmessage_;
}
inline void UserMessage::set_ispopupmessage(::google::protobuf::uint32 value) {
  set_has_ispopupmessage();
  ispopupmessage_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.UserMessage.IsPopupMessage)
}

// -------------------------------------------------------------------

// GeneralLogMessage

// optional string MessageText = 3;
inline bool GeneralLogMessage::has_messagetext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeneralLogMessage::set_has_messagetext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeneralLogMessage::clear_has_messagetext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeneralLogMessage::clear_messagetext() {
  messagetext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagetext();
}
inline const ::std::string& GeneralLogMessage::messagetext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.GeneralLogMessage.MessageText)
  return messagetext_.GetNoArena();
}
inline void GeneralLogMessage::set_messagetext(const ::std::string& value) {
  set_has_messagetext();
  messagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.GeneralLogMessage.MessageText)
}
#if LANG_CXX11
inline void GeneralLogMessage::set_messagetext(::std::string&& value) {
  set_has_messagetext();
  messagetext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.GeneralLogMessage.MessageText)
}
#endif
inline void GeneralLogMessage::set_messagetext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messagetext();
  messagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.GeneralLogMessage.MessageText)
}
inline void GeneralLogMessage::set_messagetext(const char* value, size_t size) {
  set_has_messagetext();
  messagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.GeneralLogMessage.MessageText)
}
inline ::std::string* GeneralLogMessage::mutable_messagetext() {
  set_has_messagetext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.GeneralLogMessage.MessageText)
  return messagetext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeneralLogMessage::release_messagetext() {
  // @@protoc_insertion_point(field_release:DTC_PB.GeneralLogMessage.MessageText)
  if (!has_messagetext()) {
    return NULL;
  }
  clear_has_messagetext();
  return messagetext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeneralLogMessage::set_allocated_messagetext(::std::string* messagetext) {
  if (messagetext != NULL) {
    set_has_messagetext();
  } else {
    clear_has_messagetext();
  }
  messagetext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagetext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.GeneralLogMessage.MessageText)
}

// -------------------------------------------------------------------

// JournalEntryAdd

// optional string JournalEntry = 1;
inline bool JournalEntryAdd::has_journalentry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JournalEntryAdd::set_has_journalentry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JournalEntryAdd::clear_has_journalentry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JournalEntryAdd::clear_journalentry() {
  journalentry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_journalentry();
}
inline const ::std::string& JournalEntryAdd::journalentry() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntryAdd.JournalEntry)
  return journalentry_.GetNoArena();
}
inline void JournalEntryAdd::set_journalentry(const ::std::string& value) {
  set_has_journalentry();
  journalentry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntryAdd.JournalEntry)
}
#if LANG_CXX11
inline void JournalEntryAdd::set_journalentry(::std::string&& value) {
  set_has_journalentry();
  journalentry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.JournalEntryAdd.JournalEntry)
}
#endif
inline void JournalEntryAdd::set_journalentry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_journalentry();
  journalentry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.JournalEntryAdd.JournalEntry)
}
inline void JournalEntryAdd::set_journalentry(const char* value, size_t size) {
  set_has_journalentry();
  journalentry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.JournalEntryAdd.JournalEntry)
}
inline ::std::string* JournalEntryAdd::mutable_journalentry() {
  set_has_journalentry();
  // @@protoc_insertion_point(field_mutable:DTC_PB.JournalEntryAdd.JournalEntry)
  return journalentry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JournalEntryAdd::release_journalentry() {
  // @@protoc_insertion_point(field_release:DTC_PB.JournalEntryAdd.JournalEntry)
  if (!has_journalentry()) {
    return NULL;
  }
  clear_has_journalentry();
  return journalentry_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JournalEntryAdd::set_allocated_journalentry(::std::string* journalentry) {
  if (journalentry != NULL) {
    set_has_journalentry();
  } else {
    clear_has_journalentry();
  }
  journalentry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), journalentry);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.JournalEntryAdd.JournalEntry)
}

// optional sfixed64 DateTime = 2;
inline bool JournalEntryAdd::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JournalEntryAdd::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JournalEntryAdd::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JournalEntryAdd::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 JournalEntryAdd::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntryAdd.DateTime)
  return datetime_;
}
inline void JournalEntryAdd::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntryAdd.DateTime)
}

// -------------------------------------------------------------------

// JournalEntriesRequest

// optional int32 RequestID = 1;
inline bool JournalEntriesRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JournalEntriesRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JournalEntriesRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JournalEntriesRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 JournalEntriesRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntriesRequest.RequestID)
  return requestid_;
}
inline void JournalEntriesRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntriesRequest.RequestID)
}

// optional sfixed64 StartDateTime = 2;
inline bool JournalEntriesRequest::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JournalEntriesRequest::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JournalEntriesRequest::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JournalEntriesRequest::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 JournalEntriesRequest::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntriesRequest.StartDateTime)
  return startdatetime_;
}
inline void JournalEntriesRequest::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntriesRequest.StartDateTime)
}

// -------------------------------------------------------------------

// JournalEntriesReject

// optional int32 RequestID = 1;
inline bool JournalEntriesReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JournalEntriesReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JournalEntriesReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JournalEntriesReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 JournalEntriesReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntriesReject.RequestID)
  return requestid_;
}
inline void JournalEntriesReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntriesReject.RequestID)
}

// optional string RejectText = 2;
inline bool JournalEntriesReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JournalEntriesReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JournalEntriesReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JournalEntriesReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& JournalEntriesReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntriesReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void JournalEntriesReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntriesReject.RejectText)
}
#if LANG_CXX11
inline void JournalEntriesReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.JournalEntriesReject.RejectText)
}
#endif
inline void JournalEntriesReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.JournalEntriesReject.RejectText)
}
inline void JournalEntriesReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.JournalEntriesReject.RejectText)
}
inline ::std::string* JournalEntriesReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.JournalEntriesReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JournalEntriesReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.JournalEntriesReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JournalEntriesReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.JournalEntriesReject.RejectText)
}

// -------------------------------------------------------------------

// JournalEntryResponse

// optional string JournalEntry = 1;
inline bool JournalEntryResponse::has_journalentry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JournalEntryResponse::set_has_journalentry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JournalEntryResponse::clear_has_journalentry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JournalEntryResponse::clear_journalentry() {
  journalentry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_journalentry();
}
inline const ::std::string& JournalEntryResponse::journalentry() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntryResponse.JournalEntry)
  return journalentry_.GetNoArena();
}
inline void JournalEntryResponse::set_journalentry(const ::std::string& value) {
  set_has_journalentry();
  journalentry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntryResponse.JournalEntry)
}
#if LANG_CXX11
inline void JournalEntryResponse::set_journalentry(::std::string&& value) {
  set_has_journalentry();
  journalentry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.JournalEntryResponse.JournalEntry)
}
#endif
inline void JournalEntryResponse::set_journalentry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_journalentry();
  journalentry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.JournalEntryResponse.JournalEntry)
}
inline void JournalEntryResponse::set_journalentry(const char* value, size_t size) {
  set_has_journalentry();
  journalentry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.JournalEntryResponse.JournalEntry)
}
inline ::std::string* JournalEntryResponse::mutable_journalentry() {
  set_has_journalentry();
  // @@protoc_insertion_point(field_mutable:DTC_PB.JournalEntryResponse.JournalEntry)
  return journalentry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JournalEntryResponse::release_journalentry() {
  // @@protoc_insertion_point(field_release:DTC_PB.JournalEntryResponse.JournalEntry)
  if (!has_journalentry()) {
    return NULL;
  }
  clear_has_journalentry();
  return journalentry_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JournalEntryResponse::set_allocated_journalentry(::std::string* journalentry) {
  if (journalentry != NULL) {
    set_has_journalentry();
  } else {
    clear_has_journalentry();
  }
  journalentry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), journalentry);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.JournalEntryResponse.JournalEntry)
}

// optional sfixed64 DateTime = 2;
inline bool JournalEntryResponse::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JournalEntryResponse::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JournalEntryResponse::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JournalEntryResponse::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 JournalEntryResponse::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntryResponse.DateTime)
  return datetime_;
}
inline void JournalEntryResponse::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntryResponse.DateTime)
}

// optional uint32 IsFinalResponse = 3;
inline bool JournalEntryResponse::has_isfinalresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JournalEntryResponse::set_has_isfinalresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JournalEntryResponse::clear_has_isfinalresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JournalEntryResponse::clear_isfinalresponse() {
  isfinalresponse_ = 0u;
  clear_has_isfinalresponse();
}
inline ::google::protobuf::uint32 JournalEntryResponse::isfinalresponse() const {
  // @@protoc_insertion_point(field_get:DTC_PB.JournalEntryResponse.IsFinalResponse)
  return isfinalresponse_;
}
inline void JournalEntryResponse::set_isfinalresponse(::google::protobuf::uint32 value) {
  set_has_isfinalresponse();
  isfinalresponse_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.JournalEntryResponse.IsFinalResponse)
}

// -------------------------------------------------------------------

// AlertMessage

// optional string MessageText = 3;
inline bool AlertMessage::has_messagetext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertMessage::set_has_messagetext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertMessage::clear_has_messagetext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertMessage::clear_messagetext() {
  messagetext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagetext();
}
inline const ::std::string& AlertMessage::messagetext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AlertMessage.MessageText)
  return messagetext_.GetNoArena();
}
inline void AlertMessage::set_messagetext(const ::std::string& value) {
  set_has_messagetext();
  messagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.AlertMessage.MessageText)
}
#if LANG_CXX11
inline void AlertMessage::set_messagetext(::std::string&& value) {
  set_has_messagetext();
  messagetext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.AlertMessage.MessageText)
}
#endif
inline void AlertMessage::set_messagetext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messagetext();
  messagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.AlertMessage.MessageText)
}
inline void AlertMessage::set_messagetext(const char* value, size_t size) {
  set_has_messagetext();
  messagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AlertMessage.MessageText)
}
inline ::std::string* AlertMessage::mutable_messagetext() {
  set_has_messagetext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.AlertMessage.MessageText)
  return messagetext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AlertMessage::release_messagetext() {
  // @@protoc_insertion_point(field_release:DTC_PB.AlertMessage.MessageText)
  if (!has_messagetext()) {
    return NULL;
  }
  clear_has_messagetext();
  return messagetext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlertMessage::set_allocated_messagetext(::std::string* messagetext) {
  if (messagetext != NULL) {
    set_has_messagetext();
  } else {
    clear_has_messagetext();
  }
  messagetext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagetext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AlertMessage.MessageText)
}

// optional string TradeAccount = 4;
inline bool AlertMessage::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlertMessage::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlertMessage::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlertMessage::clear_tradeaccount() {
  tradeaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradeaccount();
}
inline const ::std::string& AlertMessage::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AlertMessage.TradeAccount)
  return tradeaccount_.GetNoArena();
}
inline void AlertMessage::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.AlertMessage.TradeAccount)
}
#if LANG_CXX11
inline void AlertMessage::set_tradeaccount(::std::string&& value) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.AlertMessage.TradeAccount)
}
#endif
inline void AlertMessage::set_tradeaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.AlertMessage.TradeAccount)
}
inline void AlertMessage::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  tradeaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AlertMessage.TradeAccount)
}
inline ::std::string* AlertMessage::mutable_tradeaccount() {
  set_has_tradeaccount();
  // @@protoc_insertion_point(field_mutable:DTC_PB.AlertMessage.TradeAccount)
  return tradeaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AlertMessage::release_tradeaccount() {
  // @@protoc_insertion_point(field_release:DTC_PB.AlertMessage.TradeAccount)
  if (!has_tradeaccount()) {
    return NULL;
  }
  clear_has_tradeaccount();
  return tradeaccount_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlertMessage::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount != NULL) {
    set_has_tradeaccount();
  } else {
    clear_has_tradeaccount();
  }
  tradeaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradeaccount);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AlertMessage.TradeAccount)
}

// -------------------------------------------------------------------

// HistoricalPriceDataRequest

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.RequestID)
}

// optional string Symbol = 2;
inline bool HistoricalPriceDataRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataRequest::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& HistoricalPriceDataRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.Symbol)
  return symbol_.GetNoArena();
}
inline void HistoricalPriceDataRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.Symbol)
}
#if LANG_CXX11
inline void HistoricalPriceDataRequest::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalPriceDataRequest.Symbol)
}
#endif
inline void HistoricalPriceDataRequest::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalPriceDataRequest.Symbol)
}
inline void HistoricalPriceDataRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalPriceDataRequest.Symbol)
}
inline ::std::string* HistoricalPriceDataRequest::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalPriceDataRequest.Symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalPriceDataRequest::release_symbol() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalPriceDataRequest.Symbol)
  if (!has_symbol()) {
    return NULL;
  }
  clear_has_symbol();
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalPriceDataRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalPriceDataRequest.Symbol)
}

// optional string Exchange = 3;
inline bool HistoricalPriceDataRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataRequest::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exchange();
}
inline const ::std::string& HistoricalPriceDataRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.Exchange)
  return exchange_.GetNoArena();
}
inline void HistoricalPriceDataRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.Exchange)
}
#if LANG_CXX11
inline void HistoricalPriceDataRequest::set_exchange(::std::string&& value) {
  set_has_exchange();
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalPriceDataRequest.Exchange)
}
#endif
inline void HistoricalPriceDataRequest::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalPriceDataRequest.Exchange)
}
inline void HistoricalPriceDataRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalPriceDataRequest.Exchange)
}
inline ::std::string* HistoricalPriceDataRequest::mutable_exchange() {
  set_has_exchange();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalPriceDataRequest.Exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalPriceDataRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalPriceDataRequest.Exchange)
  if (!has_exchange()) {
    return NULL;
  }
  clear_has_exchange();
  return exchange_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalPriceDataRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    set_has_exchange();
  } else {
    clear_has_exchange();
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalPriceDataRequest.Exchange)
}

// optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 4;
inline bool HistoricalPriceDataRequest::has_recordinterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_recordinterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataRequest::clear_has_recordinterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataRequest::clear_recordinterval() {
  recordinterval_ = 0;
  clear_has_recordinterval();
}
inline ::DTC_PB::HistoricalDataIntervalEnum HistoricalPriceDataRequest::recordinterval() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.RecordInterval)
  return static_cast< ::DTC_PB::HistoricalDataIntervalEnum >(recordinterval_);
}
inline void HistoricalPriceDataRequest::set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value) {
  assert(::DTC_PB::HistoricalDataIntervalEnum_IsValid(value));
  set_has_recordinterval();
  recordinterval_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.RecordInterval)
}

// optional sfixed64 StartDateTime = 5;
inline bool HistoricalPriceDataRequest::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataRequest::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataRequest::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRequest::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.StartDateTime)
  return startdatetime_;
}
inline void HistoricalPriceDataRequest::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.StartDateTime)
}

// optional sfixed64 EndDateTime = 6;
inline bool HistoricalPriceDataRequest::has_enddatetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_enddatetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataRequest::clear_has_enddatetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataRequest::clear_enddatetime() {
  enddatetime_ = GOOGLE_LONGLONG(0);
  clear_has_enddatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRequest::enddatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.EndDateTime)
  return enddatetime_;
}
inline void HistoricalPriceDataRequest::set_enddatetime(::google::protobuf::int64 value) {
  set_has_enddatetime();
  enddatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.EndDateTime)
}

// optional uint32 MaxDaysToReturn = 7;
inline bool HistoricalPriceDataRequest::has_maxdaystoreturn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_maxdaystoreturn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalPriceDataRequest::clear_has_maxdaystoreturn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalPriceDataRequest::clear_maxdaystoreturn() {
  maxdaystoreturn_ = 0u;
  clear_has_maxdaystoreturn();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::maxdaystoreturn() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.MaxDaysToReturn)
  return maxdaystoreturn_;
}
inline void HistoricalPriceDataRequest::set_maxdaystoreturn(::google::protobuf::uint32 value) {
  set_has_maxdaystoreturn();
  maxdaystoreturn_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.MaxDaysToReturn)
}

// optional uint32 UseZLibCompression = 8;
inline bool HistoricalPriceDataRequest::has_usezlibcompression() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_usezlibcompression() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalPriceDataRequest::clear_has_usezlibcompression() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalPriceDataRequest::clear_usezlibcompression() {
  usezlibcompression_ = 0u;
  clear_has_usezlibcompression();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::usezlibcompression() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.UseZLibCompression)
  return usezlibcompression_;
}
inline void HistoricalPriceDataRequest::set_usezlibcompression(::google::protobuf::uint32 value) {
  set_has_usezlibcompression();
  usezlibcompression_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.UseZLibCompression)
}

// optional uint32 RequestDividendAdjustedStockData = 9;
inline bool HistoricalPriceDataRequest::has_requestdividendadjustedstockdata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_requestdividendadjustedstockdata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalPriceDataRequest::clear_has_requestdividendadjustedstockdata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalPriceDataRequest::clear_requestdividendadjustedstockdata() {
  requestdividendadjustedstockdata_ = 0u;
  clear_has_requestdividendadjustedstockdata();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::requestdividendadjustedstockdata() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.RequestDividendAdjustedStockData)
  return requestdividendadjustedstockdata_;
}
inline void HistoricalPriceDataRequest::set_requestdividendadjustedstockdata(::google::protobuf::uint32 value) {
  set_has_requestdividendadjustedstockdata();
  requestdividendadjustedstockdata_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.RequestDividendAdjustedStockData)
}

// optional uint32 Flag_1 = 10;
inline bool HistoricalPriceDataRequest::has_flag_1() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_flag_1() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalPriceDataRequest::clear_has_flag_1() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalPriceDataRequest::clear_flag_1() {
  flag_1_ = 0u;
  clear_has_flag_1();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::flag_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.Flag_1)
  return flag_1_;
}
inline void HistoricalPriceDataRequest::set_flag_1(::google::protobuf::uint32 value) {
  set_has_flag_1();
  flag_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.Flag_1)
}

// -------------------------------------------------------------------

// HistoricalPriceDataResponseHeader

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataResponseHeader::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataResponseHeader::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataResponseHeader::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataResponseHeader::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.RequestID)
}

// optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 2;
inline bool HistoricalPriceDataResponseHeader::has_recordinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_recordinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_recordinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataResponseHeader::clear_recordinterval() {
  recordinterval_ = 0;
  clear_has_recordinterval();
}
inline ::DTC_PB::HistoricalDataIntervalEnum HistoricalPriceDataResponseHeader::recordinterval() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.RecordInterval)
  return static_cast< ::DTC_PB::HistoricalDataIntervalEnum >(recordinterval_);
}
inline void HistoricalPriceDataResponseHeader::set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value) {
  assert(::DTC_PB::HistoricalDataIntervalEnum_IsValid(value));
  set_has_recordinterval();
  recordinterval_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.RecordInterval)
}

// optional uint32 UseZLibCompression = 3;
inline bool HistoricalPriceDataResponseHeader::has_usezlibcompression() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_usezlibcompression() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_usezlibcompression() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataResponseHeader::clear_usezlibcompression() {
  usezlibcompression_ = 0u;
  clear_has_usezlibcompression();
}
inline ::google::protobuf::uint32 HistoricalPriceDataResponseHeader::usezlibcompression() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.UseZLibCompression)
  return usezlibcompression_;
}
inline void HistoricalPriceDataResponseHeader::set_usezlibcompression(::google::protobuf::uint32 value) {
  set_has_usezlibcompression();
  usezlibcompression_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.UseZLibCompression)
}

// optional uint32 NoRecordsToReturn = 4;
inline bool HistoricalPriceDataResponseHeader::has_norecordstoreturn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_norecordstoreturn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_norecordstoreturn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataResponseHeader::clear_norecordstoreturn() {
  norecordstoreturn_ = 0u;
  clear_has_norecordstoreturn();
}
inline ::google::protobuf::uint32 HistoricalPriceDataResponseHeader::norecordstoreturn() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.NoRecordsToReturn)
  return norecordstoreturn_;
}
inline void HistoricalPriceDataResponseHeader::set_norecordstoreturn(::google::protobuf::uint32 value) {
  set_has_norecordstoreturn();
  norecordstoreturn_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.NoRecordsToReturn)
}

// optional float IntToFloatPriceDivisor = 5;
inline bool HistoricalPriceDataResponseHeader::has_inttofloatpricedivisor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_inttofloatpricedivisor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_inttofloatpricedivisor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataResponseHeader::clear_inttofloatpricedivisor() {
  inttofloatpricedivisor_ = 0;
  clear_has_inttofloatpricedivisor();
}
inline float HistoricalPriceDataResponseHeader::inttofloatpricedivisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.IntToFloatPriceDivisor)
  return inttofloatpricedivisor_;
}
inline void HistoricalPriceDataResponseHeader::set_inttofloatpricedivisor(float value) {
  set_has_inttofloatpricedivisor();
  inttofloatpricedivisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.IntToFloatPriceDivisor)
}

// -------------------------------------------------------------------

// HistoricalPriceDataReject

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataReject.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataReject.RequestID)
}

// optional string RejectText = 2;
inline bool HistoricalPriceDataReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataReject::clear_rejecttext() {
  rejecttext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rejecttext();
}
inline const ::std::string& HistoricalPriceDataReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataReject.RejectText)
  return rejecttext_.GetNoArena();
}
inline void HistoricalPriceDataReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataReject.RejectText)
}
#if LANG_CXX11
inline void HistoricalPriceDataReject::set_rejecttext(::std::string&& value) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DTC_PB.HistoricalPriceDataReject.RejectText)
}
#endif
inline void HistoricalPriceDataReject::set_rejecttext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalPriceDataReject.RejectText)
}
inline void HistoricalPriceDataReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  rejecttext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalPriceDataReject.RejectText)
}
inline ::std::string* HistoricalPriceDataReject::mutable_rejecttext() {
  set_has_rejecttext();
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalPriceDataReject.RejectText)
  return rejecttext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoricalPriceDataReject::release_rejecttext() {
  // @@protoc_insertion_point(field_release:DTC_PB.HistoricalPriceDataReject.RejectText)
  if (!has_rejecttext()) {
    return NULL;
  }
  clear_has_rejecttext();
  return rejecttext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoricalPriceDataReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext != NULL) {
    set_has_rejecttext();
  } else {
    clear_has_rejecttext();
  }
  rejecttext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rejecttext);
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalPriceDataReject.RejectText)
}

// optional .DTC_PB.HistoricalPriceDataRejectReasonCodeEnum RejectReasonCode = 3;
inline bool HistoricalPriceDataReject::has_rejectreasoncode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataReject::set_has_rejectreasoncode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataReject::clear_has_rejectreasoncode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataReject::clear_rejectreasoncode() {
  rejectreasoncode_ = 0;
  clear_has_rejectreasoncode();
}
inline ::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum HistoricalPriceDataReject::rejectreasoncode() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataReject.RejectReasonCode)
  return static_cast< ::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum >(rejectreasoncode_);
}
inline void HistoricalPriceDataReject::set_rejectreasoncode(::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum value) {
  assert(::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum_IsValid(value));
  set_has_rejectreasoncode();
  rejectreasoncode_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataReject.RejectReasonCode)
}

// optional uint32 RetryTimeInSeconds = 4;
inline bool HistoricalPriceDataReject::has_retrytimeinseconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataReject::set_has_retrytimeinseconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataReject::clear_has_retrytimeinseconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataReject::clear_retrytimeinseconds() {
  retrytimeinseconds_ = 0u;
  clear_has_retrytimeinseconds();
}
inline ::google::protobuf::uint32 HistoricalPriceDataReject::retrytimeinseconds() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataReject.RetryTimeInSeconds)
  return retrytimeinseconds_;
}
inline void HistoricalPriceDataReject::set_retrytimeinseconds(::google::protobuf::uint32 value) {
  set_has_retrytimeinseconds();
  retrytimeinseconds_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataReject.RetryTimeInSeconds)
}

// -------------------------------------------------------------------

// HistoricalPriceDataRecordResponse

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataRecordResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataRecordResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataRecordResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.RequestID)
}

// optional sfixed64 StartDateTime = 2;
inline bool HistoricalPriceDataRecordResponse::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataRecordResponse::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRecordResponse::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.StartDateTime)
  return startdatetime_;
}
inline void HistoricalPriceDataRecordResponse::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.StartDateTime)
}

// optional double OpenPrice = 3;
inline bool HistoricalPriceDataRecordResponse::has_openprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_openprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataRecordResponse::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline double HistoricalPriceDataRecordResponse::openprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.OpenPrice)
  return openprice_;
}
inline void HistoricalPriceDataRecordResponse::set_openprice(double value) {
  set_has_openprice();
  openprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.OpenPrice)
}

// optional double HighPrice = 4;
inline bool HistoricalPriceDataRecordResponse::has_highprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_highprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_highprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataRecordResponse::clear_highprice() {
  highprice_ = 0;
  clear_has_highprice();
}
inline double HistoricalPriceDataRecordResponse::highprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.HighPrice)
  return highprice_;
}
inline void HistoricalPriceDataRecordResponse::set_highprice(double value) {
  set_has_highprice();
  highprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.HighPrice)
}

// optional double LowPrice = 5;
inline bool HistoricalPriceDataRecordResponse::has_lowprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_lowprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_lowprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataRecordResponse::clear_lowprice() {
  lowprice_ = 0;
  clear_has_lowprice();
}
inline double HistoricalPriceDataRecordResponse::lowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.LowPrice)
  return lowprice_;
}
inline void HistoricalPriceDataRecordResponse::set_lowprice(double value) {
  set_has_lowprice();
  lowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.LowPrice)
}

// optional double LastPrice = 6;
inline bool HistoricalPriceDataRecordResponse::has_lastprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_lastprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_lastprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalPriceDataRecordResponse::clear_lastprice() {
  lastprice_ = 0;
  clear_has_lastprice();
}
inline double HistoricalPriceDataRecordResponse::lastprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.LastPrice)
  return lastprice_;
}
inline void HistoricalPriceDataRecordResponse::set_lastprice(double value) {
  set_has_lastprice();
  lastprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.LastPrice)
}

// optional double Volume = 7;
inline bool HistoricalPriceDataRecordResponse::has_volume() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_volume() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_volume() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalPriceDataRecordResponse::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double HistoricalPriceDataRecordResponse::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.Volume)
  return volume_;
}
inline void HistoricalPriceDataRecordResponse::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.Volume)
}

// optional uint32 NumTrades = 8;
inline bool HistoricalPriceDataRecordResponse::has_numtrades() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_numtrades() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_numtrades() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataRecordResponse::clear_numtrades() {
  numtrades_ = 0u;
  clear_has_numtrades();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse::numtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.NumTrades)
  return numtrades_;
}
inline void HistoricalPriceDataRecordResponse::set_numtrades(::google::protobuf::uint32 value) {
  set_has_numtrades();
  numtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.NumTrades)
}

// optional double BidVolume = 9;
inline bool HistoricalPriceDataRecordResponse::has_bidvolume() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_bidvolume() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_bidvolume() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalPriceDataRecordResponse::clear_bidvolume() {
  bidvolume_ = 0;
  clear_has_bidvolume();
}
inline double HistoricalPriceDataRecordResponse::bidvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.BidVolume)
  return bidvolume_;
}
inline void HistoricalPriceDataRecordResponse::set_bidvolume(double value) {
  set_has_bidvolume();
  bidvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.BidVolume)
}

// optional double AskVolume = 10;
inline bool HistoricalPriceDataRecordResponse::has_askvolume() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_askvolume() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_askvolume() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalPriceDataRecordResponse::clear_askvolume() {
  askvolume_ = 0;
  clear_has_askvolume();
}
inline double HistoricalPriceDataRecordResponse::askvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.AskVolume)
  return askvolume_;
}
inline void HistoricalPriceDataRecordResponse::set_askvolume(double value) {
  set_has_askvolume();
  askvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.AskVolume)
}

// optional uint32 IsFinalRecord = 11;
inline bool HistoricalPriceDataRecordResponse::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoricalPriceDataRecordResponse::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataRecordResponse::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataTickRecordResponse

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataTickRecordResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataTickRecordResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.RequestID)
}

// optional double DateTime = 2;
inline bool HistoricalPriceDataTickRecordResponse::has_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double HistoricalPriceDataTickRecordResponse::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.DateTime)
  return datetime_;
}
inline void HistoricalPriceDataTickRecordResponse::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.DateTime)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 3;
inline bool HistoricalPriceDataTickRecordResponse::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum HistoricalPriceDataTickRecordResponse::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void HistoricalPriceDataTickRecordResponse::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.AtBidOrAsk)
}

// optional double Price = 4;
inline bool HistoricalPriceDataTickRecordResponse::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double HistoricalPriceDataTickRecordResponse::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.Price)
  return price_;
}
inline void HistoricalPriceDataTickRecordResponse::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.Price)
}

// optional double Volume = 5;
inline bool HistoricalPriceDataTickRecordResponse::has_volume() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_volume() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_volume() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double HistoricalPriceDataTickRecordResponse::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.Volume)
  return volume_;
}
inline void HistoricalPriceDataTickRecordResponse::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.Volume)
}

// optional uint32 IsFinalRecord = 6;
inline bool HistoricalPriceDataTickRecordResponse::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataTickRecordResponse::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataTickRecordResponse::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataRecordResponse_Int

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataRecordResponse_Int::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.RequestID)
}

// optional sfixed64 StartDateTime = 2;
inline bool HistoricalPriceDataRecordResponse_Int::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRecordResponse_Int::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.StartDateTime)
  return startdatetime_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.StartDateTime)
}

// optional int32 OpenPrice = 3;
inline bool HistoricalPriceDataRecordResponse_Int::has_openprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_openprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::openprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.OpenPrice)
  return openprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_openprice(::google::protobuf::int32 value) {
  set_has_openprice();
  openprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.OpenPrice)
}

// optional int32 HighPrice = 4;
inline bool HistoricalPriceDataRecordResponse_Int::has_highprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_highprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_highprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_highprice() {
  highprice_ = 0;
  clear_has_highprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::highprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.HighPrice)
  return highprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_highprice(::google::protobuf::int32 value) {
  set_has_highprice();
  highprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.HighPrice)
}

// optional int32 LowPrice = 5;
inline bool HistoricalPriceDataRecordResponse_Int::has_lowprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_lowprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_lowprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_lowprice() {
  lowprice_ = 0;
  clear_has_lowprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::lowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.LowPrice)
  return lowprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_lowprice(::google::protobuf::int32 value) {
  set_has_lowprice();
  lowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.LowPrice)
}

// optional int32 LastPrice = 6;
inline bool HistoricalPriceDataRecordResponse_Int::has_lastprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_lastprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_lastprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_lastprice() {
  lastprice_ = 0;
  clear_has_lastprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::lastprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.LastPrice)
  return lastprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_lastprice(::google::protobuf::int32 value) {
  set_has_lastprice();
  lastprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.LastPrice)
}

// optional int32 Volume = 7;
inline bool HistoricalPriceDataRecordResponse_Int::has_volume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_volume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_volume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.Volume)
  return volume_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.Volume)
}

// optional uint32 NumTrades = 8;
inline bool HistoricalPriceDataRecordResponse_Int::has_numtrades() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_numtrades() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_numtrades() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_numtrades() {
  numtrades_ = 0u;
  clear_has_numtrades();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse_Int::numtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.NumTrades)
  return numtrades_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_numtrades(::google::protobuf::uint32 value) {
  set_has_numtrades();
  numtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.NumTrades)
}

// optional int32 BidVolume = 9;
inline bool HistoricalPriceDataRecordResponse_Int::has_bidvolume() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_bidvolume() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_bidvolume() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_bidvolume() {
  bidvolume_ = 0;
  clear_has_bidvolume();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::bidvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.BidVolume)
  return bidvolume_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_bidvolume(::google::protobuf::int32 value) {
  set_has_bidvolume();
  bidvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.BidVolume)
}

// optional int32 AskVolume = 10;
inline bool HistoricalPriceDataRecordResponse_Int::has_askvolume() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_askvolume() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_askvolume() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_askvolume() {
  askvolume_ = 0;
  clear_has_askvolume();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::askvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.AskVolume)
  return askvolume_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_askvolume(::google::protobuf::int32 value) {
  set_has_askvolume();
  askvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.AskVolume)
}

// optional uint32 IsFinalRecord = 11;
inline bool HistoricalPriceDataRecordResponse_Int::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse_Int::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataTickRecordResponse_Int

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse_Int::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.RequestID)
}

// optional double DateTime = 2;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double HistoricalPriceDataTickRecordResponse_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.DateTime)
  return datetime_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.DateTime)
}

// optional int32 Price = 3;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Price)
  return price_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Price)
}

// optional int32 Volume = 4;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse_Int::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Volume)
  return volume_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Volume)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum HistoricalPriceDataTickRecordResponse_Int::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.AtBidOrAsk)
}

// optional uint32 IsFinalRecord = 6;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataTickRecordResponse_Int::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataResponseTrailer

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataResponseTrailer::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataResponseTrailer::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataResponseTrailer::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataResponseTrailer::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataResponseTrailer::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseTrailer.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataResponseTrailer::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseTrailer.RequestID)
}

// optional double FinalRecordLastDateTime = 2;
inline bool HistoricalPriceDataResponseTrailer::has_finalrecordlastdatetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataResponseTrailer::set_has_finalrecordlastdatetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataResponseTrailer::clear_has_finalrecordlastdatetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataResponseTrailer::clear_finalrecordlastdatetime() {
  finalrecordlastdatetime_ = 0;
  clear_has_finalrecordlastdatetime();
}
inline double HistoricalPriceDataResponseTrailer::finalrecordlastdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseTrailer.FinalRecordLastDateTime)
  return finalrecordlastdatetime_;
}
inline void HistoricalPriceDataResponseTrailer::set_finalrecordlastdatetime(double value) {
  set_has_finalrecordlastdatetime();
  finalrecordlastdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseTrailer.FinalRecordLastDateTime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DTC_PB

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DTC_PB::DTCVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::DTCVersion>() {
  return ::DTC_PB::DTCVersion_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::DTCMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::DTCMessageType>() {
  return ::DTC_PB::DTCMessageType_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::EncodingEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::EncodingEnum>() {
  return ::DTC_PB::EncodingEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::LogonStatusEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::LogonStatusEnum>() {
  return ::DTC_PB::LogonStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::MessageSupportedEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::MessageSupportedEnum>() {
  return ::DTC_PB::MessageSupportedEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::TradeModeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::TradeModeEnum>() {
  return ::DTC_PB::TradeModeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::RequestActionEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::RequestActionEnum>() {
  return ::DTC_PB::RequestActionEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::UnbundledTradeIndicatorEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::UnbundledTradeIndicatorEnum>() {
  return ::DTC_PB::UnbundledTradeIndicatorEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OrderStatusEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OrderStatusEnum>() {
  return ::DTC_PB::OrderStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OrderUpdateReasonEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OrderUpdateReasonEnum>() {
  return ::DTC_PB::OrderUpdateReasonEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::AtBidOrAskEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::AtBidOrAskEnum>() {
  return ::DTC_PB::AtBidOrAskEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::AtBidOrAskEnum8> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::AtBidOrAskEnum8>() {
  return ::DTC_PB::AtBidOrAskEnum8_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::MarketDepthUpdateTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::MarketDepthUpdateTypeEnum>() {
  return ::DTC_PB::MarketDepthUpdateTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OrderTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OrderTypeEnum>() {
  return ::DTC_PB::OrderTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::TimeInForceEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::TimeInForceEnum>() {
  return ::DTC_PB::TimeInForceEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::BuySellEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::BuySellEnum>() {
  return ::DTC_PB::BuySellEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OpenCloseTradeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OpenCloseTradeEnum>() {
  return ::DTC_PB::OpenCloseTradeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::PartialFillHandlingEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::PartialFillHandlingEnum>() {
  return ::DTC_PB::PartialFillHandlingEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::MarketDataFeedStatusEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::MarketDataFeedStatusEnum>() {
  return ::DTC_PB::MarketDataFeedStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::PriceDisplayFormatEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::PriceDisplayFormatEnum>() {
  return ::DTC_PB::PriceDisplayFormatEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::SecurityTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::SecurityTypeEnum>() {
  return ::DTC_PB::SecurityTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::PutCallEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::PutCallEnum>() {
  return ::DTC_PB::PutCallEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::SearchTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::SearchTypeEnum>() {
  return ::DTC_PB::SearchTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::HistoricalDataIntervalEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::HistoricalDataIntervalEnum>() {
  return ::DTC_PB::HistoricalDataIntervalEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum>() {
  return ::DTC_PB::HistoricalPriceDataRejectReasonCodeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::TradingStatusEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::TradingStatusEnum>() {
  return ::DTC_PB::TradingStatusEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_DTCProtocol_2eproto
